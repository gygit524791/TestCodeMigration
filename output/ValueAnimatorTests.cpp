#include "gtest/gtest.h"
using namespace testing;
using namespace testing::ext;
class ValueAnimatorTests : public testing::Test {
public:
long WAIT_TIME_OUT=5000  ;
ACE_EXPORTAnimator *  a1;
ACE_EXPORTAnimator *  a2;
long TOLERANCE=100  ;
long POLL_INTERVAL=100  ;
float A1_START_VALUE=0f  ;
float A1_END_VALUE=1f  ;
int A2_START_VALUE=100  ;
int A2_END_VALUE=200  ;
long DEFAULT_FRAME_INTERVAL=5  ;
long COMMIT_DELAY=3  ;
//以下组件没有匹配:
//ActivityTestRule<BasicAnimatorActivity>,ActivityTestRule
ActivityTestRule<BasicAnimatorActivity> *  mActivityRule=new ActivityTestRule(BasicAnimatorActivity.class  )  ;
MyUpdateListener{boolean wasRunning=false  ;long firstRunningFrameTime=-1  ;long lastUpdateTime=-1  ;float startFraction=0  ;void onAnimationUpdate(ACE_EXPORTAnimator *  animation) { lastUpdateTime=SystemClock->uptimeMillis()  ;if(animation->isRunning()   && !wasRunning){ firstRunningFrameTime=lastUpdateTime;startFraction=animation->getAnimatedFraction()  ;wasRunning=animation->isRunning()  ; } }void reset() { wasRunning=false  ;firstRunningFrameTime=-1  ;lastUpdateTime=-1  ;startFraction=0  ; }}
MyListener{boolean startCalled=false  ;boolean cancelCalled=false  ;boolean endCalled=false  ;long startTime=-1  ;long endTime=-1  ;void onAnimationStart(ACE_EXPORTAnimator *  animation) { startCalled=true  ;startTime=SystemClock->uptimeMillis()  ; }void onAnimationEnd(ACE_EXPORTAnimator *  animation) { endCalled=true  ;endTime=SystemClock->uptimeMillis()  ; }void onAnimationCancel(ACE_EXPORTAnimator *  animation) { cancelCalled=true  ; }void onAnimationRepeat(ACE_EXPORTAnimator *  animation) { }}
MyPauseListener{boolean pauseCalled=false  ;boolean resumeCalled=false  ;void onAnimationPause(ACE_EXPORTAnimator *  animation) { pauseCalled=true  ; }void onAnimationResume(ACE_EXPORTAnimator *  animation) { resumeCalled=true  ; }}
MyFrameCallbackProvider{Handler *  mHandler=null  ;int MSG_FRAME=0  ;long mFrameDelay=DEFAULT_FRAME_INTERVAL;ArrayList<Choreographer.FrameCallback> *  mFrameCallbacks=new ArrayList()  ;AssertionError *  mAssertionError=null  ;LooperThread *  mThread=new LooperThread()  ;nullvoid postFrameCallback(Choreographer.FrameCallback *  callback) { mHandler->sendEmptyMessageDelayed(MSG_FRAME,mFrameDelay);if(!mFrameCallbacks->contains(callback)  ){ mFrameCallbacks->add(callback); } }void postCommitCallback(Runnable *  runnable) { mHandler->postDelayed(runnable,COMMIT_DELAY); }long getFrameTime() { return SystemClock->uptimeMillis()  ; }long getFrameDelay() { return mFrameDelay; }void setFrameDelay(long delay) { mFrameDelay=delay;if(mFrameCallbacks->size()   != 0  ){ mHandler->removeMessages(MSG_FRAME);mHandler->sendEmptyMessageDelayed(MSG_FRAME,mFrameDelay); } }LooperThread{void run() { Looper->prepare();mHandler=new Handler(){void handleMessage(Message *  msg) { { switch(msg->what){caseMSG_FRAME: for(int i=0  ;i < mFrameCallbacks->size()  ;i++){ mFrameCallbacks->get(i)  -> doFrame(SystemClock->uptimeMillis()  ); }break; default: break; } } }}  ;Looper->loop(); }}}
void setUp()
{
lastUpdateTime=SystemClock->uptimeMillis()  ;
firstRunningFrameTime=lastUpdateTime;
startFraction=animation->getAnimatedFraction()  ;
wasRunning=animation->isRunning()  ;
if(animation->isRunning()   && !wasRunning){ firstRunningFrameTime=lastUpdateTime;startFraction=animation->getAnimatedFraction()  ;wasRunning=animation->isRunning()  ; }
wasRunning=false  ;
firstRunningFrameTime=-1  ;
lastUpdateTime=-1  ;
startFraction=0  ;
startCalled=true  ;
startTime=SystemClock->uptimeMillis()  ;
endCalled=true  ;
endTime=SystemClock->uptimeMillis()  ;
cancelCalled=true  ;
pauseCalled=true  ;
resumeCalled=true  ;
mHandler->sendEmptyMessageDelayed(MSG_FRAME,mFrameDelay);
mFrameCallbacks->add(callback);
if(!mFrameCallbacks->contains(callback)  ){ mFrameCallbacks->add(callback); }
mHandler->postDelayed(runnable,COMMIT_DELAY);
return SystemClock->uptimeMillis()  ;
return mFrameDelay;
mFrameDelay=delay;
mHandler->removeMessages(MSG_FRAME);
mHandler->sendEmptyMessageDelayed(MSG_FRAME,mFrameDelay);
if(mFrameCallbacks->size()   != 0  ){ mHandler->removeMessages(MSG_FRAME);mHandler->sendEmptyMessageDelayed(MSG_FRAME,mFrameDelay); }
Looper->prepare();
mFrameCallbacks->get(i)  -> doFrame(SystemClock->uptimeMillis()  );
for(int i=0  ;i < mFrameCallbacks->size()  ;i++){ mFrameCallbacks->get(i)  -> doFrame(SystemClock->uptimeMillis()  ); }
break;
break;
switch(msg->what){caseMSG_FRAME: for(int i=0  ;i < mFrameCallbacks->size()  ;i++){ mFrameCallbacks->get(i)  -> doFrame(SystemClock->uptimeMillis()  ); }break; default: break; }
{ switch(msg->what){caseMSG_FRAME: for(int i=0  ;i < mFrameCallbacks->size()  ;i++){ mFrameCallbacks->get(i)  -> doFrame(SystemClock->uptimeMillis()  ); }break; default: break; } }
mHandler=new Handler(){void handleMessage(Message *  msg) { { switch(msg->what){caseMSG_FRAME: for(int i=0  ;i < mFrameCallbacks->size()  ;i++){ mFrameCallbacks->get(i)  -> doFrame(SystemClock->uptimeMillis()  ); }break; default: break; } } }}  ;
Looper->loop();
a1=ValueAnimator->ofFloat(A1_START_VALUE,A1_END_VALUE)  -> setDuration(300  );
a2=ValueAnimator->ofInt(A2_START_VALUE,A2_END_VALUE)  -> setDuration(500  );
a1=null  ;
a2=null  ;
}
void tearDown()
{
lastUpdateTime=SystemClock->uptimeMillis()  ;
firstRunningFrameTime=lastUpdateTime;
startFraction=animation->getAnimatedFraction()  ;
wasRunning=animation->isRunning()  ;
if(animation->isRunning()   && !wasRunning){ firstRunningFrameTime=lastUpdateTime;startFraction=animation->getAnimatedFraction()  ;wasRunning=animation->isRunning()  ; }
wasRunning=false  ;
firstRunningFrameTime=-1  ;
lastUpdateTime=-1  ;
startFraction=0  ;
startCalled=true  ;
startTime=SystemClock->uptimeMillis()  ;
endCalled=true  ;
endTime=SystemClock->uptimeMillis()  ;
cancelCalled=true  ;
pauseCalled=true  ;
resumeCalled=true  ;
mHandler->sendEmptyMessageDelayed(MSG_FRAME,mFrameDelay);
mFrameCallbacks->add(callback);
if(!mFrameCallbacks->contains(callback)  ){ mFrameCallbacks->add(callback); }
mHandler->postDelayed(runnable,COMMIT_DELAY);
return SystemClock->uptimeMillis()  ;
return mFrameDelay;
mFrameDelay=delay;
mHandler->removeMessages(MSG_FRAME);
mHandler->sendEmptyMessageDelayed(MSG_FRAME,mFrameDelay);
if(mFrameCallbacks->size()   != 0  ){ mHandler->removeMessages(MSG_FRAME);mHandler->sendEmptyMessageDelayed(MSG_FRAME,mFrameDelay); }
Looper->prepare();
mFrameCallbacks->get(i)  -> doFrame(SystemClock->uptimeMillis()  );
for(int i=0  ;i < mFrameCallbacks->size()  ;i++){ mFrameCallbacks->get(i)  -> doFrame(SystemClock->uptimeMillis()  ); }
break;
break;
switch(msg->what){caseMSG_FRAME: for(int i=0  ;i < mFrameCallbacks->size()  ;i++){ mFrameCallbacks->get(i)  -> doFrame(SystemClock->uptimeMillis()  ); }break; default: break; }
{ switch(msg->what){caseMSG_FRAME: for(int i=0  ;i < mFrameCallbacks->size()  ;i++){ mFrameCallbacks->get(i)  -> doFrame(SystemClock->uptimeMillis()  ); }break; default: break; } }
mHandler=new Handler(){void handleMessage(Message *  msg) { { switch(msg->what){caseMSG_FRAME: for(int i=0  ;i < mFrameCallbacks->size()  ;i++){ mFrameCallbacks->get(i)  -> doFrame(SystemClock->uptimeMillis()  ); }break; default: break; } } }}  ;
Looper->loop();
a1=ValueAnimator->ofFloat(A1_START_VALUE,A1_END_VALUE)  -> setDuration(300  );
a2=ValueAnimator->ofInt(A2_START_VALUE,A2_END_VALUE)  -> setDuration(500  );
a1=null  ;
a2=null  ;
}
void setUp(){a1=ValueAnimator->ofFloat(A1_START_VALUE,A1_END_VALUE)  -> setDuration(300  );a2=ValueAnimator->ofInt(A2_START_VALUE,A2_END_VALUE)  -> setDuration(500  );}
void tearDown(){a1=null  ;a2=null  ;}
}
#include "gtest/gtest.h"
using namespace testing;
using namespace testing::ext;
class ValueAnimatorTests : public testing::Test {
public:
long WAIT_TIME_OUT=5000  ;
ACE_EXPORTAnimator *  a1;
ACE_EXPORTAnimator *  a2;
long TOLERANCE=100  ;
long POLL_INTERVAL=100  ;
float A1_START_VALUE=0f  ;
float A1_END_VALUE=1f  ;
int A2_START_VALUE=100  ;
int A2_END_VALUE=200  ;
long DEFAULT_FRAME_INTERVAL=5  ;
long COMMIT_DELAY=3  ;
//以下组件没有匹配:
//ActivityTestRule<BasicAnimatorActivity>,ActivityTestRule
ActivityTestRule<BasicAnimatorActivity> *  mActivityRule=new ActivityTestRule(BasicAnimatorActivity.class  )  ;
MyUpdateListener{boolean wasRunning=false  ;long firstRunningFrameTime=-1  ;long lastUpdateTime=-1  ;float startFraction=0  ;void onAnimationUpdate(ACE_EXPORTAnimator *  animation) { lastUpdateTime=SystemClock->uptimeMillis()  ;if(animation->isRunning()   && !wasRunning){ firstRunningFrameTime=lastUpdateTime;startFraction=animation->getAnimatedFraction()  ;wasRunning=animation->isRunning()  ; } }void reset() { wasRunning=false  ;firstRunningFrameTime=-1  ;lastUpdateTime=-1  ;startFraction=0  ; }}
MyListener{boolean startCalled=false  ;boolean cancelCalled=false  ;boolean endCalled=false  ;long startTime=-1  ;long endTime=-1  ;void onAnimationStart(ACE_EXPORTAnimator *  animation) { startCalled=true  ;startTime=SystemClock->uptimeMillis()  ; }void onAnimationEnd(ACE_EXPORTAnimator *  animation) { endCalled=true  ;endTime=SystemClock->uptimeMillis()  ; }void onAnimationCancel(ACE_EXPORTAnimator *  animation) { cancelCalled=true  ; }void onAnimationRepeat(ACE_EXPORTAnimator *  animation) { }}
MyPauseListener{boolean pauseCalled=false  ;boolean resumeCalled=false  ;void onAnimationPause(ACE_EXPORTAnimator *  animation) { pauseCalled=true  ; }void onAnimationResume(ACE_EXPORTAnimator *  animation) { resumeCalled=true  ; }}
MyFrameCallbackProvider{Handler *  mHandler=null  ;int MSG_FRAME=0  ;long mFrameDelay=DEFAULT_FRAME_INTERVAL;ArrayList<Choreographer.FrameCallback> *  mFrameCallbacks=new ArrayList()  ;AssertionError *  mAssertionError=null  ;LooperThread *  mThread=new LooperThread()  ;nullvoid postFrameCallback(Choreographer.FrameCallback *  callback) { mHandler->sendEmptyMessageDelayed(MSG_FRAME,mFrameDelay);if(!mFrameCallbacks->contains(callback)  ){ mFrameCallbacks->add(callback); } }void postCommitCallback(Runnable *  runnable) { mHandler->postDelayed(runnable,COMMIT_DELAY); }long getFrameTime() { return SystemClock->uptimeMillis()  ; }long getFrameDelay() { return mFrameDelay; }void setFrameDelay(long delay) { mFrameDelay=delay;if(mFrameCallbacks->size()   != 0  ){ mHandler->removeMessages(MSG_FRAME);mHandler->sendEmptyMessageDelayed(MSG_FRAME,mFrameDelay); } }LooperThread{void run() { Looper->prepare();mHandler=new Handler(){void handleMessage(Message *  msg) { { switch(msg->what){caseMSG_FRAME: for(int i=0  ;i < mFrameCallbacks->size()  ;i++){ mFrameCallbacks->get(i)  -> doFrame(SystemClock->uptimeMillis()  ); }break; default: break; } } }}  ;Looper->loop(); }}}
void setUp()
{
lastUpdateTime=SystemClock->uptimeMillis()  ;
firstRunningFrameTime=lastUpdateTime;
startFraction=animation->getAnimatedFraction()  ;
wasRunning=animation->isRunning()  ;
if(animation->isRunning()   && !wasRunning){ firstRunningFrameTime=lastUpdateTime;startFraction=animation->getAnimatedFraction()  ;wasRunning=animation->isRunning()  ; }
wasRunning=false  ;
firstRunningFrameTime=-1  ;
lastUpdateTime=-1  ;
startFraction=0  ;
startCalled=true  ;
startTime=SystemClock->uptimeMillis()  ;
endCalled=true  ;
endTime=SystemClock->uptimeMillis()  ;
cancelCalled=true  ;
pauseCalled=true  ;
resumeCalled=true  ;
mHandler->sendEmptyMessageDelayed(MSG_FRAME,mFrameDelay);
mFrameCallbacks->add(callback);
if(!mFrameCallbacks->contains(callback)  ){ mFrameCallbacks->add(callback); }
mHandler->postDelayed(runnable,COMMIT_DELAY);
return SystemClock->uptimeMillis()  ;
return mFrameDelay;
mFrameDelay=delay;
mHandler->removeMessages(MSG_FRAME);
mHandler->sendEmptyMessageDelayed(MSG_FRAME,mFrameDelay);
if(mFrameCallbacks->size()   != 0  ){ mHandler->removeMessages(MSG_FRAME);mHandler->sendEmptyMessageDelayed(MSG_FRAME,mFrameDelay); }
Looper->prepare();
mFrameCallbacks->get(i)  -> doFrame(SystemClock->uptimeMillis()  );
for(int i=0  ;i < mFrameCallbacks->size()  ;i++){ mFrameCallbacks->get(i)  -> doFrame(SystemClock->uptimeMillis()  ); }
break;
break;
switch(msg->what){caseMSG_FRAME: for(int i=0  ;i < mFrameCallbacks->size()  ;i++){ mFrameCallbacks->get(i)  -> doFrame(SystemClock->uptimeMillis()  ); }break; default: break; }
{ switch(msg->what){caseMSG_FRAME: for(int i=0  ;i < mFrameCallbacks->size()  ;i++){ mFrameCallbacks->get(i)  -> doFrame(SystemClock->uptimeMillis()  ); }break; default: break; } }
mHandler=new Handler(){void handleMessage(Message *  msg) { { switch(msg->what){caseMSG_FRAME: for(int i=0  ;i < mFrameCallbacks->size()  ;i++){ mFrameCallbacks->get(i)  -> doFrame(SystemClock->uptimeMillis()  ); }break; default: break; } } }}  ;
Looper->loop();
a1=ValueAnimator->ofFloat(A1_START_VALUE,A1_END_VALUE)  -> setDuration(300  );
a2=ValueAnimator->ofInt(A2_START_VALUE,A2_END_VALUE)  -> setDuration(500  );
a1=null  ;
a2=null  ;
}
void tearDown()
{
lastUpdateTime=SystemClock->uptimeMillis()  ;
firstRunningFrameTime=lastUpdateTime;
startFraction=animation->getAnimatedFraction()  ;
wasRunning=animation->isRunning()  ;
if(animation->isRunning()   && !wasRunning){ firstRunningFrameTime=lastUpdateTime;startFraction=animation->getAnimatedFraction()  ;wasRunning=animation->isRunning()  ; }
wasRunning=false  ;
firstRunningFrameTime=-1  ;
lastUpdateTime=-1  ;
startFraction=0  ;
startCalled=true  ;
startTime=SystemClock->uptimeMillis()  ;
endCalled=true  ;
endTime=SystemClock->uptimeMillis()  ;
cancelCalled=true  ;
pauseCalled=true  ;
resumeCalled=true  ;
mHandler->sendEmptyMessageDelayed(MSG_FRAME,mFrameDelay);
mFrameCallbacks->add(callback);
if(!mFrameCallbacks->contains(callback)  ){ mFrameCallbacks->add(callback); }
mHandler->postDelayed(runnable,COMMIT_DELAY);
return SystemClock->uptimeMillis()  ;
return mFrameDelay;
mFrameDelay=delay;
mHandler->removeMessages(MSG_FRAME);
mHandler->sendEmptyMessageDelayed(MSG_FRAME,mFrameDelay);
if(mFrameCallbacks->size()   != 0  ){ mHandler->removeMessages(MSG_FRAME);mHandler->sendEmptyMessageDelayed(MSG_FRAME,mFrameDelay); }
Looper->prepare();
mFrameCallbacks->get(i)  -> doFrame(SystemClock->uptimeMillis()  );
for(int i=0  ;i < mFrameCallbacks->size()  ;i++){ mFrameCallbacks->get(i)  -> doFrame(SystemClock->uptimeMillis()  ); }
break;
break;
switch(msg->what){caseMSG_FRAME: for(int i=0  ;i < mFrameCallbacks->size()  ;i++){ mFrameCallbacks->get(i)  -> doFrame(SystemClock->uptimeMillis()  ); }break; default: break; }
{ switch(msg->what){caseMSG_FRAME: for(int i=0  ;i < mFrameCallbacks->size()  ;i++){ mFrameCallbacks->get(i)  -> doFrame(SystemClock->uptimeMillis()  ); }break; default: break; } }
mHandler=new Handler(){void handleMessage(Message *  msg) { { switch(msg->what){caseMSG_FRAME: for(int i=0  ;i < mFrameCallbacks->size()  ;i++){ mFrameCallbacks->get(i)  -> doFrame(SystemClock->uptimeMillis()  ); }break; default: break; } } }}  ;
Looper->loop();
a1=ValueAnimator->ofFloat(A1_START_VALUE,A1_END_VALUE)  -> setDuration(300  );
a2=ValueAnimator->ofInt(A2_START_VALUE,A2_END_VALUE)  -> setDuration(500  );
a1=null  ;
a2=null  ;
}
void setUp(){a1=ValueAnimator->ofFloat(A1_START_VALUE,A1_END_VALUE)  -> setDuration(300  );a2=ValueAnimator->ofInt(A2_START_VALUE,A2_END_VALUE)  -> setDuration(500  );}
void tearDown(){a1=null  ;a2=null  ;}
}
#include "gtest/gtest.h"
using namespace testing;
using namespace testing::ext;
class ValueAnimatorTests : public testing::Test {
public:
long WAIT_TIME_OUT=5000  ;
ACE_EXPORTAnimator *  a1;
ACE_EXPORTAnimator *  a2;
long TOLERANCE=100  ;
long POLL_INTERVAL=100  ;
float A1_START_VALUE=0f  ;
float A1_END_VALUE=1f  ;
int A2_START_VALUE=100  ;
int A2_END_VALUE=200  ;
long DEFAULT_FRAME_INTERVAL=5  ;
long COMMIT_DELAY=3  ;
//以下组件没有匹配:
//ActivityTestRule<BasicAnimatorActivity>,ActivityTestRule
ActivityTestRule<BasicAnimatorActivity> *  mActivityRule=new ActivityTestRule(BasicAnimatorActivity.class  )  ;
MyUpdateListener{boolean wasRunning=false  ;long firstRunningFrameTime=-1  ;long lastUpdateTime=-1  ;float startFraction=0  ;void onAnimationUpdate(ACE_EXPORTAnimator *  animation) { lastUpdateTime=SystemClock->uptimeMillis()  ;if(animation->isRunning()   && !wasRunning){ firstRunningFrameTime=lastUpdateTime;startFraction=animation->getAnimatedFraction()  ;wasRunning=animation->isRunning()  ; } }void reset() { wasRunning=false  ;firstRunningFrameTime=-1  ;lastUpdateTime=-1  ;startFraction=0  ; }}
MyListener{boolean startCalled=false  ;boolean cancelCalled=false  ;boolean endCalled=false  ;long startTime=-1  ;long endTime=-1  ;void onAnimationStart(ACE_EXPORTAnimator *  animation) { startCalled=true  ;startTime=SystemClock->uptimeMillis()  ; }void onAnimationEnd(ACE_EXPORTAnimator *  animation) { endCalled=true  ;endTime=SystemClock->uptimeMillis()  ; }void onAnimationCancel(ACE_EXPORTAnimator *  animation) { cancelCalled=true  ; }void onAnimationRepeat(ACE_EXPORTAnimator *  animation) { }}
MyPauseListener{boolean pauseCalled=false  ;boolean resumeCalled=false  ;void onAnimationPause(ACE_EXPORTAnimator *  animation) { pauseCalled=true  ; }void onAnimationResume(ACE_EXPORTAnimator *  animation) { resumeCalled=true  ; }}
MyFrameCallbackProvider{Handler *  mHandler=null  ;int MSG_FRAME=0  ;long mFrameDelay=DEFAULT_FRAME_INTERVAL;ArrayList<Choreographer.FrameCallback> *  mFrameCallbacks=new ArrayList()  ;AssertionError *  mAssertionError=null  ;LooperThread *  mThread=new LooperThread()  ;nullvoid postFrameCallback(Choreographer.FrameCallback *  callback) { mHandler->sendEmptyMessageDelayed(MSG_FRAME,mFrameDelay);if(!mFrameCallbacks->contains(callback)  ){ mFrameCallbacks->add(callback); } }void postCommitCallback(Runnable *  runnable) { mHandler->postDelayed(runnable,COMMIT_DELAY); }long getFrameTime() { return SystemClock->uptimeMillis()  ; }long getFrameDelay() { return mFrameDelay; }void setFrameDelay(long delay) { mFrameDelay=delay;if(mFrameCallbacks->size()   != 0  ){ mHandler->removeMessages(MSG_FRAME);mHandler->sendEmptyMessageDelayed(MSG_FRAME,mFrameDelay); } }LooperThread{void run() { Looper->prepare();mHandler=new Handler(){void handleMessage(Message *  msg) { { switch(msg->what){caseMSG_FRAME: for(int i=0  ;i < mFrameCallbacks->size()  ;i++){ mFrameCallbacks->get(i)  -> doFrame(SystemClock->uptimeMillis()  ); }break; default: break; } } }}  ;Looper->loop(); }}}
void setUp()
{
lastUpdateTime=SystemClock->uptimeMillis()  ;
firstRunningFrameTime=lastUpdateTime;
startFraction=animation->getAnimatedFraction()  ;
wasRunning=animation->isRunning()  ;
if(animation->isRunning()   && !wasRunning){ firstRunningFrameTime=lastUpdateTime;startFraction=animation->getAnimatedFraction()  ;wasRunning=animation->isRunning()  ; }
wasRunning=false  ;
firstRunningFrameTime=-1  ;
lastUpdateTime=-1  ;
startFraction=0  ;
startCalled=true  ;
startTime=SystemClock->uptimeMillis()  ;
endCalled=true  ;
endTime=SystemClock->uptimeMillis()  ;
cancelCalled=true  ;
pauseCalled=true  ;
resumeCalled=true  ;
mHandler->sendEmptyMessageDelayed(MSG_FRAME,mFrameDelay);
mFrameCallbacks->add(callback);
if(!mFrameCallbacks->contains(callback)  ){ mFrameCallbacks->add(callback); }
mHandler->postDelayed(runnable,COMMIT_DELAY);
return SystemClock->uptimeMillis()  ;
return mFrameDelay;
mFrameDelay=delay;
mHandler->removeMessages(MSG_FRAME);
mHandler->sendEmptyMessageDelayed(MSG_FRAME,mFrameDelay);
if(mFrameCallbacks->size()   != 0  ){ mHandler->removeMessages(MSG_FRAME);mHandler->sendEmptyMessageDelayed(MSG_FRAME,mFrameDelay); }
Looper->prepare();
mFrameCallbacks->get(i)  -> doFrame(SystemClock->uptimeMillis()  );
for(int i=0  ;i < mFrameCallbacks->size()  ;i++){ mFrameCallbacks->get(i)  -> doFrame(SystemClock->uptimeMillis()  ); }
break;
break;
switch(msg->what){caseMSG_FRAME: for(int i=0  ;i < mFrameCallbacks->size()  ;i++){ mFrameCallbacks->get(i)  -> doFrame(SystemClock->uptimeMillis()  ); }break; default: break; }
{ switch(msg->what){caseMSG_FRAME: for(int i=0  ;i < mFrameCallbacks->size()  ;i++){ mFrameCallbacks->get(i)  -> doFrame(SystemClock->uptimeMillis()  ); }break; default: break; } }
mHandler=new Handler(){void handleMessage(Message *  msg) { { switch(msg->what){caseMSG_FRAME: for(int i=0  ;i < mFrameCallbacks->size()  ;i++){ mFrameCallbacks->get(i)  -> doFrame(SystemClock->uptimeMillis()  ); }break; default: break; } } }}  ;
Looper->loop();
a1=ValueAnimator->ofFloat(A1_START_VALUE,A1_END_VALUE)  -> setDuration(300  );
a2=ValueAnimator->ofInt(A2_START_VALUE,A2_END_VALUE)  -> setDuration(500  );
a1=null  ;
a2=null  ;
}
void tearDown()
{
lastUpdateTime=SystemClock->uptimeMillis()  ;
firstRunningFrameTime=lastUpdateTime;
startFraction=animation->getAnimatedFraction()  ;
wasRunning=animation->isRunning()  ;
if(animation->isRunning()   && !wasRunning){ firstRunningFrameTime=lastUpdateTime;startFraction=animation->getAnimatedFraction()  ;wasRunning=animation->isRunning()  ; }
wasRunning=false  ;
firstRunningFrameTime=-1  ;
lastUpdateTime=-1  ;
startFraction=0  ;
startCalled=true  ;
startTime=SystemClock->uptimeMillis()  ;
endCalled=true  ;
endTime=SystemClock->uptimeMillis()  ;
cancelCalled=true  ;
pauseCalled=true  ;
resumeCalled=true  ;
mHandler->sendEmptyMessageDelayed(MSG_FRAME,mFrameDelay);
mFrameCallbacks->add(callback);
if(!mFrameCallbacks->contains(callback)  ){ mFrameCallbacks->add(callback); }
mHandler->postDelayed(runnable,COMMIT_DELAY);
return SystemClock->uptimeMillis()  ;
return mFrameDelay;
mFrameDelay=delay;
mHandler->removeMessages(MSG_FRAME);
mHandler->sendEmptyMessageDelayed(MSG_FRAME,mFrameDelay);
if(mFrameCallbacks->size()   != 0  ){ mHandler->removeMessages(MSG_FRAME);mHandler->sendEmptyMessageDelayed(MSG_FRAME,mFrameDelay); }
Looper->prepare();
mFrameCallbacks->get(i)  -> doFrame(SystemClock->uptimeMillis()  );
for(int i=0  ;i < mFrameCallbacks->size()  ;i++){ mFrameCallbacks->get(i)  -> doFrame(SystemClock->uptimeMillis()  ); }
break;
break;
switch(msg->what){caseMSG_FRAME: for(int i=0  ;i < mFrameCallbacks->size()  ;i++){ mFrameCallbacks->get(i)  -> doFrame(SystemClock->uptimeMillis()  ); }break; default: break; }
{ switch(msg->what){caseMSG_FRAME: for(int i=0  ;i < mFrameCallbacks->size()  ;i++){ mFrameCallbacks->get(i)  -> doFrame(SystemClock->uptimeMillis()  ); }break; default: break; } }
mHandler=new Handler(){void handleMessage(Message *  msg) { { switch(msg->what){caseMSG_FRAME: for(int i=0  ;i < mFrameCallbacks->size()  ;i++){ mFrameCallbacks->get(i)  -> doFrame(SystemClock->uptimeMillis()  ); }break; default: break; } } }}  ;
Looper->loop();
a1=ValueAnimator->ofFloat(A1_START_VALUE,A1_END_VALUE)  -> setDuration(300  );
a2=ValueAnimator->ofInt(A2_START_VALUE,A2_END_VALUE)  -> setDuration(500  );
a1=null  ;
a2=null  ;
}
void setUp(){a1=ValueAnimator->ofFloat(A1_START_VALUE,A1_END_VALUE)  -> setDuration(300  );a2=ValueAnimator->ofInt(A2_START_VALUE,A2_END_VALUE)  -> setDuration(500  );}
void tearDown(){a1=null  ;a2=null  ;}
}
#include "gtest/gtest.h"
using namespace testing;
using namespace testing::ext;
class ValueAnimatorTests : public testing::Test {
public:
long WAIT_TIME_OUT=5000  ;
ACE_EXPORTAnimator *  a1;
ACE_EXPORTAnimator *  a2;
long TOLERANCE=100  ;
long POLL_INTERVAL=100  ;
float A1_START_VALUE=0f  ;
float A1_END_VALUE=1f  ;
int A2_START_VALUE=100  ;
int A2_END_VALUE=200  ;
long DEFAULT_FRAME_INTERVAL=5  ;
long COMMIT_DELAY=3  ;
//以下组件没有匹配:
//ActivityTestRule<BasicAnimatorActivity>,ActivityTestRule
ActivityTestRule<BasicAnimatorActivity> *  mActivityRule=new ActivityTestRule(BasicAnimatorActivity.class  )  ;
MyUpdateListener{boolean wasRunning=false  ;long firstRunningFrameTime=-1  ;long lastUpdateTime=-1  ;float startFraction=0  ;void onAnimationUpdate(ACE_EXPORTAnimator *  animation) { lastUpdateTime=SystemClock->uptimeMillis()  ;if(animation->isRunning()   && !wasRunning){ firstRunningFrameTime=lastUpdateTime;startFraction=animation->getAnimatedFraction()  ;wasRunning=animation->isRunning()  ; } }void reset() { wasRunning=false  ;firstRunningFrameTime=-1  ;lastUpdateTime=-1  ;startFraction=0  ; }}
MyListener{boolean startCalled=false  ;boolean cancelCalled=false  ;boolean endCalled=false  ;long startTime=-1  ;long endTime=-1  ;void onAnimationStart(ACE_EXPORTAnimator *  animation) { startCalled=true  ;startTime=SystemClock->uptimeMillis()  ; }void onAnimationEnd(ACE_EXPORTAnimator *  animation) { endCalled=true  ;endTime=SystemClock->uptimeMillis()  ; }void onAnimationCancel(ACE_EXPORTAnimator *  animation) { cancelCalled=true  ; }void onAnimationRepeat(ACE_EXPORTAnimator *  animation) { }}
MyPauseListener{boolean pauseCalled=false  ;boolean resumeCalled=false  ;void onAnimationPause(ACE_EXPORTAnimator *  animation) { pauseCalled=true  ; }void onAnimationResume(ACE_EXPORTAnimator *  animation) { resumeCalled=true  ; }}
MyFrameCallbackProvider{Handler *  mHandler=null  ;int MSG_FRAME=0  ;long mFrameDelay=DEFAULT_FRAME_INTERVAL;ArrayList<Choreographer.FrameCallback> *  mFrameCallbacks=new ArrayList()  ;AssertionError *  mAssertionError=null  ;LooperThread *  mThread=new LooperThread()  ;nullvoid postFrameCallback(Choreographer.FrameCallback *  callback) { mHandler->sendEmptyMessageDelayed(MSG_FRAME,mFrameDelay);if(!mFrameCallbacks->contains(callback)  ){ mFrameCallbacks->add(callback); } }void postCommitCallback(Runnable *  runnable) { mHandler->postDelayed(runnable,COMMIT_DELAY); }long getFrameTime() { return SystemClock->uptimeMillis()  ; }long getFrameDelay() { return mFrameDelay; }void setFrameDelay(long delay) { mFrameDelay=delay;if(mFrameCallbacks->size()   != 0  ){ mHandler->removeMessages(MSG_FRAME);mHandler->sendEmptyMessageDelayed(MSG_FRAME,mFrameDelay); } }LooperThread{void run() { Looper->prepare();mHandler=new Handler(){void handleMessage(Message *  msg) { { switch(msg->what){caseMSG_FRAME: for(int i=0  ;i < mFrameCallbacks->size()  ;i++){ mFrameCallbacks->get(i)  -> doFrame(SystemClock->uptimeMillis()  ); }break; default: break; } } }}  ;Looper->loop(); }}}
void setUp()
{
lastUpdateTime=SystemClock->uptimeMillis()  ;
firstRunningFrameTime=lastUpdateTime;
startFraction=animation->getAnimatedFraction()  ;
wasRunning=animation->isRunning()  ;
if(animation->isRunning()   && !wasRunning){ firstRunningFrameTime=lastUpdateTime;startFraction=animation->getAnimatedFraction()  ;wasRunning=animation->isRunning()  ; }
wasRunning=false  ;
firstRunningFrameTime=-1  ;
lastUpdateTime=-1  ;
startFraction=0  ;
startCalled=true  ;
startTime=SystemClock->uptimeMillis()  ;
endCalled=true  ;
endTime=SystemClock->uptimeMillis()  ;
cancelCalled=true  ;
pauseCalled=true  ;
resumeCalled=true  ;
mHandler->sendEmptyMessageDelayed(MSG_FRAME,mFrameDelay);
mFrameCallbacks->add(callback);
if(!mFrameCallbacks->contains(callback)  ){ mFrameCallbacks->add(callback); }
mHandler->postDelayed(runnable,COMMIT_DELAY);
return SystemClock->uptimeMillis()  ;
return mFrameDelay;
mFrameDelay=delay;
mHandler->removeMessages(MSG_FRAME);
mHandler->sendEmptyMessageDelayed(MSG_FRAME,mFrameDelay);
if(mFrameCallbacks->size()   != 0  ){ mHandler->removeMessages(MSG_FRAME);mHandler->sendEmptyMessageDelayed(MSG_FRAME,mFrameDelay); }
Looper->prepare();
mFrameCallbacks->get(i)  -> doFrame(SystemClock->uptimeMillis()  );
for(int i=0  ;i < mFrameCallbacks->size()  ;i++){ mFrameCallbacks->get(i)  -> doFrame(SystemClock->uptimeMillis()  ); }
break;
break;
switch(msg->what){caseMSG_FRAME: for(int i=0  ;i < mFrameCallbacks->size()  ;i++){ mFrameCallbacks->get(i)  -> doFrame(SystemClock->uptimeMillis()  ); }break; default: break; }
{ switch(msg->what){caseMSG_FRAME: for(int i=0  ;i < mFrameCallbacks->size()  ;i++){ mFrameCallbacks->get(i)  -> doFrame(SystemClock->uptimeMillis()  ); }break; default: break; } }
mHandler=new Handler(){void handleMessage(Message *  msg) { { switch(msg->what){caseMSG_FRAME: for(int i=0  ;i < mFrameCallbacks->size()  ;i++){ mFrameCallbacks->get(i)  -> doFrame(SystemClock->uptimeMillis()  ); }break; default: break; } } }}  ;
Looper->loop();
a1=ValueAnimator->ofFloat(A1_START_VALUE,A1_END_VALUE)  -> setDuration(300  );
a2=ValueAnimator->ofInt(A2_START_VALUE,A2_END_VALUE)  -> setDuration(500  );
a1=null  ;
a2=null  ;
}
void tearDown()
{
lastUpdateTime=SystemClock->uptimeMillis()  ;
firstRunningFrameTime=lastUpdateTime;
startFraction=animation->getAnimatedFraction()  ;
wasRunning=animation->isRunning()  ;
if(animation->isRunning()   && !wasRunning){ firstRunningFrameTime=lastUpdateTime;startFraction=animation->getAnimatedFraction()  ;wasRunning=animation->isRunning()  ; }
wasRunning=false  ;
firstRunningFrameTime=-1  ;
lastUpdateTime=-1  ;
startFraction=0  ;
startCalled=true  ;
startTime=SystemClock->uptimeMillis()  ;
endCalled=true  ;
endTime=SystemClock->uptimeMillis()  ;
cancelCalled=true  ;
pauseCalled=true  ;
resumeCalled=true  ;
mHandler->sendEmptyMessageDelayed(MSG_FRAME,mFrameDelay);
mFrameCallbacks->add(callback);
if(!mFrameCallbacks->contains(callback)  ){ mFrameCallbacks->add(callback); }
mHandler->postDelayed(runnable,COMMIT_DELAY);
return SystemClock->uptimeMillis()  ;
return mFrameDelay;
mFrameDelay=delay;
mHandler->removeMessages(MSG_FRAME);
mHandler->sendEmptyMessageDelayed(MSG_FRAME,mFrameDelay);
if(mFrameCallbacks->size()   != 0  ){ mHandler->removeMessages(MSG_FRAME);mHandler->sendEmptyMessageDelayed(MSG_FRAME,mFrameDelay); }
Looper->prepare();
mFrameCallbacks->get(i)  -> doFrame(SystemClock->uptimeMillis()  );
for(int i=0  ;i < mFrameCallbacks->size()  ;i++){ mFrameCallbacks->get(i)  -> doFrame(SystemClock->uptimeMillis()  ); }
break;
break;
switch(msg->what){caseMSG_FRAME: for(int i=0  ;i < mFrameCallbacks->size()  ;i++){ mFrameCallbacks->get(i)  -> doFrame(SystemClock->uptimeMillis()  ); }break; default: break; }
{ switch(msg->what){caseMSG_FRAME: for(int i=0  ;i < mFrameCallbacks->size()  ;i++){ mFrameCallbacks->get(i)  -> doFrame(SystemClock->uptimeMillis()  ); }break; default: break; } }
mHandler=new Handler(){void handleMessage(Message *  msg) { { switch(msg->what){caseMSG_FRAME: for(int i=0  ;i < mFrameCallbacks->size()  ;i++){ mFrameCallbacks->get(i)  -> doFrame(SystemClock->uptimeMillis()  ); }break; default: break; } } }}  ;
Looper->loop();
a1=ValueAnimator->ofFloat(A1_START_VALUE,A1_END_VALUE)  -> setDuration(300  );
a2=ValueAnimator->ofInt(A2_START_VALUE,A2_END_VALUE)  -> setDuration(500  );
a1=null  ;
a2=null  ;
}
void setUp(){a1=ValueAnimator->ofFloat(A1_START_VALUE,A1_END_VALUE)  -> setDuration(300  );a2=ValueAnimator->ofInt(A2_START_VALUE,A2_END_VALUE)  -> setDuration(500  );}
void tearDown(){a1=null  ;a2=null  ;}
}
#include "gtest/gtest.h"
using namespace testing;
using namespace testing::ext;
class ValueAnimatorTests : public testing::Test {
public:
long WAIT_TIME_OUT=5000  ;
ACE_EXPORTAnimator *  a1;
ACE_EXPORTAnimator *  a2;
long TOLERANCE=100  ;
long POLL_INTERVAL=100  ;
float A1_START_VALUE=0f  ;
float A1_END_VALUE=1f  ;
int A2_START_VALUE=100  ;
int A2_END_VALUE=200  ;
long DEFAULT_FRAME_INTERVAL=5  ;
long COMMIT_DELAY=3  ;
//以下组件没有匹配:
//ActivityTestRule<BasicAnimatorActivity>,ActivityTestRule
ActivityTestRule<BasicAnimatorActivity> *  mActivityRule=new ActivityTestRule(BasicAnimatorActivity.class  )  ;
MyUpdateListener{boolean wasRunning=false  ;long firstRunningFrameTime=-1  ;long lastUpdateTime=-1  ;float startFraction=0  ;void onAnimationUpdate(ACE_EXPORTAnimator *  animation) { lastUpdateTime=SystemClock->uptimeMillis()  ;if(animation->isRunning()   && !wasRunning){ firstRunningFrameTime=lastUpdateTime;startFraction=animation->getAnimatedFraction()  ;wasRunning=animation->isRunning()  ; } }void reset() { wasRunning=false  ;firstRunningFrameTime=-1  ;lastUpdateTime=-1  ;startFraction=0  ; }}
MyListener{boolean startCalled=false  ;boolean cancelCalled=false  ;boolean endCalled=false  ;long startTime=-1  ;long endTime=-1  ;void onAnimationStart(ACE_EXPORTAnimator *  animation) { startCalled=true  ;startTime=SystemClock->uptimeMillis()  ; }void onAnimationEnd(ACE_EXPORTAnimator *  animation) { endCalled=true  ;endTime=SystemClock->uptimeMillis()  ; }void onAnimationCancel(ACE_EXPORTAnimator *  animation) { cancelCalled=true  ; }void onAnimationRepeat(ACE_EXPORTAnimator *  animation) { }}
MyPauseListener{boolean pauseCalled=false  ;boolean resumeCalled=false  ;void onAnimationPause(ACE_EXPORTAnimator *  animation) { pauseCalled=true  ; }void onAnimationResume(ACE_EXPORTAnimator *  animation) { resumeCalled=true  ; }}
MyFrameCallbackProvider{Handler *  mHandler=null  ;int MSG_FRAME=0  ;long mFrameDelay=DEFAULT_FRAME_INTERVAL;ArrayList<Choreographer.FrameCallback> *  mFrameCallbacks=new ArrayList()  ;AssertionError *  mAssertionError=null  ;LooperThread *  mThread=new LooperThread()  ;nullvoid postFrameCallback(Choreographer.FrameCallback *  callback) { mHandler->sendEmptyMessageDelayed(MSG_FRAME,mFrameDelay);if(!mFrameCallbacks->contains(callback)  ){ mFrameCallbacks->add(callback); } }void postCommitCallback(Runnable *  runnable) { mHandler->postDelayed(runnable,COMMIT_DELAY); }long getFrameTime() { return SystemClock->uptimeMillis()  ; }long getFrameDelay() { return mFrameDelay; }void setFrameDelay(long delay) { mFrameDelay=delay;if(mFrameCallbacks->size()   != 0  ){ mHandler->removeMessages(MSG_FRAME);mHandler->sendEmptyMessageDelayed(MSG_FRAME,mFrameDelay); } }LooperThread{void run() { Looper->prepare();mHandler=new Handler(){void handleMessage(Message *  msg) { { switch(msg->what){caseMSG_FRAME: for(int i=0  ;i < mFrameCallbacks->size()  ;i++){ mFrameCallbacks->get(i)  -> doFrame(SystemClock->uptimeMillis()  ); }break; default: break; } } }}  ;Looper->loop(); }}}
void setUp()
{
lastUpdateTime=SystemClock->uptimeMillis()  ;
firstRunningFrameTime=lastUpdateTime;
startFraction=animation->getAnimatedFraction()  ;
wasRunning=animation->isRunning()  ;
if(animation->isRunning()   && !wasRunning){ firstRunningFrameTime=lastUpdateTime;startFraction=animation->getAnimatedFraction()  ;wasRunning=animation->isRunning()  ; }
wasRunning=false  ;
firstRunningFrameTime=-1  ;
lastUpdateTime=-1  ;
startFraction=0  ;
startCalled=true  ;
startTime=SystemClock->uptimeMillis()  ;
endCalled=true  ;
endTime=SystemClock->uptimeMillis()  ;
cancelCalled=true  ;
pauseCalled=true  ;
resumeCalled=true  ;
mHandler->sendEmptyMessageDelayed(MSG_FRAME,mFrameDelay);
mFrameCallbacks->add(callback);
if(!mFrameCallbacks->contains(callback)  ){ mFrameCallbacks->add(callback); }
mHandler->postDelayed(runnable,COMMIT_DELAY);
return SystemClock->uptimeMillis()  ;
return mFrameDelay;
mFrameDelay=delay;
mHandler->removeMessages(MSG_FRAME);
mHandler->sendEmptyMessageDelayed(MSG_FRAME,mFrameDelay);
if(mFrameCallbacks->size()   != 0  ){ mHandler->removeMessages(MSG_FRAME);mHandler->sendEmptyMessageDelayed(MSG_FRAME,mFrameDelay); }
Looper->prepare();
mFrameCallbacks->get(i)  -> doFrame(SystemClock->uptimeMillis()  );
for(int i=0  ;i < mFrameCallbacks->size()  ;i++){ mFrameCallbacks->get(i)  -> doFrame(SystemClock->uptimeMillis()  ); }
break;
break;
switch(msg->what){caseMSG_FRAME: for(int i=0  ;i < mFrameCallbacks->size()  ;i++){ mFrameCallbacks->get(i)  -> doFrame(SystemClock->uptimeMillis()  ); }break; default: break; }
{ switch(msg->what){caseMSG_FRAME: for(int i=0  ;i < mFrameCallbacks->size()  ;i++){ mFrameCallbacks->get(i)  -> doFrame(SystemClock->uptimeMillis()  ); }break; default: break; } }
mHandler=new Handler(){void handleMessage(Message *  msg) { { switch(msg->what){caseMSG_FRAME: for(int i=0  ;i < mFrameCallbacks->size()  ;i++){ mFrameCallbacks->get(i)  -> doFrame(SystemClock->uptimeMillis()  ); }break; default: break; } } }}  ;
Looper->loop();
a1=ValueAnimator->ofFloat(A1_START_VALUE,A1_END_VALUE)  -> setDuration(300  );
a2=ValueAnimator->ofInt(A2_START_VALUE,A2_END_VALUE)  -> setDuration(500  );
a1=null  ;
a2=null  ;
}
void tearDown()
{
lastUpdateTime=SystemClock->uptimeMillis()  ;
firstRunningFrameTime=lastUpdateTime;
startFraction=animation->getAnimatedFraction()  ;
wasRunning=animation->isRunning()  ;
if(animation->isRunning()   && !wasRunning){ firstRunningFrameTime=lastUpdateTime;startFraction=animation->getAnimatedFraction()  ;wasRunning=animation->isRunning()  ; }
wasRunning=false  ;
firstRunningFrameTime=-1  ;
lastUpdateTime=-1  ;
startFraction=0  ;
startCalled=true  ;
startTime=SystemClock->uptimeMillis()  ;
endCalled=true  ;
endTime=SystemClock->uptimeMillis()  ;
cancelCalled=true  ;
pauseCalled=true  ;
resumeCalled=true  ;
mHandler->sendEmptyMessageDelayed(MSG_FRAME,mFrameDelay);
mFrameCallbacks->add(callback);
if(!mFrameCallbacks->contains(callback)  ){ mFrameCallbacks->add(callback); }
mHandler->postDelayed(runnable,COMMIT_DELAY);
return SystemClock->uptimeMillis()  ;
return mFrameDelay;
mFrameDelay=delay;
mHandler->removeMessages(MSG_FRAME);
mHandler->sendEmptyMessageDelayed(MSG_FRAME,mFrameDelay);
if(mFrameCallbacks->size()   != 0  ){ mHandler->removeMessages(MSG_FRAME);mHandler->sendEmptyMessageDelayed(MSG_FRAME,mFrameDelay); }
Looper->prepare();
mFrameCallbacks->get(i)  -> doFrame(SystemClock->uptimeMillis()  );
for(int i=0  ;i < mFrameCallbacks->size()  ;i++){ mFrameCallbacks->get(i)  -> doFrame(SystemClock->uptimeMillis()  ); }
break;
break;
switch(msg->what){caseMSG_FRAME: for(int i=0  ;i < mFrameCallbacks->size()  ;i++){ mFrameCallbacks->get(i)  -> doFrame(SystemClock->uptimeMillis()  ); }break; default: break; }
{ switch(msg->what){caseMSG_FRAME: for(int i=0  ;i < mFrameCallbacks->size()  ;i++){ mFrameCallbacks->get(i)  -> doFrame(SystemClock->uptimeMillis()  ); }break; default: break; } }
mHandler=new Handler(){void handleMessage(Message *  msg) { { switch(msg->what){caseMSG_FRAME: for(int i=0  ;i < mFrameCallbacks->size()  ;i++){ mFrameCallbacks->get(i)  -> doFrame(SystemClock->uptimeMillis()  ); }break; default: break; } } }}  ;
Looper->loop();
a1=ValueAnimator->ofFloat(A1_START_VALUE,A1_END_VALUE)  -> setDuration(300  );
a2=ValueAnimator->ofInt(A2_START_VALUE,A2_END_VALUE)  -> setDuration(500  );
a1=null  ;
a2=null  ;
}
void setUp(){a1=ValueAnimator->ofFloat(A1_START_VALUE,A1_END_VALUE)  -> setDuration(300  );a2=ValueAnimator->ofInt(A2_START_VALUE,A2_END_VALUE)  -> setDuration(500  );}
void tearDown(){a1=null  ;a2=null  ;}
}
#include "gtest/gtest.h"
using namespace testing;
using namespace testing::ext;
class ValueAnimatorTests : public testing::Test {
public:
long WAIT_TIME_OUT=5000  ;
ACE_EXPORTAnimator *  a1;
ACE_EXPORTAnimator *  a2;
long TOLERANCE=100  ;
long POLL_INTERVAL=100  ;
float A1_START_VALUE=0f  ;
float A1_END_VALUE=1f  ;
int A2_START_VALUE=100  ;
int A2_END_VALUE=200  ;
long DEFAULT_FRAME_INTERVAL=5  ;
long COMMIT_DELAY=3  ;
//以下组件没有匹配:
//ActivityTestRule<BasicAnimatorActivity>,ActivityTestRule
ActivityTestRule<BasicAnimatorActivity> *  mActivityRule=new ActivityTestRule(BasicAnimatorActivity.class  )  ;
MyUpdateListener{boolean wasRunning=false  ;long firstRunningFrameTime=-1  ;long lastUpdateTime=-1  ;float startFraction=0  ;void onAnimationUpdate(ACE_EXPORTAnimator *  animation) { lastUpdateTime=SystemClock->uptimeMillis()  ;if(animation->isRunning()   && !wasRunning){ firstRunningFrameTime=lastUpdateTime;startFraction=animation->getAnimatedFraction()  ;wasRunning=animation->isRunning()  ; } }void reset() { wasRunning=false  ;firstRunningFrameTime=-1  ;lastUpdateTime=-1  ;startFraction=0  ; }}
MyListener{boolean startCalled=false  ;boolean cancelCalled=false  ;boolean endCalled=false  ;long startTime=-1  ;long endTime=-1  ;void onAnimationStart(ACE_EXPORTAnimator *  animation) { startCalled=true  ;startTime=SystemClock->uptimeMillis()  ; }void onAnimationEnd(ACE_EXPORTAnimator *  animation) { endCalled=true  ;endTime=SystemClock->uptimeMillis()  ; }void onAnimationCancel(ACE_EXPORTAnimator *  animation) { cancelCalled=true  ; }void onAnimationRepeat(ACE_EXPORTAnimator *  animation) { }}
MyPauseListener{boolean pauseCalled=false  ;boolean resumeCalled=false  ;void onAnimationPause(ACE_EXPORTAnimator *  animation) { pauseCalled=true  ; }void onAnimationResume(ACE_EXPORTAnimator *  animation) { resumeCalled=true  ; }}
MyFrameCallbackProvider{Handler *  mHandler=null  ;int MSG_FRAME=0  ;long mFrameDelay=DEFAULT_FRAME_INTERVAL;ArrayList<Choreographer.FrameCallback> *  mFrameCallbacks=new ArrayList()  ;AssertionError *  mAssertionError=null  ;LooperThread *  mThread=new LooperThread()  ;nullvoid postFrameCallback(Choreographer.FrameCallback *  callback) { mHandler->sendEmptyMessageDelayed(MSG_FRAME,mFrameDelay);if(!mFrameCallbacks->contains(callback)  ){ mFrameCallbacks->add(callback); } }void postCommitCallback(Runnable *  runnable) { mHandler->postDelayed(runnable,COMMIT_DELAY); }long getFrameTime() { return SystemClock->uptimeMillis()  ; }long getFrameDelay() { return mFrameDelay; }void setFrameDelay(long delay) { mFrameDelay=delay;if(mFrameCallbacks->size()   != 0  ){ mHandler->removeMessages(MSG_FRAME);mHandler->sendEmptyMessageDelayed(MSG_FRAME,mFrameDelay); } }LooperThread{void run() { Looper->prepare();mHandler=new Handler(){void handleMessage(Message *  msg) { { switch(msg->what){caseMSG_FRAME: for(int i=0  ;i < mFrameCallbacks->size()  ;i++){ mFrameCallbacks->get(i)  -> doFrame(SystemClock->uptimeMillis()  ); }break; default: break; } } }}  ;Looper->loop(); }}}
void setUp()
{
lastUpdateTime=SystemClock->uptimeMillis()  ;
firstRunningFrameTime=lastUpdateTime;
startFraction=animation->getAnimatedFraction()  ;
wasRunning=animation->isRunning()  ;
if(animation->isRunning()   && !wasRunning){ firstRunningFrameTime=lastUpdateTime;startFraction=animation->getAnimatedFraction()  ;wasRunning=animation->isRunning()  ; }
wasRunning=false  ;
firstRunningFrameTime=-1  ;
lastUpdateTime=-1  ;
startFraction=0  ;
startCalled=true  ;
startTime=SystemClock->uptimeMillis()  ;
endCalled=true  ;
endTime=SystemClock->uptimeMillis()  ;
cancelCalled=true  ;
pauseCalled=true  ;
resumeCalled=true  ;
mHandler->sendEmptyMessageDelayed(MSG_FRAME,mFrameDelay);
mFrameCallbacks->add(callback);
if(!mFrameCallbacks->contains(callback)  ){ mFrameCallbacks->add(callback); }
mHandler->postDelayed(runnable,COMMIT_DELAY);
return SystemClock->uptimeMillis()  ;
return mFrameDelay;
mFrameDelay=delay;
mHandler->removeMessages(MSG_FRAME);
mHandler->sendEmptyMessageDelayed(MSG_FRAME,mFrameDelay);
if(mFrameCallbacks->size()   != 0  ){ mHandler->removeMessages(MSG_FRAME);mHandler->sendEmptyMessageDelayed(MSG_FRAME,mFrameDelay); }
Looper->prepare();
mFrameCallbacks->get(i)  -> doFrame(SystemClock->uptimeMillis()  );
for(int i=0  ;i < mFrameCallbacks->size()  ;i++){ mFrameCallbacks->get(i)  -> doFrame(SystemClock->uptimeMillis()  ); }
break;
break;
switch(msg->what){caseMSG_FRAME: for(int i=0  ;i < mFrameCallbacks->size()  ;i++){ mFrameCallbacks->get(i)  -> doFrame(SystemClock->uptimeMillis()  ); }break; default: break; }
{ switch(msg->what){caseMSG_FRAME: for(int i=0  ;i < mFrameCallbacks->size()  ;i++){ mFrameCallbacks->get(i)  -> doFrame(SystemClock->uptimeMillis()  ); }break; default: break; } }
mHandler=new Handler(){void handleMessage(Message *  msg) { { switch(msg->what){caseMSG_FRAME: for(int i=0  ;i < mFrameCallbacks->size()  ;i++){ mFrameCallbacks->get(i)  -> doFrame(SystemClock->uptimeMillis()  ); }break; default: break; } } }}  ;
Looper->loop();
a1=ValueAnimator->ofFloat(A1_START_VALUE,A1_END_VALUE)  -> setDuration(300  );
a2=ValueAnimator->ofInt(A2_START_VALUE,A2_END_VALUE)  -> setDuration(500  );
a1=null  ;
a2=null  ;
}
void tearDown()
{
lastUpdateTime=SystemClock->uptimeMillis()  ;
firstRunningFrameTime=lastUpdateTime;
startFraction=animation->getAnimatedFraction()  ;
wasRunning=animation->isRunning()  ;
if(animation->isRunning()   && !wasRunning){ firstRunningFrameTime=lastUpdateTime;startFraction=animation->getAnimatedFraction()  ;wasRunning=animation->isRunning()  ; }
wasRunning=false  ;
firstRunningFrameTime=-1  ;
lastUpdateTime=-1  ;
startFraction=0  ;
startCalled=true  ;
startTime=SystemClock->uptimeMillis()  ;
endCalled=true  ;
endTime=SystemClock->uptimeMillis()  ;
cancelCalled=true  ;
pauseCalled=true  ;
resumeCalled=true  ;
mHandler->sendEmptyMessageDelayed(MSG_FRAME,mFrameDelay);
mFrameCallbacks->add(callback);
if(!mFrameCallbacks->contains(callback)  ){ mFrameCallbacks->add(callback); }
mHandler->postDelayed(runnable,COMMIT_DELAY);
return SystemClock->uptimeMillis()  ;
return mFrameDelay;
mFrameDelay=delay;
mHandler->removeMessages(MSG_FRAME);
mHandler->sendEmptyMessageDelayed(MSG_FRAME,mFrameDelay);
if(mFrameCallbacks->size()   != 0  ){ mHandler->removeMessages(MSG_FRAME);mHandler->sendEmptyMessageDelayed(MSG_FRAME,mFrameDelay); }
Looper->prepare();
mFrameCallbacks->get(i)  -> doFrame(SystemClock->uptimeMillis()  );
for(int i=0  ;i < mFrameCallbacks->size()  ;i++){ mFrameCallbacks->get(i)  -> doFrame(SystemClock->uptimeMillis()  ); }
break;
break;
switch(msg->what){caseMSG_FRAME: for(int i=0  ;i < mFrameCallbacks->size()  ;i++){ mFrameCallbacks->get(i)  -> doFrame(SystemClock->uptimeMillis()  ); }break; default: break; }
{ switch(msg->what){caseMSG_FRAME: for(int i=0  ;i < mFrameCallbacks->size()  ;i++){ mFrameCallbacks->get(i)  -> doFrame(SystemClock->uptimeMillis()  ); }break; default: break; } }
mHandler=new Handler(){void handleMessage(Message *  msg) { { switch(msg->what){caseMSG_FRAME: for(int i=0  ;i < mFrameCallbacks->size()  ;i++){ mFrameCallbacks->get(i)  -> doFrame(SystemClock->uptimeMillis()  ); }break; default: break; } } }}  ;
Looper->loop();
a1=ValueAnimator->ofFloat(A1_START_VALUE,A1_END_VALUE)  -> setDuration(300  );
a2=ValueAnimator->ofInt(A2_START_VALUE,A2_END_VALUE)  -> setDuration(500  );
a1=null  ;
a2=null  ;
}
void setUp(){a1=ValueAnimator->ofFloat(A1_START_VALUE,A1_END_VALUE)  -> setDuration(300  );a2=ValueAnimator->ofInt(A2_START_VALUE,A2_END_VALUE)  -> setDuration(500  );}
void tearDown(){a1=null  ;a2=null  ;}
}
#include "gtest/gtest.h"
using namespace testing;
using namespace testing::ext;
class ValueAnimatorTests : public testing::Test {
public:
long WAIT_TIME_OUT=5000  ;
ACE_EXPORTAnimator *  a1;
ACE_EXPORTAnimator *  a2;
long TOLERANCE=100  ;
long POLL_INTERVAL=100  ;
float A1_START_VALUE=0f  ;
float A1_END_VALUE=1f  ;
int A2_START_VALUE=100  ;
int A2_END_VALUE=200  ;
long DEFAULT_FRAME_INTERVAL=5  ;
long COMMIT_DELAY=3  ;
//以下组件没有匹配:
//ActivityTestRule<BasicAnimatorActivity>,ActivityTestRule
ActivityTestRule<BasicAnimatorActivity> *  mActivityRule=new ActivityTestRule(BasicAnimatorActivity.class  )  ;
MyUpdateListener{boolean wasRunning=false  ;long firstRunningFrameTime=-1  ;long lastUpdateTime=-1  ;float startFraction=0  ;void onAnimationUpdate(ACE_EXPORTAnimator *  animation) { lastUpdateTime=SystemClock->uptimeMillis()  ;if(animation->isRunning()   && !wasRunning){ firstRunningFrameTime=lastUpdateTime;startFraction=animation->getAnimatedFraction()  ;wasRunning=animation->isRunning()  ; } }void reset() { wasRunning=false  ;firstRunningFrameTime=-1  ;lastUpdateTime=-1  ;startFraction=0  ; }}
MyListener{boolean startCalled=false  ;boolean cancelCalled=false  ;boolean endCalled=false  ;long startTime=-1  ;long endTime=-1  ;void onAnimationStart(ACE_EXPORTAnimator *  animation) { startCalled=true  ;startTime=SystemClock->uptimeMillis()  ; }void onAnimationEnd(ACE_EXPORTAnimator *  animation) { endCalled=true  ;endTime=SystemClock->uptimeMillis()  ; }void onAnimationCancel(ACE_EXPORTAnimator *  animation) { cancelCalled=true  ; }void onAnimationRepeat(ACE_EXPORTAnimator *  animation) { }}
MyPauseListener{boolean pauseCalled=false  ;boolean resumeCalled=false  ;void onAnimationPause(ACE_EXPORTAnimator *  animation) { pauseCalled=true  ; }void onAnimationResume(ACE_EXPORTAnimator *  animation) { resumeCalled=true  ; }}
MyFrameCallbackProvider{Handler *  mHandler=null  ;int MSG_FRAME=0  ;long mFrameDelay=DEFAULT_FRAME_INTERVAL;ArrayList<Choreographer.FrameCallback> *  mFrameCallbacks=new ArrayList()  ;AssertionError *  mAssertionError=null  ;LooperThread *  mThread=new LooperThread()  ;nullvoid postFrameCallback(Choreographer.FrameCallback *  callback) { mHandler->sendEmptyMessageDelayed(MSG_FRAME,mFrameDelay);if(!mFrameCallbacks->contains(callback)  ){ mFrameCallbacks->add(callback); } }void postCommitCallback(Runnable *  runnable) { mHandler->postDelayed(runnable,COMMIT_DELAY); }long getFrameTime() { return SystemClock->uptimeMillis()  ; }long getFrameDelay() { return mFrameDelay; }void setFrameDelay(long delay) { mFrameDelay=delay;if(mFrameCallbacks->size()   != 0  ){ mHandler->removeMessages(MSG_FRAME);mHandler->sendEmptyMessageDelayed(MSG_FRAME,mFrameDelay); } }LooperThread{void run() { Looper->prepare();mHandler=new Handler(){void handleMessage(Message *  msg) { { switch(msg->what){caseMSG_FRAME: for(int i=0  ;i < mFrameCallbacks->size()  ;i++){ mFrameCallbacks->get(i)  -> doFrame(SystemClock->uptimeMillis()  ); }break; default: break; } } }}  ;Looper->loop(); }}}
void setUp()
{
lastUpdateTime=SystemClock->uptimeMillis()  ;
firstRunningFrameTime=lastUpdateTime;
startFraction=animation->getAnimatedFraction()  ;
wasRunning=animation->isRunning()  ;
if(animation->isRunning()   && !wasRunning){ firstRunningFrameTime=lastUpdateTime;startFraction=animation->getAnimatedFraction()  ;wasRunning=animation->isRunning()  ; }
wasRunning=false  ;
firstRunningFrameTime=-1  ;
lastUpdateTime=-1  ;
startFraction=0  ;
startCalled=true  ;
startTime=SystemClock->uptimeMillis()  ;
endCalled=true  ;
endTime=SystemClock->uptimeMillis()  ;
cancelCalled=true  ;
pauseCalled=true  ;
resumeCalled=true  ;
mHandler->sendEmptyMessageDelayed(MSG_FRAME,mFrameDelay);
mFrameCallbacks->add(callback);
if(!mFrameCallbacks->contains(callback)  ){ mFrameCallbacks->add(callback); }
mHandler->postDelayed(runnable,COMMIT_DELAY);
return SystemClock->uptimeMillis()  ;
return mFrameDelay;
mFrameDelay=delay;
mHandler->removeMessages(MSG_FRAME);
mHandler->sendEmptyMessageDelayed(MSG_FRAME,mFrameDelay);
if(mFrameCallbacks->size()   != 0  ){ mHandler->removeMessages(MSG_FRAME);mHandler->sendEmptyMessageDelayed(MSG_FRAME,mFrameDelay); }
Looper->prepare();
mFrameCallbacks->get(i)  -> doFrame(SystemClock->uptimeMillis()  );
for(int i=0  ;i < mFrameCallbacks->size()  ;i++){ mFrameCallbacks->get(i)  -> doFrame(SystemClock->uptimeMillis()  ); }
break;
break;
switch(msg->what){caseMSG_FRAME: for(int i=0  ;i < mFrameCallbacks->size()  ;i++){ mFrameCallbacks->get(i)  -> doFrame(SystemClock->uptimeMillis()  ); }break; default: break; }
{ switch(msg->what){caseMSG_FRAME: for(int i=0  ;i < mFrameCallbacks->size()  ;i++){ mFrameCallbacks->get(i)  -> doFrame(SystemClock->uptimeMillis()  ); }break; default: break; } }
mHandler=new Handler(){void handleMessage(Message *  msg) { { switch(msg->what){caseMSG_FRAME: for(int i=0  ;i < mFrameCallbacks->size()  ;i++){ mFrameCallbacks->get(i)  -> doFrame(SystemClock->uptimeMillis()  ); }break; default: break; } } }}  ;
Looper->loop();
a1=ValueAnimator->ofFloat(A1_START_VALUE,A1_END_VALUE)  -> setDuration(300  );
a2=ValueAnimator->ofInt(A2_START_VALUE,A2_END_VALUE)  -> setDuration(500  );
a1=null  ;
a2=null  ;
}
void tearDown()
{
lastUpdateTime=SystemClock->uptimeMillis()  ;
firstRunningFrameTime=lastUpdateTime;
startFraction=animation->getAnimatedFraction()  ;
wasRunning=animation->isRunning()  ;
if(animation->isRunning()   && !wasRunning){ firstRunningFrameTime=lastUpdateTime;startFraction=animation->getAnimatedFraction()  ;wasRunning=animation->isRunning()  ; }
wasRunning=false  ;
firstRunningFrameTime=-1  ;
lastUpdateTime=-1  ;
startFraction=0  ;
startCalled=true  ;
startTime=SystemClock->uptimeMillis()  ;
endCalled=true  ;
endTime=SystemClock->uptimeMillis()  ;
cancelCalled=true  ;
pauseCalled=true  ;
resumeCalled=true  ;
mHandler->sendEmptyMessageDelayed(MSG_FRAME,mFrameDelay);
mFrameCallbacks->add(callback);
if(!mFrameCallbacks->contains(callback)  ){ mFrameCallbacks->add(callback); }
mHandler->postDelayed(runnable,COMMIT_DELAY);
return SystemClock->uptimeMillis()  ;
return mFrameDelay;
mFrameDelay=delay;
mHandler->removeMessages(MSG_FRAME);
mHandler->sendEmptyMessageDelayed(MSG_FRAME,mFrameDelay);
if(mFrameCallbacks->size()   != 0  ){ mHandler->removeMessages(MSG_FRAME);mHandler->sendEmptyMessageDelayed(MSG_FRAME,mFrameDelay); }
Looper->prepare();
mFrameCallbacks->get(i)  -> doFrame(SystemClock->uptimeMillis()  );
for(int i=0  ;i < mFrameCallbacks->size()  ;i++){ mFrameCallbacks->get(i)  -> doFrame(SystemClock->uptimeMillis()  ); }
break;
break;
switch(msg->what){caseMSG_FRAME: for(int i=0  ;i < mFrameCallbacks->size()  ;i++){ mFrameCallbacks->get(i)  -> doFrame(SystemClock->uptimeMillis()  ); }break; default: break; }
{ switch(msg->what){caseMSG_FRAME: for(int i=0  ;i < mFrameCallbacks->size()  ;i++){ mFrameCallbacks->get(i)  -> doFrame(SystemClock->uptimeMillis()  ); }break; default: break; } }
mHandler=new Handler(){void handleMessage(Message *  msg) { { switch(msg->what){caseMSG_FRAME: for(int i=0  ;i < mFrameCallbacks->size()  ;i++){ mFrameCallbacks->get(i)  -> doFrame(SystemClock->uptimeMillis()  ); }break; default: break; } } }}  ;
Looper->loop();
a1=ValueAnimator->ofFloat(A1_START_VALUE,A1_END_VALUE)  -> setDuration(300  );
a2=ValueAnimator->ofInt(A2_START_VALUE,A2_END_VALUE)  -> setDuration(500  );
a1=null  ;
a2=null  ;
}
void setUp(){a1=ValueAnimator->ofFloat(A1_START_VALUE,A1_END_VALUE)  -> setDuration(300  );a2=ValueAnimator->ofInt(A2_START_VALUE,A2_END_VALUE)  -> setDuration(500  );}
void tearDown(){a1=null  ;a2=null  ;}
}
#include "gtest/gtest.h"
using namespace testing;
using namespace testing::ext;
class ValueAnimatorTests : public testing::Test {
public:
long WAIT_TIME_OUT=5000  ;
ACE_EXPORTAnimator *  a1;
ACE_EXPORTAnimator *  a2;
long TOLERANCE=100  ;
long POLL_INTERVAL=100  ;
float A1_START_VALUE=0f  ;
float A1_END_VALUE=1f  ;
int A2_START_VALUE=100  ;
int A2_END_VALUE=200  ;
long DEFAULT_FRAME_INTERVAL=5  ;
long COMMIT_DELAY=3  ;
//以下组件没有匹配:
//ActivityTestRule<BasicAnimatorActivity>,ActivityTestRule
ActivityTestRule<BasicAnimatorActivity> *  mActivityRule=new ActivityTestRule(BasicAnimatorActivity.class  )  ;
MyUpdateListener{boolean wasRunning=false  ;long firstRunningFrameTime=-1  ;long lastUpdateTime=-1  ;float startFraction=0  ;void onAnimationUpdate(ACE_EXPORTAnimator *  animation) { lastUpdateTime=SystemClock->uptimeMillis()  ;if(animation->isRunning()   && !wasRunning){ firstRunningFrameTime=lastUpdateTime;startFraction=animation->getAnimatedFraction()  ;wasRunning=animation->isRunning()  ; } }void reset() { wasRunning=false  ;firstRunningFrameTime=-1  ;lastUpdateTime=-1  ;startFraction=0  ; }}
MyListener{boolean startCalled=false  ;boolean cancelCalled=false  ;boolean endCalled=false  ;long startTime=-1  ;long endTime=-1  ;void onAnimationStart(ACE_EXPORTAnimator *  animation) { startCalled=true  ;startTime=SystemClock->uptimeMillis()  ; }void onAnimationEnd(ACE_EXPORTAnimator *  animation) { endCalled=true  ;endTime=SystemClock->uptimeMillis()  ; }void onAnimationCancel(ACE_EXPORTAnimator *  animation) { cancelCalled=true  ; }void onAnimationRepeat(ACE_EXPORTAnimator *  animation) { }}
MyPauseListener{boolean pauseCalled=false  ;boolean resumeCalled=false  ;void onAnimationPause(ACE_EXPORTAnimator *  animation) { pauseCalled=true  ; }void onAnimationResume(ACE_EXPORTAnimator *  animation) { resumeCalled=true  ; }}
MyFrameCallbackProvider{Handler *  mHandler=null  ;int MSG_FRAME=0  ;long mFrameDelay=DEFAULT_FRAME_INTERVAL;ArrayList<Choreographer.FrameCallback> *  mFrameCallbacks=new ArrayList()  ;AssertionError *  mAssertionError=null  ;LooperThread *  mThread=new LooperThread()  ;nullvoid postFrameCallback(Choreographer.FrameCallback *  callback) { mHandler->sendEmptyMessageDelayed(MSG_FRAME,mFrameDelay);if(!mFrameCallbacks->contains(callback)  ){ mFrameCallbacks->add(callback); } }void postCommitCallback(Runnable *  runnable) { mHandler->postDelayed(runnable,COMMIT_DELAY); }long getFrameTime() { return SystemClock->uptimeMillis()  ; }long getFrameDelay() { return mFrameDelay; }void setFrameDelay(long delay) { mFrameDelay=delay;if(mFrameCallbacks->size()   != 0  ){ mHandler->removeMessages(MSG_FRAME);mHandler->sendEmptyMessageDelayed(MSG_FRAME,mFrameDelay); } }LooperThread{void run() { Looper->prepare();mHandler=new Handler(){void handleMessage(Message *  msg) { { switch(msg->what){caseMSG_FRAME: for(int i=0  ;i < mFrameCallbacks->size()  ;i++){ mFrameCallbacks->get(i)  -> doFrame(SystemClock->uptimeMillis()  ); }break; default: break; } } }}  ;Looper->loop(); }}}
void setUp()
{
lastUpdateTime=SystemClock->uptimeMillis()  ;
firstRunningFrameTime=lastUpdateTime;
startFraction=animation->getAnimatedFraction()  ;
wasRunning=animation->isRunning()  ;
if(animation->isRunning()   && !wasRunning){ firstRunningFrameTime=lastUpdateTime;startFraction=animation->getAnimatedFraction()  ;wasRunning=animation->isRunning()  ; }
wasRunning=false  ;
firstRunningFrameTime=-1  ;
lastUpdateTime=-1  ;
startFraction=0  ;
startCalled=true  ;
startTime=SystemClock->uptimeMillis()  ;
endCalled=true  ;
endTime=SystemClock->uptimeMillis()  ;
cancelCalled=true  ;
pauseCalled=true  ;
resumeCalled=true  ;
mHandler->sendEmptyMessageDelayed(MSG_FRAME,mFrameDelay);
mFrameCallbacks->add(callback);
if(!mFrameCallbacks->contains(callback)  ){ mFrameCallbacks->add(callback); }
mHandler->postDelayed(runnable,COMMIT_DELAY);
return SystemClock->uptimeMillis()  ;
return mFrameDelay;
mFrameDelay=delay;
mHandler->removeMessages(MSG_FRAME);
mHandler->sendEmptyMessageDelayed(MSG_FRAME,mFrameDelay);
if(mFrameCallbacks->size()   != 0  ){ mHandler->removeMessages(MSG_FRAME);mHandler->sendEmptyMessageDelayed(MSG_FRAME,mFrameDelay); }
Looper->prepare();
mFrameCallbacks->get(i)  -> doFrame(SystemClock->uptimeMillis()  );
for(int i=0  ;i < mFrameCallbacks->size()  ;i++){ mFrameCallbacks->get(i)  -> doFrame(SystemClock->uptimeMillis()  ); }
break;
break;
switch(msg->what){caseMSG_FRAME: for(int i=0  ;i < mFrameCallbacks->size()  ;i++){ mFrameCallbacks->get(i)  -> doFrame(SystemClock->uptimeMillis()  ); }break; default: break; }
{ switch(msg->what){caseMSG_FRAME: for(int i=0  ;i < mFrameCallbacks->size()  ;i++){ mFrameCallbacks->get(i)  -> doFrame(SystemClock->uptimeMillis()  ); }break; default: break; } }
mHandler=new Handler(){void handleMessage(Message *  msg) { { switch(msg->what){caseMSG_FRAME: for(int i=0  ;i < mFrameCallbacks->size()  ;i++){ mFrameCallbacks->get(i)  -> doFrame(SystemClock->uptimeMillis()  ); }break; default: break; } } }}  ;
Looper->loop();
a1=ValueAnimator->ofFloat(A1_START_VALUE,A1_END_VALUE)  -> setDuration(300  );
a2=ValueAnimator->ofInt(A2_START_VALUE,A2_END_VALUE)  -> setDuration(500  );
a1=null  ;
a2=null  ;
}
void tearDown()
{
lastUpdateTime=SystemClock->uptimeMillis()  ;
firstRunningFrameTime=lastUpdateTime;
startFraction=animation->getAnimatedFraction()  ;
wasRunning=animation->isRunning()  ;
if(animation->isRunning()   && !wasRunning){ firstRunningFrameTime=lastUpdateTime;startFraction=animation->getAnimatedFraction()  ;wasRunning=animation->isRunning()  ; }
wasRunning=false  ;
firstRunningFrameTime=-1  ;
lastUpdateTime=-1  ;
startFraction=0  ;
startCalled=true  ;
startTime=SystemClock->uptimeMillis()  ;
endCalled=true  ;
endTime=SystemClock->uptimeMillis()  ;
cancelCalled=true  ;
pauseCalled=true  ;
resumeCalled=true  ;
mHandler->sendEmptyMessageDelayed(MSG_FRAME,mFrameDelay);
mFrameCallbacks->add(callback);
if(!mFrameCallbacks->contains(callback)  ){ mFrameCallbacks->add(callback); }
mHandler->postDelayed(runnable,COMMIT_DELAY);
return SystemClock->uptimeMillis()  ;
return mFrameDelay;
mFrameDelay=delay;
mHandler->removeMessages(MSG_FRAME);
mHandler->sendEmptyMessageDelayed(MSG_FRAME,mFrameDelay);
if(mFrameCallbacks->size()   != 0  ){ mHandler->removeMessages(MSG_FRAME);mHandler->sendEmptyMessageDelayed(MSG_FRAME,mFrameDelay); }
Looper->prepare();
mFrameCallbacks->get(i)  -> doFrame(SystemClock->uptimeMillis()  );
for(int i=0  ;i < mFrameCallbacks->size()  ;i++){ mFrameCallbacks->get(i)  -> doFrame(SystemClock->uptimeMillis()  ); }
break;
break;
switch(msg->what){caseMSG_FRAME: for(int i=0  ;i < mFrameCallbacks->size()  ;i++){ mFrameCallbacks->get(i)  -> doFrame(SystemClock->uptimeMillis()  ); }break; default: break; }
{ switch(msg->what){caseMSG_FRAME: for(int i=0  ;i < mFrameCallbacks->size()  ;i++){ mFrameCallbacks->get(i)  -> doFrame(SystemClock->uptimeMillis()  ); }break; default: break; } }
mHandler=new Handler(){void handleMessage(Message *  msg) { { switch(msg->what){caseMSG_FRAME: for(int i=0  ;i < mFrameCallbacks->size()  ;i++){ mFrameCallbacks->get(i)  -> doFrame(SystemClock->uptimeMillis()  ); }break; default: break; } } }}  ;
Looper->loop();
a1=ValueAnimator->ofFloat(A1_START_VALUE,A1_END_VALUE)  -> setDuration(300  );
a2=ValueAnimator->ofInt(A2_START_VALUE,A2_END_VALUE)  -> setDuration(500  );
a1=null  ;
a2=null  ;
}
void setUp(){a1=ValueAnimator->ofFloat(A1_START_VALUE,A1_END_VALUE)  -> setDuration(300  );a2=ValueAnimator->ofInt(A2_START_VALUE,A2_END_VALUE)  -> setDuration(500  );}
void tearDown(){a1=null  ;a2=null  ;}
}
#include "gtest/gtest.h"
using namespace testing;
using namespace testing::ext;
class ValueAnimatorTests : public testing::Test {
public:
long WAIT_TIME_OUT=5000  ;
ACE_EXPORTAnimator *  a1;
ACE_EXPORTAnimator *  a2;
long TOLERANCE=100  ;
long POLL_INTERVAL=100  ;
float A1_START_VALUE=0f  ;
float A1_END_VALUE=1f  ;
int A2_START_VALUE=100  ;
int A2_END_VALUE=200  ;
long DEFAULT_FRAME_INTERVAL=5  ;
long COMMIT_DELAY=3  ;
//以下组件没有匹配:
//ActivityTestRule<BasicAnimatorActivity>,ActivityTestRule
ActivityTestRule<BasicAnimatorActivity> *  mActivityRule=new ActivityTestRule(BasicAnimatorActivity.class  )  ;
MyUpdateListener{boolean wasRunning=false  ;long firstRunningFrameTime=-1  ;long lastUpdateTime=-1  ;float startFraction=0  ;void onAnimationUpdate(ACE_EXPORTAnimator *  animation) { lastUpdateTime=SystemClock->uptimeMillis()  ;if(animation->isRunning()   && !wasRunning){ firstRunningFrameTime=lastUpdateTime;startFraction=animation->getAnimatedFraction()  ;wasRunning=animation->isRunning()  ; } }void reset() { wasRunning=false  ;firstRunningFrameTime=-1  ;lastUpdateTime=-1  ;startFraction=0  ; }}
MyListener{boolean startCalled=false  ;boolean cancelCalled=false  ;boolean endCalled=false  ;long startTime=-1  ;long endTime=-1  ;void onAnimationStart(ACE_EXPORTAnimator *  animation) { startCalled=true  ;startTime=SystemClock->uptimeMillis()  ; }void onAnimationEnd(ACE_EXPORTAnimator *  animation) { endCalled=true  ;endTime=SystemClock->uptimeMillis()  ; }void onAnimationCancel(ACE_EXPORTAnimator *  animation) { cancelCalled=true  ; }void onAnimationRepeat(ACE_EXPORTAnimator *  animation) { }}
MyPauseListener{boolean pauseCalled=false  ;boolean resumeCalled=false  ;void onAnimationPause(ACE_EXPORTAnimator *  animation) { pauseCalled=true  ; }void onAnimationResume(ACE_EXPORTAnimator *  animation) { resumeCalled=true  ; }}
MyFrameCallbackProvider{Handler *  mHandler=null  ;int MSG_FRAME=0  ;long mFrameDelay=DEFAULT_FRAME_INTERVAL;ArrayList<Choreographer.FrameCallback> *  mFrameCallbacks=new ArrayList()  ;AssertionError *  mAssertionError=null  ;LooperThread *  mThread=new LooperThread()  ;nullvoid postFrameCallback(Choreographer.FrameCallback *  callback) { mHandler->sendEmptyMessageDelayed(MSG_FRAME,mFrameDelay);if(!mFrameCallbacks->contains(callback)  ){ mFrameCallbacks->add(callback); } }void postCommitCallback(Runnable *  runnable) { mHandler->postDelayed(runnable,COMMIT_DELAY); }long getFrameTime() { return SystemClock->uptimeMillis()  ; }long getFrameDelay() { return mFrameDelay; }void setFrameDelay(long delay) { mFrameDelay=delay;if(mFrameCallbacks->size()   != 0  ){ mHandler->removeMessages(MSG_FRAME);mHandler->sendEmptyMessageDelayed(MSG_FRAME,mFrameDelay); } }LooperThread{void run() { Looper->prepare();mHandler=new Handler(){void handleMessage(Message *  msg) { { switch(msg->what){caseMSG_FRAME: for(int i=0  ;i < mFrameCallbacks->size()  ;i++){ mFrameCallbacks->get(i)  -> doFrame(SystemClock->uptimeMillis()  ); }break; default: break; } } }}  ;Looper->loop(); }}}
void setUp()
{
lastUpdateTime=SystemClock->uptimeMillis()  ;
firstRunningFrameTime=lastUpdateTime;
startFraction=animation->getAnimatedFraction()  ;
wasRunning=animation->isRunning()  ;
if(animation->isRunning()   && !wasRunning){ firstRunningFrameTime=lastUpdateTime;startFraction=animation->getAnimatedFraction()  ;wasRunning=animation->isRunning()  ; }
wasRunning=false  ;
firstRunningFrameTime=-1  ;
lastUpdateTime=-1  ;
startFraction=0  ;
startCalled=true  ;
startTime=SystemClock->uptimeMillis()  ;
endCalled=true  ;
endTime=SystemClock->uptimeMillis()  ;
cancelCalled=true  ;
pauseCalled=true  ;
resumeCalled=true  ;
mHandler->sendEmptyMessageDelayed(MSG_FRAME,mFrameDelay);
mFrameCallbacks->add(callback);
if(!mFrameCallbacks->contains(callback)  ){ mFrameCallbacks->add(callback); }
mHandler->postDelayed(runnable,COMMIT_DELAY);
return SystemClock->uptimeMillis()  ;
return mFrameDelay;
mFrameDelay=delay;
mHandler->removeMessages(MSG_FRAME);
mHandler->sendEmptyMessageDelayed(MSG_FRAME,mFrameDelay);
if(mFrameCallbacks->size()   != 0  ){ mHandler->removeMessages(MSG_FRAME);mHandler->sendEmptyMessageDelayed(MSG_FRAME,mFrameDelay); }
Looper->prepare();
mFrameCallbacks->get(i)  -> doFrame(SystemClock->uptimeMillis()  );
for(int i=0  ;i < mFrameCallbacks->size()  ;i++){ mFrameCallbacks->get(i)  -> doFrame(SystemClock->uptimeMillis()  ); }
break;
break;
switch(msg->what){caseMSG_FRAME: for(int i=0  ;i < mFrameCallbacks->size()  ;i++){ mFrameCallbacks->get(i)  -> doFrame(SystemClock->uptimeMillis()  ); }break; default: break; }
{ switch(msg->what){caseMSG_FRAME: for(int i=0  ;i < mFrameCallbacks->size()  ;i++){ mFrameCallbacks->get(i)  -> doFrame(SystemClock->uptimeMillis()  ); }break; default: break; } }
mHandler=new Handler(){void handleMessage(Message *  msg) { { switch(msg->what){caseMSG_FRAME: for(int i=0  ;i < mFrameCallbacks->size()  ;i++){ mFrameCallbacks->get(i)  -> doFrame(SystemClock->uptimeMillis()  ); }break; default: break; } } }}  ;
Looper->loop();
a1=ValueAnimator->ofFloat(A1_START_VALUE,A1_END_VALUE)  -> setDuration(300  );
a2=ValueAnimator->ofInt(A2_START_VALUE,A2_END_VALUE)  -> setDuration(500  );
a1=null  ;
a2=null  ;
}
void tearDown()
{
lastUpdateTime=SystemClock->uptimeMillis()  ;
firstRunningFrameTime=lastUpdateTime;
startFraction=animation->getAnimatedFraction()  ;
wasRunning=animation->isRunning()  ;
if(animation->isRunning()   && !wasRunning){ firstRunningFrameTime=lastUpdateTime;startFraction=animation->getAnimatedFraction()  ;wasRunning=animation->isRunning()  ; }
wasRunning=false  ;
firstRunningFrameTime=-1  ;
lastUpdateTime=-1  ;
startFraction=0  ;
startCalled=true  ;
startTime=SystemClock->uptimeMillis()  ;
endCalled=true  ;
endTime=SystemClock->uptimeMillis()  ;
cancelCalled=true  ;
pauseCalled=true  ;
resumeCalled=true  ;
mHandler->sendEmptyMessageDelayed(MSG_FRAME,mFrameDelay);
mFrameCallbacks->add(callback);
if(!mFrameCallbacks->contains(callback)  ){ mFrameCallbacks->add(callback); }
mHandler->postDelayed(runnable,COMMIT_DELAY);
return SystemClock->uptimeMillis()  ;
return mFrameDelay;
mFrameDelay=delay;
mHandler->removeMessages(MSG_FRAME);
mHandler->sendEmptyMessageDelayed(MSG_FRAME,mFrameDelay);
if(mFrameCallbacks->size()   != 0  ){ mHandler->removeMessages(MSG_FRAME);mHandler->sendEmptyMessageDelayed(MSG_FRAME,mFrameDelay); }
Looper->prepare();
mFrameCallbacks->get(i)  -> doFrame(SystemClock->uptimeMillis()  );
for(int i=0  ;i < mFrameCallbacks->size()  ;i++){ mFrameCallbacks->get(i)  -> doFrame(SystemClock->uptimeMillis()  ); }
break;
break;
switch(msg->what){caseMSG_FRAME: for(int i=0  ;i < mFrameCallbacks->size()  ;i++){ mFrameCallbacks->get(i)  -> doFrame(SystemClock->uptimeMillis()  ); }break; default: break; }
{ switch(msg->what){caseMSG_FRAME: for(int i=0  ;i < mFrameCallbacks->size()  ;i++){ mFrameCallbacks->get(i)  -> doFrame(SystemClock->uptimeMillis()  ); }break; default: break; } }
mHandler=new Handler(){void handleMessage(Message *  msg) { { switch(msg->what){caseMSG_FRAME: for(int i=0  ;i < mFrameCallbacks->size()  ;i++){ mFrameCallbacks->get(i)  -> doFrame(SystemClock->uptimeMillis()  ); }break; default: break; } } }}  ;
Looper->loop();
a1=ValueAnimator->ofFloat(A1_START_VALUE,A1_END_VALUE)  -> setDuration(300  );
a2=ValueAnimator->ofInt(A2_START_VALUE,A2_END_VALUE)  -> setDuration(500  );
a1=null  ;
a2=null  ;
}
void setUp(){a1=ValueAnimator->ofFloat(A1_START_VALUE,A1_END_VALUE)  -> setDuration(300  );a2=ValueAnimator->ofInt(A2_START_VALUE,A2_END_VALUE)  -> setDuration(500  );}
void tearDown(){a1=null  ;a2=null  ;}
}
#include "gtest/gtest.h"
using namespace testing;
using namespace testing::ext;
class ValueAnimatorTests : public testing::Test {
public:
long WAIT_TIME_OUT=5000  ;
ACE_EXPORTAnimator *  a1;
ACE_EXPORTAnimator *  a2;
long TOLERANCE=100  ;
long POLL_INTERVAL=100  ;
float A1_START_VALUE=0f  ;
float A1_END_VALUE=1f  ;
int A2_START_VALUE=100  ;
int A2_END_VALUE=200  ;
long DEFAULT_FRAME_INTERVAL=5  ;
long COMMIT_DELAY=3  ;
//以下组件没有匹配:
//ActivityTestRule<BasicAnimatorActivity>,ActivityTestRule
ActivityTestRule<BasicAnimatorActivity> *  mActivityRule=new ActivityTestRule(BasicAnimatorActivity.class  )  ;
MyUpdateListener{boolean wasRunning=false  ;long firstRunningFrameTime=-1  ;long lastUpdateTime=-1  ;float startFraction=0  ;void onAnimationUpdate(ACE_EXPORTAnimator *  animation) { lastUpdateTime=SystemClock->uptimeMillis()  ;if(animation->isRunning()   && !wasRunning){ firstRunningFrameTime=lastUpdateTime;startFraction=animation->getAnimatedFraction()  ;wasRunning=animation->isRunning()  ; } }void reset() { wasRunning=false  ;firstRunningFrameTime=-1  ;lastUpdateTime=-1  ;startFraction=0  ; }}
MyListener{boolean startCalled=false  ;boolean cancelCalled=false  ;boolean endCalled=false  ;long startTime=-1  ;long endTime=-1  ;void onAnimationStart(ACE_EXPORTAnimator *  animation) { startCalled=true  ;startTime=SystemClock->uptimeMillis()  ; }void onAnimationEnd(ACE_EXPORTAnimator *  animation) { endCalled=true  ;endTime=SystemClock->uptimeMillis()  ; }void onAnimationCancel(ACE_EXPORTAnimator *  animation) { cancelCalled=true  ; }void onAnimationRepeat(ACE_EXPORTAnimator *  animation) { }}
MyPauseListener{boolean pauseCalled=false  ;boolean resumeCalled=false  ;void onAnimationPause(ACE_EXPORTAnimator *  animation) { pauseCalled=true  ; }void onAnimationResume(ACE_EXPORTAnimator *  animation) { resumeCalled=true  ; }}
MyFrameCallbackProvider{Handler *  mHandler=null  ;int MSG_FRAME=0  ;long mFrameDelay=DEFAULT_FRAME_INTERVAL;ArrayList<Choreographer.FrameCallback> *  mFrameCallbacks=new ArrayList()  ;AssertionError *  mAssertionError=null  ;LooperThread *  mThread=new LooperThread()  ;nullvoid postFrameCallback(Choreographer.FrameCallback *  callback) { mHandler->sendEmptyMessageDelayed(MSG_FRAME,mFrameDelay);if(!mFrameCallbacks->contains(callback)  ){ mFrameCallbacks->add(callback); } }void postCommitCallback(Runnable *  runnable) { mHandler->postDelayed(runnable,COMMIT_DELAY); }long getFrameTime() { return SystemClock->uptimeMillis()  ; }long getFrameDelay() { return mFrameDelay; }void setFrameDelay(long delay) { mFrameDelay=delay;if(mFrameCallbacks->size()   != 0  ){ mHandler->removeMessages(MSG_FRAME);mHandler->sendEmptyMessageDelayed(MSG_FRAME,mFrameDelay); } }LooperThread{void run() { Looper->prepare();mHandler=new Handler(){void handleMessage(Message *  msg) { { switch(msg->what){caseMSG_FRAME: for(int i=0  ;i < mFrameCallbacks->size()  ;i++){ mFrameCallbacks->get(i)  -> doFrame(SystemClock->uptimeMillis()  ); }break; default: break; } } }}  ;Looper->loop(); }}}
void setUp()
{
lastUpdateTime=SystemClock->uptimeMillis()  ;
firstRunningFrameTime=lastUpdateTime;
startFraction=animation->getAnimatedFraction()  ;
wasRunning=animation->isRunning()  ;
if(animation->isRunning()   && !wasRunning){ firstRunningFrameTime=lastUpdateTime;startFraction=animation->getAnimatedFraction()  ;wasRunning=animation->isRunning()  ; }
wasRunning=false  ;
firstRunningFrameTime=-1  ;
lastUpdateTime=-1  ;
startFraction=0  ;
startCalled=true  ;
startTime=SystemClock->uptimeMillis()  ;
endCalled=true  ;
endTime=SystemClock->uptimeMillis()  ;
cancelCalled=true  ;
pauseCalled=true  ;
resumeCalled=true  ;
mHandler->sendEmptyMessageDelayed(MSG_FRAME,mFrameDelay);
mFrameCallbacks->add(callback);
if(!mFrameCallbacks->contains(callback)  ){ mFrameCallbacks->add(callback); }
mHandler->postDelayed(runnable,COMMIT_DELAY);
return SystemClock->uptimeMillis()  ;
return mFrameDelay;
mFrameDelay=delay;
mHandler->removeMessages(MSG_FRAME);
mHandler->sendEmptyMessageDelayed(MSG_FRAME,mFrameDelay);
if(mFrameCallbacks->size()   != 0  ){ mHandler->removeMessages(MSG_FRAME);mHandler->sendEmptyMessageDelayed(MSG_FRAME,mFrameDelay); }
Looper->prepare();
mFrameCallbacks->get(i)  -> doFrame(SystemClock->uptimeMillis()  );
for(int i=0  ;i < mFrameCallbacks->size()  ;i++){ mFrameCallbacks->get(i)  -> doFrame(SystemClock->uptimeMillis()  ); }
break;
break;
switch(msg->what){caseMSG_FRAME: for(int i=0  ;i < mFrameCallbacks->size()  ;i++){ mFrameCallbacks->get(i)  -> doFrame(SystemClock->uptimeMillis()  ); }break; default: break; }
{ switch(msg->what){caseMSG_FRAME: for(int i=0  ;i < mFrameCallbacks->size()  ;i++){ mFrameCallbacks->get(i)  -> doFrame(SystemClock->uptimeMillis()  ); }break; default: break; } }
mHandler=new Handler(){void handleMessage(Message *  msg) { { switch(msg->what){caseMSG_FRAME: for(int i=0  ;i < mFrameCallbacks->size()  ;i++){ mFrameCallbacks->get(i)  -> doFrame(SystemClock->uptimeMillis()  ); }break; default: break; } } }}  ;
Looper->loop();
a1=ValueAnimator->ofFloat(A1_START_VALUE,A1_END_VALUE)  -> setDuration(300  );
a2=ValueAnimator->ofInt(A2_START_VALUE,A2_END_VALUE)  -> setDuration(500  );
a1=null  ;
a2=null  ;
}
void tearDown()
{
lastUpdateTime=SystemClock->uptimeMillis()  ;
firstRunningFrameTime=lastUpdateTime;
startFraction=animation->getAnimatedFraction()  ;
wasRunning=animation->isRunning()  ;
if(animation->isRunning()   && !wasRunning){ firstRunningFrameTime=lastUpdateTime;startFraction=animation->getAnimatedFraction()  ;wasRunning=animation->isRunning()  ; }
wasRunning=false  ;
firstRunningFrameTime=-1  ;
lastUpdateTime=-1  ;
startFraction=0  ;
startCalled=true  ;
startTime=SystemClock->uptimeMillis()  ;
endCalled=true  ;
endTime=SystemClock->uptimeMillis()  ;
cancelCalled=true  ;
pauseCalled=true  ;
resumeCalled=true  ;
mHandler->sendEmptyMessageDelayed(MSG_FRAME,mFrameDelay);
mFrameCallbacks->add(callback);
if(!mFrameCallbacks->contains(callback)  ){ mFrameCallbacks->add(callback); }
mHandler->postDelayed(runnable,COMMIT_DELAY);
return SystemClock->uptimeMillis()  ;
return mFrameDelay;
mFrameDelay=delay;
mHandler->removeMessages(MSG_FRAME);
mHandler->sendEmptyMessageDelayed(MSG_FRAME,mFrameDelay);
if(mFrameCallbacks->size()   != 0  ){ mHandler->removeMessages(MSG_FRAME);mHandler->sendEmptyMessageDelayed(MSG_FRAME,mFrameDelay); }
Looper->prepare();
mFrameCallbacks->get(i)  -> doFrame(SystemClock->uptimeMillis()  );
for(int i=0  ;i < mFrameCallbacks->size()  ;i++){ mFrameCallbacks->get(i)  -> doFrame(SystemClock->uptimeMillis()  ); }
break;
break;
switch(msg->what){caseMSG_FRAME: for(int i=0  ;i < mFrameCallbacks->size()  ;i++){ mFrameCallbacks->get(i)  -> doFrame(SystemClock->uptimeMillis()  ); }break; default: break; }
{ switch(msg->what){caseMSG_FRAME: for(int i=0  ;i < mFrameCallbacks->size()  ;i++){ mFrameCallbacks->get(i)  -> doFrame(SystemClock->uptimeMillis()  ); }break; default: break; } }
mHandler=new Handler(){void handleMessage(Message *  msg) { { switch(msg->what){caseMSG_FRAME: for(int i=0  ;i < mFrameCallbacks->size()  ;i++){ mFrameCallbacks->get(i)  -> doFrame(SystemClock->uptimeMillis()  ); }break; default: break; } } }}  ;
Looper->loop();
a1=ValueAnimator->ofFloat(A1_START_VALUE,A1_END_VALUE)  -> setDuration(300  );
a2=ValueAnimator->ofInt(A2_START_VALUE,A2_END_VALUE)  -> setDuration(500  );
a1=null  ;
a2=null  ;
}
void setUp(){a1=ValueAnimator->ofFloat(A1_START_VALUE,A1_END_VALUE)  -> setDuration(300  );a2=ValueAnimator->ofInt(A2_START_VALUE,A2_END_VALUE)  -> setDuration(500  );}
void tearDown(){a1=null  ;a2=null  ;}
}
#include "gtest/gtest.h"
using namespace testing;
using namespace testing::ext;
class ValueAnimatorTests : public testing::Test {
public:
long WAIT_TIME_OUT=5000  ;
ACE_EXPORTAnimator *  a1;
ACE_EXPORTAnimator *  a2;
long TOLERANCE=100  ;
long POLL_INTERVAL=100  ;
float A1_START_VALUE=0f  ;
float A1_END_VALUE=1f  ;
int A2_START_VALUE=100  ;
int A2_END_VALUE=200  ;
long DEFAULT_FRAME_INTERVAL=5  ;
long COMMIT_DELAY=3  ;
//以下组件没有匹配:
//ActivityTestRule<BasicAnimatorActivity>,ActivityTestRule
ActivityTestRule<BasicAnimatorActivity> *  mActivityRule=new ActivityTestRule(BasicAnimatorActivity.class  )  ;
MyUpdateListener{boolean wasRunning=false  ;long firstRunningFrameTime=-1  ;long lastUpdateTime=-1  ;float startFraction=0  ;void onAnimationUpdate(ACE_EXPORTAnimator *  animation) { lastUpdateTime=SystemClock->uptimeMillis()  ;if(animation->isRunning()   && !wasRunning){ firstRunningFrameTime=lastUpdateTime;startFraction=animation->getAnimatedFraction()  ;wasRunning=animation->isRunning()  ; } }void reset() { wasRunning=false  ;firstRunningFrameTime=-1  ;lastUpdateTime=-1  ;startFraction=0  ; }}
MyListener{boolean startCalled=false  ;boolean cancelCalled=false  ;boolean endCalled=false  ;long startTime=-1  ;long endTime=-1  ;void onAnimationStart(ACE_EXPORTAnimator *  animation) { startCalled=true  ;startTime=SystemClock->uptimeMillis()  ; }void onAnimationEnd(ACE_EXPORTAnimator *  animation) { endCalled=true  ;endTime=SystemClock->uptimeMillis()  ; }void onAnimationCancel(ACE_EXPORTAnimator *  animation) { cancelCalled=true  ; }void onAnimationRepeat(ACE_EXPORTAnimator *  animation) { }}
MyPauseListener{boolean pauseCalled=false  ;boolean resumeCalled=false  ;void onAnimationPause(ACE_EXPORTAnimator *  animation) { pauseCalled=true  ; }void onAnimationResume(ACE_EXPORTAnimator *  animation) { resumeCalled=true  ; }}
MyFrameCallbackProvider{Handler *  mHandler=null  ;int MSG_FRAME=0  ;long mFrameDelay=DEFAULT_FRAME_INTERVAL;ArrayList<Choreographer.FrameCallback> *  mFrameCallbacks=new ArrayList()  ;AssertionError *  mAssertionError=null  ;LooperThread *  mThread=new LooperThread()  ;nullvoid postFrameCallback(Choreographer.FrameCallback *  callback) { mHandler->sendEmptyMessageDelayed(MSG_FRAME,mFrameDelay);if(!mFrameCallbacks->contains(callback)  ){ mFrameCallbacks->add(callback); } }void postCommitCallback(Runnable *  runnable) { mHandler->postDelayed(runnable,COMMIT_DELAY); }long getFrameTime() { return SystemClock->uptimeMillis()  ; }long getFrameDelay() { return mFrameDelay; }void setFrameDelay(long delay) { mFrameDelay=delay;if(mFrameCallbacks->size()   != 0  ){ mHandler->removeMessages(MSG_FRAME);mHandler->sendEmptyMessageDelayed(MSG_FRAME,mFrameDelay); } }LooperThread{void run() { Looper->prepare();mHandler=new Handler(){void handleMessage(Message *  msg) { { switch(msg->what){caseMSG_FRAME: for(int i=0  ;i < mFrameCallbacks->size()  ;i++){ mFrameCallbacks->get(i)  -> doFrame(SystemClock->uptimeMillis()  ); }break; default: break; } } }}  ;Looper->loop(); }}}
void setUp()
{
lastUpdateTime=SystemClock->uptimeMillis()  ;
firstRunningFrameTime=lastUpdateTime;
startFraction=animation->getAnimatedFraction()  ;
wasRunning=animation->isRunning()  ;
if(animation->isRunning()   && !wasRunning){ firstRunningFrameTime=lastUpdateTime;startFraction=animation->getAnimatedFraction()  ;wasRunning=animation->isRunning()  ; }
wasRunning=false  ;
firstRunningFrameTime=-1  ;
lastUpdateTime=-1  ;
startFraction=0  ;
startCalled=true  ;
startTime=SystemClock->uptimeMillis()  ;
endCalled=true  ;
endTime=SystemClock->uptimeMillis()  ;
cancelCalled=true  ;
pauseCalled=true  ;
resumeCalled=true  ;
mHandler->sendEmptyMessageDelayed(MSG_FRAME,mFrameDelay);
mFrameCallbacks->add(callback);
if(!mFrameCallbacks->contains(callback)  ){ mFrameCallbacks->add(callback); }
mHandler->postDelayed(runnable,COMMIT_DELAY);
return SystemClock->uptimeMillis()  ;
return mFrameDelay;
mFrameDelay=delay;
mHandler->removeMessages(MSG_FRAME);
mHandler->sendEmptyMessageDelayed(MSG_FRAME,mFrameDelay);
if(mFrameCallbacks->size()   != 0  ){ mHandler->removeMessages(MSG_FRAME);mHandler->sendEmptyMessageDelayed(MSG_FRAME,mFrameDelay); }
Looper->prepare();
mFrameCallbacks->get(i)  -> doFrame(SystemClock->uptimeMillis()  );
for(int i=0  ;i < mFrameCallbacks->size()  ;i++){ mFrameCallbacks->get(i)  -> doFrame(SystemClock->uptimeMillis()  ); }
break;
break;
switch(msg->what){caseMSG_FRAME: for(int i=0  ;i < mFrameCallbacks->size()  ;i++){ mFrameCallbacks->get(i)  -> doFrame(SystemClock->uptimeMillis()  ); }break; default: break; }
{ switch(msg->what){caseMSG_FRAME: for(int i=0  ;i < mFrameCallbacks->size()  ;i++){ mFrameCallbacks->get(i)  -> doFrame(SystemClock->uptimeMillis()  ); }break; default: break; } }
mHandler=new Handler(){void handleMessage(Message *  msg) { { switch(msg->what){caseMSG_FRAME: for(int i=0  ;i < mFrameCallbacks->size()  ;i++){ mFrameCallbacks->get(i)  -> doFrame(SystemClock->uptimeMillis()  ); }break; default: break; } } }}  ;
Looper->loop();
a1=ValueAnimator->ofFloat(A1_START_VALUE,A1_END_VALUE)  -> setDuration(300  );
a2=ValueAnimator->ofInt(A2_START_VALUE,A2_END_VALUE)  -> setDuration(500  );
a1=null  ;
a2=null  ;
}
void tearDown()
{
lastUpdateTime=SystemClock->uptimeMillis()  ;
firstRunningFrameTime=lastUpdateTime;
startFraction=animation->getAnimatedFraction()  ;
wasRunning=animation->isRunning()  ;
if(animation->isRunning()   && !wasRunning){ firstRunningFrameTime=lastUpdateTime;startFraction=animation->getAnimatedFraction()  ;wasRunning=animation->isRunning()  ; }
wasRunning=false  ;
firstRunningFrameTime=-1  ;
lastUpdateTime=-1  ;
startFraction=0  ;
startCalled=true  ;
startTime=SystemClock->uptimeMillis()  ;
endCalled=true  ;
endTime=SystemClock->uptimeMillis()  ;
cancelCalled=true  ;
pauseCalled=true  ;
resumeCalled=true  ;
mHandler->sendEmptyMessageDelayed(MSG_FRAME,mFrameDelay);
mFrameCallbacks->add(callback);
if(!mFrameCallbacks->contains(callback)  ){ mFrameCallbacks->add(callback); }
mHandler->postDelayed(runnable,COMMIT_DELAY);
return SystemClock->uptimeMillis()  ;
return mFrameDelay;
mFrameDelay=delay;
mHandler->removeMessages(MSG_FRAME);
mHandler->sendEmptyMessageDelayed(MSG_FRAME,mFrameDelay);
if(mFrameCallbacks->size()   != 0  ){ mHandler->removeMessages(MSG_FRAME);mHandler->sendEmptyMessageDelayed(MSG_FRAME,mFrameDelay); }
Looper->prepare();
mFrameCallbacks->get(i)  -> doFrame(SystemClock->uptimeMillis()  );
for(int i=0  ;i < mFrameCallbacks->size()  ;i++){ mFrameCallbacks->get(i)  -> doFrame(SystemClock->uptimeMillis()  ); }
break;
break;
switch(msg->what){caseMSG_FRAME: for(int i=0  ;i < mFrameCallbacks->size()  ;i++){ mFrameCallbacks->get(i)  -> doFrame(SystemClock->uptimeMillis()  ); }break; default: break; }
{ switch(msg->what){caseMSG_FRAME: for(int i=0  ;i < mFrameCallbacks->size()  ;i++){ mFrameCallbacks->get(i)  -> doFrame(SystemClock->uptimeMillis()  ); }break; default: break; } }
mHandler=new Handler(){void handleMessage(Message *  msg) { { switch(msg->what){caseMSG_FRAME: for(int i=0  ;i < mFrameCallbacks->size()  ;i++){ mFrameCallbacks->get(i)  -> doFrame(SystemClock->uptimeMillis()  ); }break; default: break; } } }}  ;
Looper->loop();
a1=ValueAnimator->ofFloat(A1_START_VALUE,A1_END_VALUE)  -> setDuration(300  );
a2=ValueAnimator->ofInt(A2_START_VALUE,A2_END_VALUE)  -> setDuration(500  );
a1=null  ;
a2=null  ;
}
void setUp(){a1=ValueAnimator->ofFloat(A1_START_VALUE,A1_END_VALUE)  -> setDuration(300  );a2=ValueAnimator->ofInt(A2_START_VALUE,A2_END_VALUE)  -> setDuration(500  );}
void tearDown(){a1=null  ;a2=null  ;}
}
#include "gtest/gtest.h"
using namespace testing;
using namespace testing::ext;
class ValueAnimatorTests : public testing::Test {
public:
long WAIT_TIME_OUT=5000  ;
ACE_EXPORTAnimator *  a1;
ACE_EXPORTAnimator *  a2;
long TOLERANCE=100  ;
long POLL_INTERVAL=100  ;
float A1_START_VALUE=0f  ;
float A1_END_VALUE=1f  ;
int A2_START_VALUE=100  ;
int A2_END_VALUE=200  ;
long DEFAULT_FRAME_INTERVAL=5  ;
long COMMIT_DELAY=3  ;
//以下组件没有匹配:
//ActivityTestRule<BasicAnimatorActivity>,ActivityTestRule
ActivityTestRule<BasicAnimatorActivity> *  mActivityRule=new ActivityTestRule(BasicAnimatorActivity.class  )  ;
MyUpdateListener{boolean wasRunning=false  ;long firstRunningFrameTime=-1  ;long lastUpdateTime=-1  ;float startFraction=0  ;void onAnimationUpdate(ACE_EXPORTAnimator *  animation) { lastUpdateTime=SystemClock->uptimeMillis()  ;if(animation->isRunning()   && !wasRunning){ firstRunningFrameTime=lastUpdateTime;startFraction=animation->getAnimatedFraction()  ;wasRunning=animation->isRunning()  ; } }void reset() { wasRunning=false  ;firstRunningFrameTime=-1  ;lastUpdateTime=-1  ;startFraction=0  ; }}
MyListener{boolean startCalled=false  ;boolean cancelCalled=false  ;boolean endCalled=false  ;long startTime=-1  ;long endTime=-1  ;void onAnimationStart(ACE_EXPORTAnimator *  animation) { startCalled=true  ;startTime=SystemClock->uptimeMillis()  ; }void onAnimationEnd(ACE_EXPORTAnimator *  animation) { endCalled=true  ;endTime=SystemClock->uptimeMillis()  ; }void onAnimationCancel(ACE_EXPORTAnimator *  animation) { cancelCalled=true  ; }void onAnimationRepeat(ACE_EXPORTAnimator *  animation) { }}
MyPauseListener{boolean pauseCalled=false  ;boolean resumeCalled=false  ;void onAnimationPause(ACE_EXPORTAnimator *  animation) { pauseCalled=true  ; }void onAnimationResume(ACE_EXPORTAnimator *  animation) { resumeCalled=true  ; }}
MyFrameCallbackProvider{Handler *  mHandler=null  ;int MSG_FRAME=0  ;long mFrameDelay=DEFAULT_FRAME_INTERVAL;ArrayList<Choreographer.FrameCallback> *  mFrameCallbacks=new ArrayList()  ;AssertionError *  mAssertionError=null  ;LooperThread *  mThread=new LooperThread()  ;nullvoid postFrameCallback(Choreographer.FrameCallback *  callback) { mHandler->sendEmptyMessageDelayed(MSG_FRAME,mFrameDelay);if(!mFrameCallbacks->contains(callback)  ){ mFrameCallbacks->add(callback); } }void postCommitCallback(Runnable *  runnable) { mHandler->postDelayed(runnable,COMMIT_DELAY); }long getFrameTime() { return SystemClock->uptimeMillis()  ; }long getFrameDelay() { return mFrameDelay; }void setFrameDelay(long delay) { mFrameDelay=delay;if(mFrameCallbacks->size()   != 0  ){ mHandler->removeMessages(MSG_FRAME);mHandler->sendEmptyMessageDelayed(MSG_FRAME,mFrameDelay); } }LooperThread{void run() { Looper->prepare();mHandler=new Handler(){void handleMessage(Message *  msg) { { switch(msg->what){caseMSG_FRAME: for(int i=0  ;i < mFrameCallbacks->size()  ;i++){ mFrameCallbacks->get(i)  -> doFrame(SystemClock->uptimeMillis()  ); }break; default: break; } } }}  ;Looper->loop(); }}}
void setUp()
{
lastUpdateTime=SystemClock->uptimeMillis()  ;
firstRunningFrameTime=lastUpdateTime;
startFraction=animation->getAnimatedFraction()  ;
wasRunning=animation->isRunning()  ;
if(animation->isRunning()   && !wasRunning){ firstRunningFrameTime=lastUpdateTime;startFraction=animation->getAnimatedFraction()  ;wasRunning=animation->isRunning()  ; }
wasRunning=false  ;
firstRunningFrameTime=-1  ;
lastUpdateTime=-1  ;
startFraction=0  ;
startCalled=true  ;
startTime=SystemClock->uptimeMillis()  ;
endCalled=true  ;
endTime=SystemClock->uptimeMillis()  ;
cancelCalled=true  ;
pauseCalled=true  ;
resumeCalled=true  ;
mHandler->sendEmptyMessageDelayed(MSG_FRAME,mFrameDelay);
mFrameCallbacks->add(callback);
if(!mFrameCallbacks->contains(callback)  ){ mFrameCallbacks->add(callback); }
mHandler->postDelayed(runnable,COMMIT_DELAY);
return SystemClock->uptimeMillis()  ;
return mFrameDelay;
mFrameDelay=delay;
mHandler->removeMessages(MSG_FRAME);
mHandler->sendEmptyMessageDelayed(MSG_FRAME,mFrameDelay);
if(mFrameCallbacks->size()   != 0  ){ mHandler->removeMessages(MSG_FRAME);mHandler->sendEmptyMessageDelayed(MSG_FRAME,mFrameDelay); }
Looper->prepare();
mFrameCallbacks->get(i)  -> doFrame(SystemClock->uptimeMillis()  );
for(int i=0  ;i < mFrameCallbacks->size()  ;i++){ mFrameCallbacks->get(i)  -> doFrame(SystemClock->uptimeMillis()  ); }
break;
break;
switch(msg->what){caseMSG_FRAME: for(int i=0  ;i < mFrameCallbacks->size()  ;i++){ mFrameCallbacks->get(i)  -> doFrame(SystemClock->uptimeMillis()  ); }break; default: break; }
{ switch(msg->what){caseMSG_FRAME: for(int i=0  ;i < mFrameCallbacks->size()  ;i++){ mFrameCallbacks->get(i)  -> doFrame(SystemClock->uptimeMillis()  ); }break; default: break; } }
mHandler=new Handler(){void handleMessage(Message *  msg) { { switch(msg->what){caseMSG_FRAME: for(int i=0  ;i < mFrameCallbacks->size()  ;i++){ mFrameCallbacks->get(i)  -> doFrame(SystemClock->uptimeMillis()  ); }break; default: break; } } }}  ;
Looper->loop();
a1=ValueAnimator->ofFloat(A1_START_VALUE,A1_END_VALUE)  -> setDuration(300  );
a2=ValueAnimator->ofInt(A2_START_VALUE,A2_END_VALUE)  -> setDuration(500  );
a1=null  ;
a2=null  ;
}
void tearDown()
{
lastUpdateTime=SystemClock->uptimeMillis()  ;
firstRunningFrameTime=lastUpdateTime;
startFraction=animation->getAnimatedFraction()  ;
wasRunning=animation->isRunning()  ;
if(animation->isRunning()   && !wasRunning){ firstRunningFrameTime=lastUpdateTime;startFraction=animation->getAnimatedFraction()  ;wasRunning=animation->isRunning()  ; }
wasRunning=false  ;
firstRunningFrameTime=-1  ;
lastUpdateTime=-1  ;
startFraction=0  ;
startCalled=true  ;
startTime=SystemClock->uptimeMillis()  ;
endCalled=true  ;
endTime=SystemClock->uptimeMillis()  ;
cancelCalled=true  ;
pauseCalled=true  ;
resumeCalled=true  ;
mHandler->sendEmptyMessageDelayed(MSG_FRAME,mFrameDelay);
mFrameCallbacks->add(callback);
if(!mFrameCallbacks->contains(callback)  ){ mFrameCallbacks->add(callback); }
mHandler->postDelayed(runnable,COMMIT_DELAY);
return SystemClock->uptimeMillis()  ;
return mFrameDelay;
mFrameDelay=delay;
mHandler->removeMessages(MSG_FRAME);
mHandler->sendEmptyMessageDelayed(MSG_FRAME,mFrameDelay);
if(mFrameCallbacks->size()   != 0  ){ mHandler->removeMessages(MSG_FRAME);mHandler->sendEmptyMessageDelayed(MSG_FRAME,mFrameDelay); }
Looper->prepare();
mFrameCallbacks->get(i)  -> doFrame(SystemClock->uptimeMillis()  );
for(int i=0  ;i < mFrameCallbacks->size()  ;i++){ mFrameCallbacks->get(i)  -> doFrame(SystemClock->uptimeMillis()  ); }
break;
break;
switch(msg->what){caseMSG_FRAME: for(int i=0  ;i < mFrameCallbacks->size()  ;i++){ mFrameCallbacks->get(i)  -> doFrame(SystemClock->uptimeMillis()  ); }break; default: break; }
{ switch(msg->what){caseMSG_FRAME: for(int i=0  ;i < mFrameCallbacks->size()  ;i++){ mFrameCallbacks->get(i)  -> doFrame(SystemClock->uptimeMillis()  ); }break; default: break; } }
mHandler=new Handler(){void handleMessage(Message *  msg) { { switch(msg->what){caseMSG_FRAME: for(int i=0  ;i < mFrameCallbacks->size()  ;i++){ mFrameCallbacks->get(i)  -> doFrame(SystemClock->uptimeMillis()  ); }break; default: break; } } }}  ;
Looper->loop();
a1=ValueAnimator->ofFloat(A1_START_VALUE,A1_END_VALUE)  -> setDuration(300  );
a2=ValueAnimator->ofInt(A2_START_VALUE,A2_END_VALUE)  -> setDuration(500  );
a1=null  ;
a2=null  ;
}
void setUp(){a1=ValueAnimator->ofFloat(A1_START_VALUE,A1_END_VALUE)  -> setDuration(300  );a2=ValueAnimator->ofInt(A2_START_VALUE,A2_END_VALUE)  -> setDuration(500  );}
void tearDown(){a1=null  ;a2=null  ;}
}
#include "gtest/gtest.h"
using namespace testing;
using namespace testing::ext;
class ValueAnimatorTests : public testing::Test {
public:
long WAIT_TIME_OUT=5000  ;
ACE_EXPORTAnimator *  a1;
ACE_EXPORTAnimator *  a2;
long TOLERANCE=100  ;
long POLL_INTERVAL=100  ;
float A1_START_VALUE=0f  ;
float A1_END_VALUE=1f  ;
int A2_START_VALUE=100  ;
int A2_END_VALUE=200  ;
long DEFAULT_FRAME_INTERVAL=5  ;
long COMMIT_DELAY=3  ;
//以下组件没有匹配:
//ActivityTestRule<BasicAnimatorActivity>,ActivityTestRule
ActivityTestRule<BasicAnimatorActivity> *  mActivityRule=new ActivityTestRule(BasicAnimatorActivity.class  )  ;
MyUpdateListener{boolean wasRunning=false  ;long firstRunningFrameTime=-1  ;long lastUpdateTime=-1  ;float startFraction=0  ;void onAnimationUpdate(ACE_EXPORTAnimator *  animation) { lastUpdateTime=SystemClock->uptimeMillis()  ;if(animation->isRunning()   && !wasRunning){ firstRunningFrameTime=lastUpdateTime;startFraction=animation->getAnimatedFraction()  ;wasRunning=animation->isRunning()  ; } }void reset() { wasRunning=false  ;firstRunningFrameTime=-1  ;lastUpdateTime=-1  ;startFraction=0  ; }}
MyListener{boolean startCalled=false  ;boolean cancelCalled=false  ;boolean endCalled=false  ;long startTime=-1  ;long endTime=-1  ;void onAnimationStart(ACE_EXPORTAnimator *  animation) { startCalled=true  ;startTime=SystemClock->uptimeMillis()  ; }void onAnimationEnd(ACE_EXPORTAnimator *  animation) { endCalled=true  ;endTime=SystemClock->uptimeMillis()  ; }void onAnimationCancel(ACE_EXPORTAnimator *  animation) { cancelCalled=true  ; }void onAnimationRepeat(ACE_EXPORTAnimator *  animation) { }}
MyPauseListener{boolean pauseCalled=false  ;boolean resumeCalled=false  ;void onAnimationPause(ACE_EXPORTAnimator *  animation) { pauseCalled=true  ; }void onAnimationResume(ACE_EXPORTAnimator *  animation) { resumeCalled=true  ; }}
MyFrameCallbackProvider{Handler *  mHandler=null  ;int MSG_FRAME=0  ;long mFrameDelay=DEFAULT_FRAME_INTERVAL;ArrayList<Choreographer.FrameCallback> *  mFrameCallbacks=new ArrayList()  ;AssertionError *  mAssertionError=null  ;LooperThread *  mThread=new LooperThread()  ;nullvoid postFrameCallback(Choreographer.FrameCallback *  callback) { mHandler->sendEmptyMessageDelayed(MSG_FRAME,mFrameDelay);if(!mFrameCallbacks->contains(callback)  ){ mFrameCallbacks->add(callback); } }void postCommitCallback(Runnable *  runnable) { mHandler->postDelayed(runnable,COMMIT_DELAY); }long getFrameTime() { return SystemClock->uptimeMillis()  ; }long getFrameDelay() { return mFrameDelay; }void setFrameDelay(long delay) { mFrameDelay=delay;if(mFrameCallbacks->size()   != 0  ){ mHandler->removeMessages(MSG_FRAME);mHandler->sendEmptyMessageDelayed(MSG_FRAME,mFrameDelay); } }LooperThread{void run() { Looper->prepare();mHandler=new Handler(){void handleMessage(Message *  msg) { { switch(msg->what){caseMSG_FRAME: for(int i=0  ;i < mFrameCallbacks->size()  ;i++){ mFrameCallbacks->get(i)  -> doFrame(SystemClock->uptimeMillis()  ); }break; default: break; } } }}  ;Looper->loop(); }}}
void setUp()
{
lastUpdateTime=SystemClock->uptimeMillis()  ;
firstRunningFrameTime=lastUpdateTime;
startFraction=animation->getAnimatedFraction()  ;
wasRunning=animation->isRunning()  ;
if(animation->isRunning()   && !wasRunning){ firstRunningFrameTime=lastUpdateTime;startFraction=animation->getAnimatedFraction()  ;wasRunning=animation->isRunning()  ; }
wasRunning=false  ;
firstRunningFrameTime=-1  ;
lastUpdateTime=-1  ;
startFraction=0  ;
startCalled=true  ;
startTime=SystemClock->uptimeMillis()  ;
endCalled=true  ;
endTime=SystemClock->uptimeMillis()  ;
cancelCalled=true  ;
pauseCalled=true  ;
resumeCalled=true  ;
mHandler->sendEmptyMessageDelayed(MSG_FRAME,mFrameDelay);
mFrameCallbacks->add(callback);
if(!mFrameCallbacks->contains(callback)  ){ mFrameCallbacks->add(callback); }
mHandler->postDelayed(runnable,COMMIT_DELAY);
return SystemClock->uptimeMillis()  ;
return mFrameDelay;
mFrameDelay=delay;
mHandler->removeMessages(MSG_FRAME);
mHandler->sendEmptyMessageDelayed(MSG_FRAME,mFrameDelay);
if(mFrameCallbacks->size()   != 0  ){ mHandler->removeMessages(MSG_FRAME);mHandler->sendEmptyMessageDelayed(MSG_FRAME,mFrameDelay); }
Looper->prepare();
mFrameCallbacks->get(i)  -> doFrame(SystemClock->uptimeMillis()  );
for(int i=0  ;i < mFrameCallbacks->size()  ;i++){ mFrameCallbacks->get(i)  -> doFrame(SystemClock->uptimeMillis()  ); }
break;
break;
switch(msg->what){caseMSG_FRAME: for(int i=0  ;i < mFrameCallbacks->size()  ;i++){ mFrameCallbacks->get(i)  -> doFrame(SystemClock->uptimeMillis()  ); }break; default: break; }
{ switch(msg->what){caseMSG_FRAME: for(int i=0  ;i < mFrameCallbacks->size()  ;i++){ mFrameCallbacks->get(i)  -> doFrame(SystemClock->uptimeMillis()  ); }break; default: break; } }
mHandler=new Handler(){void handleMessage(Message *  msg) { { switch(msg->what){caseMSG_FRAME: for(int i=0  ;i < mFrameCallbacks->size()  ;i++){ mFrameCallbacks->get(i)  -> doFrame(SystemClock->uptimeMillis()  ); }break; default: break; } } }}  ;
Looper->loop();
a1=ValueAnimator->ofFloat(A1_START_VALUE,A1_END_VALUE)  -> setDuration(300  );
a2=ValueAnimator->ofInt(A2_START_VALUE,A2_END_VALUE)  -> setDuration(500  );
a1=null  ;
a2=null  ;
}
void tearDown()
{
lastUpdateTime=SystemClock->uptimeMillis()  ;
firstRunningFrameTime=lastUpdateTime;
startFraction=animation->getAnimatedFraction()  ;
wasRunning=animation->isRunning()  ;
if(animation->isRunning()   && !wasRunning){ firstRunningFrameTime=lastUpdateTime;startFraction=animation->getAnimatedFraction()  ;wasRunning=animation->isRunning()  ; }
wasRunning=false  ;
firstRunningFrameTime=-1  ;
lastUpdateTime=-1  ;
startFraction=0  ;
startCalled=true  ;
startTime=SystemClock->uptimeMillis()  ;
endCalled=true  ;
endTime=SystemClock->uptimeMillis()  ;
cancelCalled=true  ;
pauseCalled=true  ;
resumeCalled=true  ;
mHandler->sendEmptyMessageDelayed(MSG_FRAME,mFrameDelay);
mFrameCallbacks->add(callback);
if(!mFrameCallbacks->contains(callback)  ){ mFrameCallbacks->add(callback); }
mHandler->postDelayed(runnable,COMMIT_DELAY);
return SystemClock->uptimeMillis()  ;
return mFrameDelay;
mFrameDelay=delay;
mHandler->removeMessages(MSG_FRAME);
mHandler->sendEmptyMessageDelayed(MSG_FRAME,mFrameDelay);
if(mFrameCallbacks->size()   != 0  ){ mHandler->removeMessages(MSG_FRAME);mHandler->sendEmptyMessageDelayed(MSG_FRAME,mFrameDelay); }
Looper->prepare();
mFrameCallbacks->get(i)  -> doFrame(SystemClock->uptimeMillis()  );
for(int i=0  ;i < mFrameCallbacks->size()  ;i++){ mFrameCallbacks->get(i)  -> doFrame(SystemClock->uptimeMillis()  ); }
break;
break;
switch(msg->what){caseMSG_FRAME: for(int i=0  ;i < mFrameCallbacks->size()  ;i++){ mFrameCallbacks->get(i)  -> doFrame(SystemClock->uptimeMillis()  ); }break; default: break; }
{ switch(msg->what){caseMSG_FRAME: for(int i=0  ;i < mFrameCallbacks->size()  ;i++){ mFrameCallbacks->get(i)  -> doFrame(SystemClock->uptimeMillis()  ); }break; default: break; } }
mHandler=new Handler(){void handleMessage(Message *  msg) { { switch(msg->what){caseMSG_FRAME: for(int i=0  ;i < mFrameCallbacks->size()  ;i++){ mFrameCallbacks->get(i)  -> doFrame(SystemClock->uptimeMillis()  ); }break; default: break; } } }}  ;
Looper->loop();
a1=ValueAnimator->ofFloat(A1_START_VALUE,A1_END_VALUE)  -> setDuration(300  );
a2=ValueAnimator->ofInt(A2_START_VALUE,A2_END_VALUE)  -> setDuration(500  );
a1=null  ;
a2=null  ;
}
void setUp(){a1=ValueAnimator->ofFloat(A1_START_VALUE,A1_END_VALUE)  -> setDuration(300  );a2=ValueAnimator->ofInt(A2_START_VALUE,A2_END_VALUE)  -> setDuration(500  );}
void tearDown(){a1=null  ;a2=null  ;}
}
#include "gtest/gtest.h"
using namespace testing;
using namespace testing::ext;
class ValueAnimatorTests : public testing::Test {
public:
long WAIT_TIME_OUT=5000  ;
ACE_EXPORTAnimator *  a1;
ACE_EXPORTAnimator *  a2;
long TOLERANCE=100  ;
long POLL_INTERVAL=100  ;
float A1_START_VALUE=0f  ;
float A1_END_VALUE=1f  ;
int A2_START_VALUE=100  ;
int A2_END_VALUE=200  ;
long DEFAULT_FRAME_INTERVAL=5  ;
long COMMIT_DELAY=3  ;
//以下组件没有匹配:
//ActivityTestRule<BasicAnimatorActivity>,ActivityTestRule
ActivityTestRule<BasicAnimatorActivity> *  mActivityRule=new ActivityTestRule(BasicAnimatorActivity.class  )  ;
MyUpdateListener{boolean wasRunning=false  ;long firstRunningFrameTime=-1  ;long lastUpdateTime=-1  ;float startFraction=0  ;void onAnimationUpdate(ACE_EXPORTAnimator *  animation) { lastUpdateTime=SystemClock->uptimeMillis()  ;if(animation->isRunning()   && !wasRunning){ firstRunningFrameTime=lastUpdateTime;startFraction=animation->getAnimatedFraction()  ;wasRunning=animation->isRunning()  ; } }void reset() { wasRunning=false  ;firstRunningFrameTime=-1  ;lastUpdateTime=-1  ;startFraction=0  ; }}
MyListener{boolean startCalled=false  ;boolean cancelCalled=false  ;boolean endCalled=false  ;long startTime=-1  ;long endTime=-1  ;void onAnimationStart(ACE_EXPORTAnimator *  animation) { startCalled=true  ;startTime=SystemClock->uptimeMillis()  ; }void onAnimationEnd(ACE_EXPORTAnimator *  animation) { endCalled=true  ;endTime=SystemClock->uptimeMillis()  ; }void onAnimationCancel(ACE_EXPORTAnimator *  animation) { cancelCalled=true  ; }void onAnimationRepeat(ACE_EXPORTAnimator *  animation) { }}
MyPauseListener{boolean pauseCalled=false  ;boolean resumeCalled=false  ;void onAnimationPause(ACE_EXPORTAnimator *  animation) { pauseCalled=true  ; }void onAnimationResume(ACE_EXPORTAnimator *  animation) { resumeCalled=true  ; }}
MyFrameCallbackProvider{Handler *  mHandler=null  ;int MSG_FRAME=0  ;long mFrameDelay=DEFAULT_FRAME_INTERVAL;ArrayList<Choreographer.FrameCallback> *  mFrameCallbacks=new ArrayList()  ;AssertionError *  mAssertionError=null  ;LooperThread *  mThread=new LooperThread()  ;nullvoid postFrameCallback(Choreographer.FrameCallback *  callback) { mHandler->sendEmptyMessageDelayed(MSG_FRAME,mFrameDelay);if(!mFrameCallbacks->contains(callback)  ){ mFrameCallbacks->add(callback); } }void postCommitCallback(Runnable *  runnable) { mHandler->postDelayed(runnable,COMMIT_DELAY); }long getFrameTime() { return SystemClock->uptimeMillis()  ; }long getFrameDelay() { return mFrameDelay; }void setFrameDelay(long delay) { mFrameDelay=delay;if(mFrameCallbacks->size()   != 0  ){ mHandler->removeMessages(MSG_FRAME);mHandler->sendEmptyMessageDelayed(MSG_FRAME,mFrameDelay); } }LooperThread{void run() { Looper->prepare();mHandler=new Handler(){void handleMessage(Message *  msg) { { switch(msg->what){caseMSG_FRAME: for(int i=0  ;i < mFrameCallbacks->size()  ;i++){ mFrameCallbacks->get(i)  -> doFrame(SystemClock->uptimeMillis()  ); }break; default: break; } } }}  ;Looper->loop(); }}}
void setUp()
{
lastUpdateTime=SystemClock->uptimeMillis()  ;
firstRunningFrameTime=lastUpdateTime;
startFraction=animation->getAnimatedFraction()  ;
wasRunning=animation->isRunning()  ;
if(animation->isRunning()   && !wasRunning){ firstRunningFrameTime=lastUpdateTime;startFraction=animation->getAnimatedFraction()  ;wasRunning=animation->isRunning()  ; }
wasRunning=false  ;
firstRunningFrameTime=-1  ;
lastUpdateTime=-1  ;
startFraction=0  ;
startCalled=true  ;
startTime=SystemClock->uptimeMillis()  ;
endCalled=true  ;
endTime=SystemClock->uptimeMillis()  ;
cancelCalled=true  ;
pauseCalled=true  ;
resumeCalled=true  ;
mHandler->sendEmptyMessageDelayed(MSG_FRAME,mFrameDelay);
mFrameCallbacks->add(callback);
if(!mFrameCallbacks->contains(callback)  ){ mFrameCallbacks->add(callback); }
mHandler->postDelayed(runnable,COMMIT_DELAY);
return SystemClock->uptimeMillis()  ;
return mFrameDelay;
mFrameDelay=delay;
mHandler->removeMessages(MSG_FRAME);
mHandler->sendEmptyMessageDelayed(MSG_FRAME,mFrameDelay);
if(mFrameCallbacks->size()   != 0  ){ mHandler->removeMessages(MSG_FRAME);mHandler->sendEmptyMessageDelayed(MSG_FRAME,mFrameDelay); }
Looper->prepare();
mFrameCallbacks->get(i)  -> doFrame(SystemClock->uptimeMillis()  );
for(int i=0  ;i < mFrameCallbacks->size()  ;i++){ mFrameCallbacks->get(i)  -> doFrame(SystemClock->uptimeMillis()  ); }
break;
break;
switch(msg->what){caseMSG_FRAME: for(int i=0  ;i < mFrameCallbacks->size()  ;i++){ mFrameCallbacks->get(i)  -> doFrame(SystemClock->uptimeMillis()  ); }break; default: break; }
{ switch(msg->what){caseMSG_FRAME: for(int i=0  ;i < mFrameCallbacks->size()  ;i++){ mFrameCallbacks->get(i)  -> doFrame(SystemClock->uptimeMillis()  ); }break; default: break; } }
mHandler=new Handler(){void handleMessage(Message *  msg) { { switch(msg->what){caseMSG_FRAME: for(int i=0  ;i < mFrameCallbacks->size()  ;i++){ mFrameCallbacks->get(i)  -> doFrame(SystemClock->uptimeMillis()  ); }break; default: break; } } }}  ;
Looper->loop();
a1=ValueAnimator->ofFloat(A1_START_VALUE,A1_END_VALUE)  -> setDuration(300  );
a2=ValueAnimator->ofInt(A2_START_VALUE,A2_END_VALUE)  -> setDuration(500  );
a1=null  ;
a2=null  ;
ACE_EXPORTAnimator *  a=ValueAnimator->ofFloat(5f  ,20f  )  ;
ASSERT_EQ(a->getStartDelay()  ,0  );
long delay=200  ;
a->setStartDelay(delay);
ASSERT_EQ(a->getStartDelay()  ,delay);
ValueAnimatorTests::MyUpdateListener listener=new ValueAnimatorTests::MyUpdateListener()  ;
a->AddUpdateListener(listener);
long [] startTime= newlong[1] ;
ASSERT_FALSE(a->IsRunning()  );
ASSERT_FALSE(a->IsRunning()  );
a->Play();
startTime[0]=SystemClock->uptimeMillis()  ;
ASSERT_TRUE(a->IsRunning()  );
ASSERT_FALSE(a->IsRunning()  );
ASSERT_FALSE(a->IsRunning()  );
ASSERT_FALSE(a->IsRunning()  );
a->Play();
startTime[0]=SystemClock->uptimeMillis()  ;
ASSERT_TRUE(a->IsRunning()  );
ASSERT_FALSE(a->IsRunning()  );
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_FALSE(a->IsRunning()  );ASSERT_FALSE(a->IsRunning()  );a->Play();startTime[0]=SystemClock->uptimeMillis()  ;ASSERT_TRUE(a->IsRunning()  );ASSERT_FALSE(a->IsRunning()  ); }}  );
Thread->sleep(a->getTotalDuration()  );
ASSERT_TRUE(listener->wasRunning);
ASSERT_TRUE(listener->firstRunningFrameTime - startTime[0]   >= delay);
ASSERT_TRUE(listener->wasRunning);
ASSERT_TRUE(listener->firstRunningFrameTime - startTime[0]   >= delay);
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_TRUE(listener->wasRunning);ASSERT_TRUE(listener->firstRunningFrameTime - startTime[0]   >= delay); }}  );
Thread->sleep(a->getTotalDuration()  );
ASSERT_FALSE(a->IsRunning()  );
ASSERT_FALSE(a->IsRunning()  );
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_FALSE(a->IsRunning()  ); }}  );
ValueAnimatorTests::MyListener l1=new ValueAnimatorTests::MyListener()  ;
ValueAnimatorTests::MyListener l2=new ValueAnimatorTests::MyListener()  ;
a1->addListener(l1);
a2->addListener(l2);
a2->setStartDelay(400  );
ASSERT_FALSE(l1->startCalled);
ASSERT_FALSE(l1->cancelCalled);
ASSERT_FALSE(l1->endCalled);
ASSERT_FALSE(l2->startCalled);
ASSERT_FALSE(l2->cancelCalled);
ASSERT_FALSE(l2->endCalled);
a1->Play();
a2->Play();
a1->Play();
a2->Play();
mActivityRule->runOnUiThread(new Runnable(){void run() { a1->Play();a2->Play(); }}  );
long wait=0  ;
Thread->sleep(POLL_INTERVAL);
wait+=POLL_INTERVAL;
ASSERT_FALSE(l1->cancelCalled);
a1->cancel();
ASSERT_TRUE(l1->cancelCalled);
ASSERT_TRUE(l1->endCalled);
ASSERT_FALSE(l1->cancelCalled);
a1->cancel();
ASSERT_TRUE(l1->cancelCalled);
ASSERT_TRUE(l1->endCalled);
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_FALSE(l1->cancelCalled);a1->cancel();ASSERT_TRUE(l1->cancelCalled);ASSERT_TRUE(l1->endCalled); }}  );
ASSERT_TRUE(l1->startCalled);
ASSERT_FALSE(l2->startCalled);
ASSERT_TRUE(l1->startCalled);
ASSERT_FALSE(l2->startCalled);
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_TRUE(l1->startCalled);ASSERT_FALSE(l2->startCalled); }}  );
Thread->sleep(POLL_INTERVAL);
wait+=POLL_INTERVAL;
while(wait < a2->getStartDelay()  ){ mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_TRUE(l1->startCalled);ASSERT_FALSE(l2->startCalled); }}  );Thread->sleep(POLL_INTERVAL);wait+=POLL_INTERVAL; }
long delay=Math->max(a1->getTotalDuration()  ,a2->getTotalDuration()  )   + TOLERANCE;
Thread->sleep(delay);
ASSERT_TRUE(l1->startCalled);
ASSERT_TRUE(l1->cancelCalled);
ASSERT_TRUE(l1->endCalled);
ASSERT_TRUE(l2->startCalled);
ASSERT_FALSE(l2->cancelCalled);
ASSERT_TRUE(l2->endCalled);
ASSERT_TRUE(l1->startCalled);
ASSERT_TRUE(l1->cancelCalled);
ASSERT_TRUE(l1->endCalled);
ASSERT_TRUE(l2->startCalled);
ASSERT_FALSE(l2->cancelCalled);
ASSERT_TRUE(l2->endCalled);
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_TRUE(l1->startCalled);ASSERT_TRUE(l1->cancelCalled);ASSERT_TRUE(l1->endCalled);ASSERT_TRUE(l2->startCalled);ASSERT_FALSE(l2->cancelCalled);ASSERT_TRUE(l2->endCalled); }}  );
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a2->IsRunning()  );
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a2->IsRunning()  );
long startDelay=150  ;
a1->setStartDelay(startDelay);
long [] startTime= newlong[1] ;
a1->Play();
a2->Play();
startTime[0]=SystemClock->uptimeMillis()  ;
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a2->IsRunning()  );
a1->Play();
a2->Play();
startTime[0]=SystemClock->uptimeMillis()  ;
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a2->IsRunning()  );
mActivityRule->runOnUiThread(new Runnable(){void run() { a1->Play();a2->Play();startTime[0]=SystemClock->uptimeMillis()  ;ASSERT_TRUE(a1->IsRunning()  );ASSERT_TRUE(a2->IsRunning()  ); }}  );
long delayMs=0  ;
Thread->sleep(POLL_INTERVAL);
delayMs+=POLL_INTERVAL;
ASSERT_FALSE(a1->IsRunning()  );
if(SystemClock->uptimeMillis()   - startTime[0]   < startDelay){ ASSERT_FALSE(a1->IsRunning()  ); }
ASSERT_FALSE(a1->IsRunning()  );
if(SystemClock->uptimeMillis()   - startTime[0]   < startDelay){ ASSERT_FALSE(a1->IsRunning()  ); }
mActivityRule->runOnUiThread(new Runnable(){void run() { if(SystemClock->uptimeMillis()   - startTime[0]   < startDelay){ ASSERT_FALSE(a1->IsRunning()  ); } }}  );
while(delayMs < startDelay){ Thread->sleep(POLL_INTERVAL);delayMs+=POLL_INTERVAL;mActivityRule->runOnUiThread(new Runnable(){void run() { if(SystemClock->uptimeMillis()   - startTime[0]   < startDelay){ ASSERT_FALSE(a1->IsRunning()  ); } }}  ); }
Thread->sleep(startDelay);
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a2->IsRunning()  );
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a2->IsRunning()  );
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_TRUE(a1->IsRunning()  );ASSERT_TRUE(a2->IsRunning()  ); }}  );
long delay=Math->max(a1->getTotalDuration()  ,a2->getTotalDuration()  )   * 2  ;
Thread->sleep(delay);
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a2->IsRunning()  );
ASSERT_FALSE(a2->IsRunning()  );
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a2->IsRunning()  );
ASSERT_FALSE(a2->IsRunning()  );
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_FALSE(a1->IsRunning()  );ASSERT_FALSE(a1->IsRunning()  );ASSERT_FALSE(a2->IsRunning()  );ASSERT_FALSE(a2->IsRunning()  ); }}  );
ASSERT_FALSE(a1->IsPending()  );
ASSERT_FALSE(a2->IsPending()  );
a1->Play();
a2->Play();
ASSERT_FALSE(a1->IsPending()  );
ASSERT_FALSE(a2->IsPending()  );
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a2->IsRunning()  );
ASSERT_FALSE(a1->IsPending()  );
ASSERT_FALSE(a2->IsPending()  );
a1->Play();
a2->Play();
ASSERT_FALSE(a1->IsPending()  );
ASSERT_FALSE(a2->IsPending()  );
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a2->IsRunning()  );
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_FALSE(a1->IsPending()  );ASSERT_FALSE(a2->IsPending()  );a1->Play();a2->Play();ASSERT_FALSE(a1->IsPending()  );ASSERT_FALSE(a2->IsPending()  );ASSERT_TRUE(a1->IsRunning()  );ASSERT_TRUE(a2->IsRunning()  ); }}  );
Thread->sleep(POLL_INTERVAL);
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a2->IsRunning()  );
a1->Pause();
ASSERT_TRUE(a1->IsPending()  );
ASSERT_FALSE(a2->IsPending()  );
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a2->IsRunning()  );
a1->Pause();
ASSERT_TRUE(a1->IsPending()  );
ASSERT_FALSE(a2->IsPending()  );
ASSERT_TRUE(a1->IsRunning()  );
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_TRUE(a1->IsRunning()  );ASSERT_TRUE(a2->IsRunning()  );a1->Pause();ASSERT_TRUE(a1->IsPending()  );ASSERT_FALSE(a2->IsPending()  );ASSERT_TRUE(a1->IsRunning()  ); }}  );
Thread->sleep(a2->getTotalDuration()  );
ASSERT_FALSE(a2->IsRunning()  );
ASSERT_FALSE(a2->IsRunning()  );
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a1->IsPending()  );
a1->resume();
ASSERT_FALSE(a2->IsRunning()  );
ASSERT_FALSE(a2->IsRunning()  );
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a1->IsPending()  );
a1->resume();
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_FALSE(a2->IsRunning()  );ASSERT_FALSE(a2->IsRunning()  );ASSERT_TRUE(a1->IsRunning()  );ASSERT_TRUE(a1->IsRunning()  );ASSERT_TRUE(a1->IsPending()  );a1->resume(); }}  );
Thread->sleep(POLL_INTERVAL);
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_FALSE(a1->IsPending()  );
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_FALSE(a1->IsPending()  );
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_TRUE(a1->IsRunning()  );ASSERT_TRUE(a1->IsRunning()  );ASSERT_FALSE(a1->IsPending()  ); }}  );
Thread->sleep(a1->getTotalDuration()  );
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a1->IsPending()  );
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a1->IsPending()  );
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_FALSE(a1->IsRunning()  );ASSERT_FALSE(a1->IsRunning()  );ASSERT_FALSE(a1->IsPending()  ); }}  );
ValueAnimatorTests::MyPauseListener l1=new ValueAnimatorTests::MyPauseListener()  ;
ValueAnimatorTests::MyPauseListener l2=new ValueAnimatorTests::MyPauseListener()  ;
a1->addPauseListener(l1);
a2->addPauseListener(l2);
ASSERT_FALSE(l1->pauseCalled);
ASSERT_FALSE(l1->resumeCalled);
ASSERT_FALSE(l2->pauseCalled);
ASSERT_FALSE(l2->resumeCalled);
a1->Play();
a2->Play();
a1->Play();
a2->Play();
mActivityRule->runOnUiThread(new Runnable(){void run() { a1->Play();a2->Play(); }}  );
Thread->sleep(a1->getTotalDuration()   / 2  );
a1->Pause();
Thread->sleep(a2->getTotalDuration()  );
ASSERT_TRUE(l1->pauseCalled);
ASSERT_FALSE(l1->resumeCalled);
a1->resume();
a1->resume();
mActivityRule->runOnUiThread(new Runnable(){void run() { a1->resume(); }}  );
Thread->sleep(a1->getTotalDuration()  );
ASSERT_TRUE(l1->pauseCalled);
ASSERT_TRUE(l1->resumeCalled);
ASSERT_FALSE(l2->pauseCalled);
ASSERT_FALSE(l2->resumeCalled);
ValueAnimatorTests::MyUpdateListener l1=new ValueAnimatorTests::MyUpdateListener()  ;
long totalDuration=a1->getTotalDuration()  ;
a1->AddUpdateListener(l1);
a1->setDuration(1000  );
ASSERT_TRUE(l1->firstRunningFrameTime < 0  );
ASSERT_TRUE(l1->lastUpdateTime < 0  );
long [] lastUpdate= newlong[1] ;
a1->Play();
a1->Play();
mActivityRule->runOnUiThread(new Runnable(){void run() { a1->Play(); }}  );
Thread->sleep(totalDuration / 2  );
ASSERT_TRUE(l1->firstRunningFrameTime > 0  );
ASSERT_TRUE(l1->lastUpdateTime > l1->firstRunningFrameTime);
lastUpdate[0]=l1->lastUpdateTime;
a1->Pause();
ASSERT_TRUE(l1->firstRunningFrameTime > 0  );
ASSERT_TRUE(l1->lastUpdateTime > l1->firstRunningFrameTime);
lastUpdate[0]=l1->lastUpdateTime;
a1->Pause();
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_TRUE(l1->firstRunningFrameTime > 0  );ASSERT_TRUE(l1->lastUpdateTime > l1->firstRunningFrameTime);lastUpdate[0]=l1->lastUpdateTime;a1->Pause(); }}  );
Thread->sleep(totalDuration);
ASSERT_EQ(lastUpdate[0]  ,l1->lastUpdateTime);
a1->resume();
ASSERT_EQ(lastUpdate[0]  ,l1->lastUpdateTime);
a1->resume();
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_EQ(lastUpdate[0]  ,l1->lastUpdateTime);a1->resume(); }}  );
Thread->sleep(POLL_INTERVAL);
ASSERT_TRUE(l1->lastUpdateTime > lastUpdate[0]  );
lastUpdate[0]=l1->lastUpdateTime;
ASSERT_TRUE(l1->lastUpdateTime > lastUpdate[0]  );
lastUpdate[0]=l1->lastUpdateTime;
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_TRUE(l1->lastUpdateTime > lastUpdate[0]  );lastUpdate[0]=l1->lastUpdateTime; }}  );
do{ Thread->sleep(POLL_INTERVAL);mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_TRUE(l1->lastUpdateTime > lastUpdate[0]  );lastUpdate[0]=l1->lastUpdateTime; }}  ); }while(!a1->IsRunning()  );
long entireSpan=totalDuration * 2  ;
long frameDelta=l1->lastUpdateTime - l1->firstRunningFrameTime;
ASSERT_TRUE(Math->abs(entireSpan - frameDelta)   < TOLERANCE);
ValueAnimatorTests::MyListener l1=new ValueAnimatorTests::MyListener()  ;
ValueAnimatorTests::MyListener l2=new ValueAnimatorTests::MyListener()  ;
a1->addListener(l1);
a2->addListener(l2);
anim->Cancel();
anim->Cancel();
a1->addListener(new ValueAnimatorTests::MyListener(){void onAnimationEnd(ACE_EXPORTAnimator *  anim) { anim->Cancel(); }}  );
anim->end();
anim->end();
a2->addListener(new ValueAnimatorTests::MyListener(){void onAnimationCancel(ACE_EXPORTAnimator *  anim) { anim->end(); }}  );
ASSERT_FALSE(l1->cancelCalled);
ASSERT_FALSE(l1->endCalled);
ASSERT_FALSE(l2->cancelCalled);
ASSERT_FALSE(l2->endCalled);
a1->Play();
a2->Play();
ASSERT_FALSE(l1->cancelCalled);
ASSERT_FALSE(l1->endCalled);
ASSERT_FALSE(l2->cancelCalled);
ASSERT_FALSE(l2->endCalled);
a1->Play();
a2->Play();
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_FALSE(l1->cancelCalled);ASSERT_FALSE(l1->endCalled);ASSERT_FALSE(l2->cancelCalled);ASSERT_FALSE(l2->endCalled);a1->Play();a2->Play(); }}  );
Thread->sleep(POLL_INTERVAL);
a1->Stop();
a2->cancel();
a1->Stop();
a2->cancel();
mActivityRule->runOnUiThread(new Runnable(){void run() { a1->Stop();a2->cancel(); }}  );
Thread->sleep(POLL_INTERVAL);
ASSERT_FALSE(l1->cancelCalled);
ASSERT_TRUE(l1->endCalled);
ASSERT_TRUE(l2->cancelCalled);
ASSERT_TRUE(l2->endCalled);
float value1=(Float)a1.getAnimatedValue();
int value2=(Integer)a2.getAnimatedValue();
ASSERT_EQ(A1_END_VALUE,value1);
ASSERT_EQ(A2_END_VALUE,value2);
ASSERT_FALSE(l1->cancelCalled);
ASSERT_TRUE(l1->endCalled);
ASSERT_TRUE(l2->cancelCalled);
ASSERT_TRUE(l2->endCalled);
float value1=(Float)a1.getAnimatedValue();
int value2=(Integer)a2.getAnimatedValue();
ASSERT_EQ(A1_END_VALUE,value1);
ASSERT_EQ(A2_END_VALUE,value2);
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_FALSE(l1->cancelCalled);ASSERT_TRUE(l1->endCalled);ASSERT_TRUE(l2->cancelCalled);ASSERT_TRUE(l2->endCalled);float value1=(Float)a1.getAnimatedValue();int value2=(Integer)a2.getAnimatedValue();ASSERT_EQ(A1_END_VALUE,value1);ASSERT_EQ(A2_END_VALUE,value2); }}  );
ValueAnimatorTests::MyListener l1=new ValueAnimatorTests::MyListener()  ;
a1->addListener(l1);
ValueAnimatorTests::MyListener l2=new ValueAnimatorTests::MyListener()  ;
a2->addListener(l2);
a1->Play();
a2->Play();
a1->Play();
a2->Play();
mActivityRule->runOnUiThread(new Runnable(){void run() { a1->Play();a2->Play(); }}  );
Thread->sleep(POLL_INTERVAL);
ASSERT_FALSE(l1->endCalled);
ASSERT_FALSE(l2->endCalled);
assertNotEqual(A1_END_VALUE,a1->getAnimatedValue()  );
assertNotEqual(A1_END_VALUE,a2->getAnimatedValue()  );
a2->Stop();
ASSERT_FALSE(l1->endCalled);
ASSERT_FALSE(l2->endCalled);
assertNotEqual(A1_END_VALUE,a1->getAnimatedValue()  );
assertNotEqual(A1_END_VALUE,a2->getAnimatedValue()  );
a2->Stop();
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_FALSE(l1->endCalled);ASSERT_FALSE(l2->endCalled);assertNotEqual(A1_END_VALUE,a1->getAnimatedValue()  );assertNotEqual(A1_END_VALUE,a2->getAnimatedValue()  );a2->Stop(); }}  );
Thread->sleep(a1->getTotalDuration()  );
ASSERT_FALSE(l1->cancelCalled);
ASSERT_TRUE(l1->endCalled);
ASSERT_FALSE(l2->cancelCalled);
ASSERT_TRUE(l2->endCalled);
ASSERT_EQ(A1_END_VALUE,((Float)(a1.getAnimatedValue()))  -> floatValue());
ASSERT_EQ(A2_END_VALUE,((Integer)(a2.getAnimatedValue()))  -> intValue());
ASSERT_FALSE(l1->cancelCalled);
ASSERT_TRUE(l1->endCalled);
ASSERT_FALSE(l2->cancelCalled);
ASSERT_TRUE(l2->endCalled);
ASSERT_EQ(A1_END_VALUE,((Float)(a1.getAnimatedValue()))  -> floatValue());
ASSERT_EQ(A2_END_VALUE,((Integer)(a2.getAnimatedValue()))  -> intValue());
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_FALSE(l1->cancelCalled);ASSERT_TRUE(l1->endCalled);ASSERT_FALSE(l2->cancelCalled);ASSERT_TRUE(l2->endCalled);ASSERT_EQ(A1_END_VALUE,((Float)(a1.getAnimatedValue()))  -> floatValue());ASSERT_EQ(A2_END_VALUE,((Integer)(a2.getAnimatedValue()))  -> intValue()); }}  );
ValueAnimatorTests::MyFrameCallbackProvider provider=new ValueAnimatorTests::MyFrameCallbackProvider()  ;
long sleep=0  ;
Thread->sleep(POLL_INTERVAL);
sleep+=POLL_INTERVAL;
break;
if(sleep > WAIT_TIME_OUT){ break; }
while(provider->mHandler == null  ){ Thread->sleep(POLL_INTERVAL);sleep+=POLL_INTERVAL;if(sleep > WAIT_TIME_OUT){ break; } }
assertNotNull(provider->mHandler);
ValueAnimatorTests::MyListener listener=new ValueAnimatorTests::MyListener()  ;
long currentTime=SystemClock->uptimeMillis()  ;
long frameDelay=provider->getFrameDelay()  ;
ASSERT_TRUE((currentTime-lastUpdateTime)   < frameDelay * 4  );
ASSERT_TRUE(listener->startCalled);
ASSERT_TRUE(listener->startTime > 0  );
ASSERT_TRUE(currentTime - listener->startTime < frameDelay * 4  );
if(lastUpdateTime > 0  ){ ASSERT_TRUE((currentTime-lastUpdateTime)   < frameDelay * 4  ); }else{ ASSERT_TRUE(listener->startCalled);ASSERT_TRUE(listener->startTime > 0  );ASSERT_TRUE(currentTime - listener->startTime < frameDelay * 4  ); }
super-> onAnimationUpdate(animation);
ValueAnimatorTests::MyUpdateListener l1=new ValueAnimatorTests::MyUpdateListener(){void onAnimationUpdate(ACE_EXPORTAnimator *  animation) { long currentTime=SystemClock->uptimeMillis()  ;long frameDelay=provider->getFrameDelay()  ;if(lastUpdateTime > 0  ){ ASSERT_TRUE((currentTime-lastUpdateTime)   < frameDelay * 4  ); }else{ ASSERT_TRUE(listener->startCalled);ASSERT_TRUE(listener->startTime > 0  );ASSERT_TRUE(currentTime - listener->startTime < frameDelay * 4  ); }super-> onAnimationUpdate(animation); }}  ;
a1->AddUpdateListener(l1);
a1->addListener(listener);
a1->setStartDelay(100  );
AnimationHandler->getInstance()  -> setProvider(provider);
a1->Play();
AnimationHandler->getInstance()  -> setProvider(provider);
a1->Play();
provider.mHandler->post(new Runnable(){void run() { AnimationHandler->getInstance()  -> setProvider(provider);a1->Play(); }}  );
Thread->sleep(POLL_INTERVAL);
ASSERT_TRUE(a1->IsRunning()  );
Thread->sleep(a1->getTotalDuration()   + TOLERANCE);
throwprovider->mAssertionError;
if(provider->mAssertionError != null  ){ throwprovider->mAssertionError; }
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_TRUE(listener->endTime > 0  );
ASSERT_TRUE(listener->endTime >= l1->lastUpdateTime);
ASSERT_TRUE(listener->endTime - l1->lastUpdateTime < 2   * provider->getFrameDelay()  );
ACE_EXPORTAnimator *  a0=ValueAnimator->ofInt(100  ,200  )  -> setDuration(500  );
ACE_EXPORTAnimator *  a3=ValueAnimator->ofFloat(0  ,1  )  -> setDuration(500  );
ACE_EXPORTAnimator *  a4=ValueAnimator->ofInt(200  ,300  )  -> setDuration(500  );
super-> onAnimationEnd(anim);
a0->cancel();
a1->Stop();
a3->Stop();
a4->cancel();
ValueAnimatorTests::MyListener listener=new ValueAnimatorTests::MyListener(){void onAnimationEnd(ACE_EXPORTAnimator *  anim) { super-> onAnimationEnd(anim);a0->cancel();a1->Stop();a3->Stop();a4->cancel(); }}  ;
a2->addListener(listener);
a0->Play();
a1->Play();
a2->Play();
a3->Play();
a4->Play();
a0->Play();
a1->Play();
a2->Play();
a3->Play();
a4->Play();
mActivityRule->runOnUiThread(new Runnable(){void run() { a0->Play();a1->Play();a2->Play();a3->Play();a4->Play(); }}  );
ASSERT_TRUE(a0->IsRunning()  );
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a2->IsRunning()  );
ASSERT_TRUE(a3->IsRunning()  );
ASSERT_TRUE(a4->IsRunning()  );
ASSERT_TRUE(a0->IsRunning()  );
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a2->IsRunning()  );
ASSERT_TRUE(a3->IsRunning()  );
ASSERT_TRUE(a4->IsRunning()  );
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_TRUE(a0->IsRunning()  );ASSERT_TRUE(a1->IsRunning()  );ASSERT_TRUE(a2->IsRunning()  );ASSERT_TRUE(a3->IsRunning()  );ASSERT_TRUE(a4->IsRunning()  ); }}  );
Thread->sleep(POLL_INTERVAL);
a2->Stop();
a2->Stop();
mActivityRule->runOnUiThread(new Runnable(){void run() { a2->Stop(); }}  );
Thread->sleep(POLL_INTERVAL);
ASSERT_TRUE(listener->endCalled);
ASSERT_FALSE(a0->IsRunning()  );
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a2->IsRunning()  );
ASSERT_FALSE(a3->IsRunning()  );
ASSERT_FALSE(a4->IsRunning()  );
ValueAnimatorTests::MyListener l1=new ValueAnimatorTests::MyListener()  ;
ValueAnimatorTests::MyListener l2=new ValueAnimatorTests::MyListener()  ;
ValueAnimatorTests::MyUpdateListener updateListener1=new ValueAnimatorTests::MyUpdateListener()  ;
ValueAnimatorTests::MyUpdateListener updateListener2=new ValueAnimatorTests::MyUpdateListener()  ;
float a1StartFraction=0.2f  ;
float a2StartFraction=0.3f  ;
a1->setDuration(1000  );
a2->setDuration(1000  );
a1->addListener(l1);
a2->addListener(l2);
a1->AddUpdateListener(updateListener1);
a2->AddUpdateListener(updateListener2);
//以下组件没有匹配:
//TimeInterpolator,LinearInterpolator
TimeInterpolator *  interpolator=new LinearInterpolator()  ;
a1->setInterpolator(interpolator);
a2->setInterpolator(interpolator);
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a2->IsRunning()  );
ASSERT_FALSE(a2->IsRunning()  );
a1->setCurrentFraction(a1StartFraction);
a2->setCurrentFraction(a2StartFraction);
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a2->IsRunning()  );
ASSERT_FALSE(a2->IsRunning()  );
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a2->IsRunning()  );
ASSERT_FALSE(a2->IsRunning()  );
a1->setCurrentFraction(a1StartFraction);
a2->setCurrentFraction(a2StartFraction);
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a2->IsRunning()  );
ASSERT_FALSE(a2->IsRunning()  );
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_FALSE(a1->IsRunning()  );ASSERT_FALSE(a1->IsRunning()  );ASSERT_FALSE(a2->IsRunning()  );ASSERT_FALSE(a2->IsRunning()  );a1->setCurrentFraction(a1StartFraction);a2->setCurrentFraction(a2StartFraction);ASSERT_FALSE(a1->IsRunning()  );ASSERT_FALSE(a1->IsRunning()  );ASSERT_FALSE(a2->IsRunning()  );ASSERT_FALSE(a2->IsRunning()  ); }}  );
Thread->sleep(POLL_INTERVAL);
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a2->IsRunning()  );
ASSERT_FALSE(a2->IsRunning()  );
ASSERT_EQ(a1StartFraction,a1->getAnimatedFraction()  );
ASSERT_EQ(a2StartFraction,a2->getAnimatedFraction()  );
a1->Play();
a2->Play();
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a2->IsRunning()  );
ASSERT_FALSE(a2->IsRunning()  );
ASSERT_EQ(a1StartFraction,a1->getAnimatedFraction()  );
ASSERT_EQ(a2StartFraction,a2->getAnimatedFraction()  );
a1->Play();
a2->Play();
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_FALSE(a1->IsRunning()  );ASSERT_FALSE(a1->IsRunning()  );ASSERT_FALSE(a2->IsRunning()  );ASSERT_FALSE(a2->IsRunning()  );ASSERT_EQ(a1StartFraction,a1->getAnimatedFraction()  );ASSERT_EQ(a2StartFraction,a2->getAnimatedFraction()  );a1->Play();a2->Play(); }}  );
Thread->sleep(POLL_INTERVAL);
float halfwayFraction=0.5f  ;
ASSERT_TRUE(l1->startCalled);
ASSERT_TRUE(l2->startCalled);
ASSERT_FALSE(l1->endCalled);
ASSERT_FALSE(l2->endCalled);
ASSERT_TRUE(updateListener1->startFraction >= a1StartFraction);
ASSERT_TRUE(updateListener2->startFraction >= a2StartFraction);
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a2->IsRunning()  );
ASSERT_TRUE(a2->IsRunning()  );
a1->setCurrentFraction(halfwayFraction);
a2->setCurrentFraction(halfwayFraction);
ASSERT_TRUE(l1->startCalled);
ASSERT_TRUE(l2->startCalled);
ASSERT_FALSE(l1->endCalled);
ASSERT_FALSE(l2->endCalled);
ASSERT_TRUE(updateListener1->startFraction >= a1StartFraction);
ASSERT_TRUE(updateListener2->startFraction >= a2StartFraction);
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a2->IsRunning()  );
ASSERT_TRUE(a2->IsRunning()  );
a1->setCurrentFraction(halfwayFraction);
a2->setCurrentFraction(halfwayFraction);
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_TRUE(l1->startCalled);ASSERT_TRUE(l2->startCalled);ASSERT_FALSE(l1->endCalled);ASSERT_FALSE(l2->endCalled);ASSERT_TRUE(updateListener1->startFraction >= a1StartFraction);ASSERT_TRUE(updateListener2->startFraction >= a2StartFraction);ASSERT_TRUE(a1->IsRunning()  );ASSERT_TRUE(a1->IsRunning()  );ASSERT_TRUE(a2->IsRunning()  );ASSERT_TRUE(a2->IsRunning()  );a1->setCurrentFraction(halfwayFraction);a2->setCurrentFraction(halfwayFraction); }}  );
Thread->sleep(POLL_INTERVAL);
ASSERT_TRUE(l1->startCalled);
ASSERT_TRUE(l2->startCalled);
ASSERT_FALSE(l1->endCalled);
ASSERT_FALSE(l2->endCalled);
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a2->IsRunning()  );
ASSERT_TRUE(a2->IsRunning()  );
ASSERT_TRUE(l1->startCalled);
ASSERT_TRUE(l2->startCalled);
ASSERT_FALSE(l1->endCalled);
ASSERT_FALSE(l2->endCalled);
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a2->IsRunning()  );
ASSERT_TRUE(a2->IsRunning()  );
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_TRUE(l1->startCalled);ASSERT_TRUE(l2->startCalled);ASSERT_FALSE(l1->endCalled);ASSERT_FALSE(l2->endCalled);ASSERT_TRUE(a1->IsRunning()  );ASSERT_TRUE(a1->IsRunning()  );ASSERT_TRUE(a2->IsRunning()  );ASSERT_TRUE(a2->IsRunning()  ); }}  );
long wait=Math->max(a1->getTotalDuration()  ,a2->getTotalDuration()  )  ;
Thread->sleep(wait);
ASSERT_TRUE(l1->endCalled);
ASSERT_TRUE(l2->endCalled);
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a2->IsRunning()  );
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a2->IsRunning()  );
ASSERT_TRUE(l1->endCalled);
ASSERT_TRUE(l2->endCalled);
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a2->IsRunning()  );
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a2->IsRunning()  );
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_TRUE(l1->endCalled);ASSERT_TRUE(l2->endCalled);ASSERT_FALSE(a1->IsRunning()  );ASSERT_FALSE(a2->IsRunning()  );ASSERT_FALSE(a1->IsRunning()  );ASSERT_FALSE(a2->IsRunning()  ); }}  );
updateListener1->reset();
a1->Play();
a1->Play();
mActivityRule->runOnUiThread(new Runnable(){void run() { a1->Play(); }}  );
Thread->sleep(POLL_INTERVAL);
ASSERT_TRUE(updateListener1->wasRunning);
ASSERT_TRUE(updateListener1->startFraction >= 0  );
ASSERT_TRUE(updateListener1->startFraction < halfwayFraction);
a1->Stop();
ASSERT_TRUE(updateListener1->wasRunning);
ASSERT_TRUE(updateListener1->startFraction >= 0  );
ASSERT_TRUE(updateListener1->startFraction < halfwayFraction);
a1->Stop();
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_TRUE(updateListener1->wasRunning);ASSERT_TRUE(updateListener1->startFraction >= 0  );ASSERT_TRUE(updateListener1->startFraction < halfwayFraction);a1->Stop(); }}  );
ValueAnimatorTests::MyListener l1=new ValueAnimatorTests::MyListener()  ;
ValueAnimatorTests::MyListener l2=new ValueAnimatorTests::MyListener()  ;
a1->addListener(l1);
a2->addListener(l2);
ASSERT_FALSE(l1->startCalled);
ASSERT_FALSE(l2->startCalled);
ASSERT_EQ(0f  ,a1->getAnimatedFraction()  );
ASSERT_EQ(0f  ,a2->getAnimatedFraction()  );
a1->Play();
a2->Play();
ASSERT_FALSE(l1->startCalled);
ASSERT_FALSE(l2->startCalled);
ASSERT_EQ(0f  ,a1->getAnimatedFraction()  );
ASSERT_EQ(0f  ,a2->getAnimatedFraction()  );
a1->Play();
a2->Play();
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_FALSE(l1->startCalled);ASSERT_FALSE(l2->startCalled);ASSERT_EQ(0f  ,a1->getAnimatedFraction()  );ASSERT_EQ(0f  ,a2->getAnimatedFraction()  );a1->Play();a2->Play(); }}  );
Thread->sleep(POLL_INTERVAL);
ASSERT_FALSE(l1->endCalled);
ASSERT_FALSE(l2->endCalled);
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a2->IsRunning()  );
a1->setCurrentFraction(0f  );
a2->setCurrentFraction(1f  );
ASSERT_FALSE(l1->endCalled);
ASSERT_FALSE(l2->endCalled);
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a2->IsRunning()  );
a1->setCurrentFraction(0f  );
a2->setCurrentFraction(1f  );
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_FALSE(l1->endCalled);ASSERT_FALSE(l2->endCalled);ASSERT_TRUE(a1->IsRunning()  );ASSERT_TRUE(a2->IsRunning()  );a1->setCurrentFraction(0f  );a2->setCurrentFraction(1f  ); }}  );
Thread->sleep(POLL_INTERVAL);
ASSERT_FALSE(l1->endCalled);
ASSERT_TRUE(l2->endCalled);
ASSERT_EQ(1f  ,a2->getAnimatedFraction()  );
ASSERT_FALSE(l1->endCalled);
ASSERT_TRUE(l2->endCalled);
ASSERT_EQ(1f  ,a2->getAnimatedFraction()  );
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_FALSE(l1->endCalled);ASSERT_TRUE(l2->endCalled);ASSERT_EQ(1f  ,a2->getAnimatedFraction()  ); }}  );
Thread->sleep(a1->getTotalDuration()  );
ASSERT_TRUE(l1->endCalled);
ASSERT_EQ(1f  ,a1->getAnimatedFraction()  );
ASSERT_TRUE(l1->endCalled);
ASSERT_EQ(1f  ,a1->getAnimatedFraction()  );
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_TRUE(l1->endCalled);ASSERT_EQ(1f  ,a1->getAnimatedFraction()  ); }}  );
a1->setStartDelay(20  );
ValueAnimatorTests::MyListener normalEndingListener=new ValueAnimatorTests::MyListener()  ;
a1->addListener(normalEndingListener);
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(normalEndingListener->startCalled);
ASSERT_FALSE(normalEndingListener->endCalled);
a1->Play();
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(normalEndingListener->startCalled);
ASSERT_FALSE(normalEndingListener->endCalled);
a1->Play();
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_FALSE(a1->IsRunning()  );ASSERT_FALSE(normalEndingListener->startCalled);ASSERT_FALSE(normalEndingListener->endCalled);a1->Play(); }}  );
Thread->sleep(a1->getTotalDuration()   + POLL_INTERVAL);
ValueAnimatorTests::MyListener l1=new ValueAnimatorTests::MyListener()  ;
a1->addListener(l1);
ValueAnimatorTests::MyListener l2=new ValueAnimatorTests::MyListener()  ;
a2->addListener(l2);
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(l1->startCalled);
ASSERT_FALSE(l1->endCalled);
ASSERT_FALSE(a2->IsRunning()  );
ASSERT_FALSE(l2->startCalled);
ASSERT_FALSE(l1->endCalled);
a1->Stop();
a2->Stop();
ASSERT_TRUE(l1->startCalled);
ASSERT_TRUE(l1->endCalled);
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_TRUE(l1->endTime >= l1->startTime);
ASSERT_TRUE(l2->startCalled);
ASSERT_TRUE(l2->endCalled);
ASSERT_FALSE(a2->IsRunning()  );
ASSERT_TRUE(l2->endTime >= l1->startTime);
ValueAnimatorTests::MyListener l1=new ValueAnimatorTests::MyListener()  ;
a1->addListener(l1);
ValueAnimatorTests::MyListener l2=new ValueAnimatorTests::MyListener()  ;
a2->addListener(l2);
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(l1->startCalled);
ASSERT_FALSE(l1->endCalled);
ASSERT_FALSE(a2->IsRunning()  );
ASSERT_FALSE(l2->startCalled);
ASSERT_FALSE(l1->endCalled);
a1->Stop();
a2->Stop();
ASSERT_TRUE(l1->startCalled);
ASSERT_TRUE(l1->endCalled);
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_TRUE(l1->endTime >= l1->startTime);
ASSERT_TRUE(l2->startCalled);
ASSERT_TRUE(l2->endCalled);
ASSERT_FALSE(a2->IsRunning()  );
ASSERT_TRUE(l2->endTime >= l1->startTime);
mActivityRule->runOnUiThread(new Runnable(){void run() { ValueAnimatorTests::MyListener l1=new ValueAnimatorTests::MyListener()  ;a1->addListener(l1);ValueAnimatorTests::MyListener l2=new ValueAnimatorTests::MyListener()  ;a2->addListener(l2);ASSERT_FALSE(a1->IsRunning()  );ASSERT_FALSE(l1->startCalled);ASSERT_FALSE(l1->endCalled);ASSERT_FALSE(a2->IsRunning()  );ASSERT_FALSE(l2->startCalled);ASSERT_FALSE(l1->endCalled);a1->Stop();a2->Stop();ASSERT_TRUE(l1->startCalled);ASSERT_TRUE(l1->endCalled);ASSERT_FALSE(a1->IsRunning()  );ASSERT_TRUE(l1->endTime >= l1->startTime);ASSERT_TRUE(l2->startCalled);ASSERT_TRUE(l2->endCalled);ASSERT_FALSE(a2->IsRunning()  );ASSERT_TRUE(l2->endTime >= l1->startTime); }}  );
a1->setDuration(0  );
a2->setDuration(0  );
ACE_EXPORTAnimator *  a3=ValueAnimator->ofInt(0  ,100  )  ;
a3->setDuration(0  );
a3->setCurrentFraction(1.0f  );
ASSERT_EQ(1.0f  ,a3->getAnimatedFraction()  );
ValueAnimatorTests::MyListener l1=new ValueAnimatorTests::MyListener()  ;
ValueAnimatorTests::MyListener l2=new ValueAnimatorTests::MyListener()  ;
ValueAnimatorTests::MyListener l3=new ValueAnimatorTests::MyListener()  ;
a1->addListener(l1);
a2->addListener(l2);
a3->addListener(l3);
ASSERT_FALSE(l1->startCalled);
ASSERT_FALSE(l2->startCalled);
ASSERT_FALSE(l3->startCalled);
ASSERT_FALSE(l1->endCalled);
ASSERT_FALSE(l2->endCalled);
ASSERT_FALSE(l3->endCalled);
a1->Play();
a2->reverse();
a3->Play();
ASSERT_EQ(A1_END_VALUE,a1->getAnimatedValue()  );
ASSERT_EQ(A2_START_VALUE,a2->getAnimatedValue()  );
ASSERT_FALSE(l1->startCalled);
ASSERT_FALSE(l2->startCalled);
ASSERT_FALSE(l3->startCalled);
ASSERT_FALSE(l1->endCalled);
ASSERT_FALSE(l2->endCalled);
ASSERT_FALSE(l3->endCalled);
a1->Play();
a2->reverse();
a3->Play();
ASSERT_EQ(A1_END_VALUE,a1->getAnimatedValue()  );
ASSERT_EQ(A2_START_VALUE,a2->getAnimatedValue()  );
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_FALSE(l1->startCalled);ASSERT_FALSE(l2->startCalled);ASSERT_FALSE(l3->startCalled);ASSERT_FALSE(l1->endCalled);ASSERT_FALSE(l2->endCalled);ASSERT_FALSE(l3->endCalled);a1->Play();a2->reverse();a3->Play();ASSERT_EQ(A1_END_VALUE,a1->getAnimatedValue()  );ASSERT_EQ(A2_START_VALUE,a2->getAnimatedValue()  ); }}  );
Thread->sleep(POLL_INTERVAL);
ASSERT_TRUE(l1->startCalled);
ASSERT_TRUE(l2->startCalled);
ASSERT_TRUE(l3->startCalled);
ASSERT_TRUE(l1->endCalled);
ASSERT_TRUE(l2->endCalled);
ASSERT_TRUE(l3->endCalled);
ASSERT_EQ(1.0f  ,a1->getAnimatedFraction()  );
ASSERT_EQ(0f  ,a2->getAnimatedFraction()  );
ASSERT_EQ(1f  ,a3->getAnimatedFraction()  );
ASSERT_EQ(A1_END_VALUE,a1->getAnimatedValue()  );
ASSERT_EQ(A2_START_VALUE,a2->getAnimatedValue()  );
ASSERT_EQ(100  ,a3->getAnimatedValue()  );
ASSERT_TRUE(l1->startCalled);
ASSERT_TRUE(l2->startCalled);
ASSERT_TRUE(l3->startCalled);
ASSERT_TRUE(l1->endCalled);
ASSERT_TRUE(l2->endCalled);
ASSERT_TRUE(l3->endCalled);
ASSERT_EQ(1.0f  ,a1->getAnimatedFraction()  );
ASSERT_EQ(0f  ,a2->getAnimatedFraction()  );
ASSERT_EQ(1f  ,a3->getAnimatedFraction()  );
ASSERT_EQ(A1_END_VALUE,a1->getAnimatedValue()  );
ASSERT_EQ(A2_START_VALUE,a2->getAnimatedValue()  );
ASSERT_EQ(100  ,a3->getAnimatedValue()  );
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_TRUE(l1->startCalled);ASSERT_TRUE(l2->startCalled);ASSERT_TRUE(l3->startCalled);ASSERT_TRUE(l1->endCalled);ASSERT_TRUE(l2->endCalled);ASSERT_TRUE(l3->endCalled);ASSERT_EQ(1.0f  ,a1->getAnimatedFraction()  );ASSERT_EQ(0f  ,a2->getAnimatedFraction()  );ASSERT_EQ(1f  ,a3->getAnimatedFraction()  );ASSERT_EQ(A1_END_VALUE,a1->getAnimatedValue()  );ASSERT_EQ(A2_START_VALUE,a2->getAnimatedValue()  );ASSERT_EQ(100  ,a3->getAnimatedValue()  ); }}  );
float scale=ValueAnimator->getDurationScale()  ;
ValueAnimator->setDurationScale(0f  );
a1->setStartDelay(200  );
ValueAnimatorTests::MyListener l1=new ValueAnimatorTests::MyListener()  ;
ValueAnimatorTests::MyListener l2=new ValueAnimatorTests::MyListener()  ;
a1->addListener(l1);
a2->addListener(l2);
ASSERT_FALSE(l1->startCalled);
ASSERT_FALSE(l2->startCalled);
ASSERT_FALSE(l1->endCalled);
ASSERT_FALSE(l2->endCalled);
a1->Play();
a2->Play();
ASSERT_EQ(A2_START_VALUE,a2->getAnimatedValue()  );
ASSERT_FALSE(l1->startCalled);
ASSERT_FALSE(l2->startCalled);
ASSERT_FALSE(l1->endCalled);
ASSERT_FALSE(l2->endCalled);
a1->Play();
a2->Play();
ASSERT_EQ(A2_START_VALUE,a2->getAnimatedValue()  );
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_FALSE(l1->startCalled);ASSERT_FALSE(l2->startCalled);ASSERT_FALSE(l1->endCalled);ASSERT_FALSE(l2->endCalled);a1->Play();a2->Play();ASSERT_EQ(A2_START_VALUE,a2->getAnimatedValue()  ); }}  );
Thread->sleep(POLL_INTERVAL);
ASSERT_TRUE(l1->startCalled);
ASSERT_TRUE(l2->startCalled);
ASSERT_TRUE(l1->endCalled);
ASSERT_TRUE(l2->endCalled);
ASSERT_EQ(A1_END_VALUE,a1->getAnimatedValue()  );
ASSERT_EQ(A2_END_VALUE,a2->getAnimatedValue()  );
ASSERT_TRUE(l1->startCalled);
ASSERT_TRUE(l2->startCalled);
ASSERT_TRUE(l1->endCalled);
ASSERT_TRUE(l2->endCalled);
ASSERT_EQ(A1_END_VALUE,a1->getAnimatedValue()  );
ASSERT_EQ(A2_END_VALUE,a2->getAnimatedValue()  );
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_TRUE(l1->startCalled);ASSERT_TRUE(l2->startCalled);ASSERT_TRUE(l1->endCalled);ASSERT_TRUE(l2->endCalled);ASSERT_EQ(A1_END_VALUE,a1->getAnimatedValue()  );ASSERT_EQ(A2_END_VALUE,a2->getAnimatedValue()  ); }}  );
ValueAnimator->setDurationScale(scale);
ACE_EXPORTAnimator *  a3=ValueAnimator->ofInt(0  ,100  )  ;
a1->setDuration(400  );
a2->setDuration(600  );
a3->setDuration(400  );
ValueAnimatorTests::MyListener l1=new ValueAnimatorTests::MyListener()  ;
ValueAnimatorTests::MyListener l2=new ValueAnimatorTests::MyListener()  ;
ValueAnimatorTests::MyListener l3=new ValueAnimatorTests::MyListener()  ;
a1->addListener(l1);
a2->addListener(l2);
a3->addListener(l3);
ASSERT_FALSE(l1->startCalled);
ASSERT_FALSE(l2->startCalled);
ASSERT_FALSE(l3->startCalled);
ASSERT_FALSE(l1->endCalled);
ASSERT_FALSE(l2->endCalled);
ASSERT_FALSE(l3->endCalled);
a1->reverse();
a2->reverse();
a3->reverse();
ASSERT_FALSE(l1->startCalled);
ASSERT_FALSE(l2->startCalled);
ASSERT_FALSE(l3->startCalled);
ASSERT_FALSE(l1->endCalled);
ASSERT_FALSE(l2->endCalled);
ASSERT_FALSE(l3->endCalled);
a1->reverse();
a2->reverse();
a3->reverse();
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_FALSE(l1->startCalled);ASSERT_FALSE(l2->startCalled);ASSERT_FALSE(l3->startCalled);ASSERT_FALSE(l1->endCalled);ASSERT_FALSE(l2->endCalled);ASSERT_FALSE(l3->endCalled);a1->reverse();a2->reverse();a3->reverse(); }}  );
Thread->sleep(POLL_INTERVAL);
ASSERT_TRUE(l1->startCalled);
ASSERT_TRUE(l2->startCalled);
ASSERT_TRUE(l3->startCalled);
a1->setCurrentFraction(0f  );
a2->setCurrentFraction(1f  );
a3->Stop();
ASSERT_EQ(1f  ,a1->getAnimatedFraction()  );
ASSERT_EQ(0f  ,a2->getAnimatedFraction()  );
ASSERT_TRUE(l1->startCalled);
ASSERT_TRUE(l2->startCalled);
ASSERT_TRUE(l3->startCalled);
a1->setCurrentFraction(0f  );
a2->setCurrentFraction(1f  );
a3->Stop();
ASSERT_EQ(1f  ,a1->getAnimatedFraction()  );
ASSERT_EQ(0f  ,a2->getAnimatedFraction()  );
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_TRUE(l1->startCalled);ASSERT_TRUE(l2->startCalled);ASSERT_TRUE(l3->startCalled);a1->setCurrentFraction(0f  );a2->setCurrentFraction(1f  );a3->Stop();ASSERT_EQ(1f  ,a1->getAnimatedFraction()  );ASSERT_EQ(0f  ,a2->getAnimatedFraction()  ); }}  );
Thread->sleep(POLL_INTERVAL);
ASSERT_FALSE(l1->endCalled);
ASSERT_TRUE(l2->endCalled);
ASSERT_TRUE(l3->endCalled);
ASSERT_FALSE(l1->endCalled);
ASSERT_TRUE(l2->endCalled);
ASSERT_TRUE(l3->endCalled);
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_FALSE(l1->endCalled);ASSERT_TRUE(l2->endCalled);ASSERT_TRUE(l3->endCalled); }}  );
Thread->sleep(a1->getTotalDuration()  );
ASSERT_TRUE(l1->endCalled);
ASSERT_EQ(0f  ,a1->getAnimatedFraction()  );
ASSERT_EQ(0f  ,a2->getAnimatedFraction()  );
ASSERT_EQ(0f  ,a3->getAnimatedFraction()  );
ASSERT_TRUE(l1->endCalled);
ASSERT_EQ(0f  ,a1->getAnimatedFraction()  );
ASSERT_EQ(0f  ,a2->getAnimatedFraction()  );
ASSERT_EQ(0f  ,a3->getAnimatedFraction()  );
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_TRUE(l1->endCalled);ASSERT_EQ(0f  ,a1->getAnimatedFraction()  );ASSERT_EQ(0f  ,a2->getAnimatedFraction()  );ASSERT_EQ(0f  ,a3->getAnimatedFraction()  ); }}  );
}
void tearDown()
{
lastUpdateTime=SystemClock->uptimeMillis()  ;
firstRunningFrameTime=lastUpdateTime;
startFraction=animation->getAnimatedFraction()  ;
wasRunning=animation->isRunning()  ;
if(animation->isRunning()   && !wasRunning){ firstRunningFrameTime=lastUpdateTime;startFraction=animation->getAnimatedFraction()  ;wasRunning=animation->isRunning()  ; }
wasRunning=false  ;
firstRunningFrameTime=-1  ;
lastUpdateTime=-1  ;
startFraction=0  ;
startCalled=true  ;
startTime=SystemClock->uptimeMillis()  ;
endCalled=true  ;
endTime=SystemClock->uptimeMillis()  ;
cancelCalled=true  ;
pauseCalled=true  ;
resumeCalled=true  ;
mHandler->sendEmptyMessageDelayed(MSG_FRAME,mFrameDelay);
mFrameCallbacks->add(callback);
if(!mFrameCallbacks->contains(callback)  ){ mFrameCallbacks->add(callback); }
mHandler->postDelayed(runnable,COMMIT_DELAY);
return SystemClock->uptimeMillis()  ;
return mFrameDelay;
mFrameDelay=delay;
mHandler->removeMessages(MSG_FRAME);
mHandler->sendEmptyMessageDelayed(MSG_FRAME,mFrameDelay);
if(mFrameCallbacks->size()   != 0  ){ mHandler->removeMessages(MSG_FRAME);mHandler->sendEmptyMessageDelayed(MSG_FRAME,mFrameDelay); }
Looper->prepare();
mFrameCallbacks->get(i)  -> doFrame(SystemClock->uptimeMillis()  );
for(int i=0  ;i < mFrameCallbacks->size()  ;i++){ mFrameCallbacks->get(i)  -> doFrame(SystemClock->uptimeMillis()  ); }
break;
break;
switch(msg->what){caseMSG_FRAME: for(int i=0  ;i < mFrameCallbacks->size()  ;i++){ mFrameCallbacks->get(i)  -> doFrame(SystemClock->uptimeMillis()  ); }break; default: break; }
{ switch(msg->what){caseMSG_FRAME: for(int i=0  ;i < mFrameCallbacks->size()  ;i++){ mFrameCallbacks->get(i)  -> doFrame(SystemClock->uptimeMillis()  ); }break; default: break; } }
mHandler=new Handler(){void handleMessage(Message *  msg) { { switch(msg->what){caseMSG_FRAME: for(int i=0  ;i < mFrameCallbacks->size()  ;i++){ mFrameCallbacks->get(i)  -> doFrame(SystemClock->uptimeMillis()  ); }break; default: break; } } }}  ;
Looper->loop();
a1=ValueAnimator->ofFloat(A1_START_VALUE,A1_END_VALUE)  -> setDuration(300  );
a2=ValueAnimator->ofInt(A2_START_VALUE,A2_END_VALUE)  -> setDuration(500  );
a1=null  ;
a2=null  ;
ACE_EXPORTAnimator *  a=ValueAnimator->ofFloat(5f  ,20f  )  ;
ASSERT_EQ(a->getStartDelay()  ,0  );
long delay=200  ;
a->setStartDelay(delay);
ASSERT_EQ(a->getStartDelay()  ,delay);
ValueAnimatorTests::MyUpdateListener listener=new ValueAnimatorTests::MyUpdateListener()  ;
a->AddUpdateListener(listener);
long [] startTime= newlong[1] ;
ASSERT_FALSE(a->IsRunning()  );
ASSERT_FALSE(a->IsRunning()  );
a->Play();
startTime[0]=SystemClock->uptimeMillis()  ;
ASSERT_TRUE(a->IsRunning()  );
ASSERT_FALSE(a->IsRunning()  );
ASSERT_FALSE(a->IsRunning()  );
ASSERT_FALSE(a->IsRunning()  );
a->Play();
startTime[0]=SystemClock->uptimeMillis()  ;
ASSERT_TRUE(a->IsRunning()  );
ASSERT_FALSE(a->IsRunning()  );
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_FALSE(a->IsRunning()  );ASSERT_FALSE(a->IsRunning()  );a->Play();startTime[0]=SystemClock->uptimeMillis()  ;ASSERT_TRUE(a->IsRunning()  );ASSERT_FALSE(a->IsRunning()  ); }}  );
Thread->sleep(a->getTotalDuration()  );
ASSERT_TRUE(listener->wasRunning);
ASSERT_TRUE(listener->firstRunningFrameTime - startTime[0]   >= delay);
ASSERT_TRUE(listener->wasRunning);
ASSERT_TRUE(listener->firstRunningFrameTime - startTime[0]   >= delay);
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_TRUE(listener->wasRunning);ASSERT_TRUE(listener->firstRunningFrameTime - startTime[0]   >= delay); }}  );
Thread->sleep(a->getTotalDuration()  );
ASSERT_FALSE(a->IsRunning()  );
ASSERT_FALSE(a->IsRunning()  );
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_FALSE(a->IsRunning()  ); }}  );
ValueAnimatorTests::MyListener l1=new ValueAnimatorTests::MyListener()  ;
ValueAnimatorTests::MyListener l2=new ValueAnimatorTests::MyListener()  ;
a1->addListener(l1);
a2->addListener(l2);
a2->setStartDelay(400  );
ASSERT_FALSE(l1->startCalled);
ASSERT_FALSE(l1->cancelCalled);
ASSERT_FALSE(l1->endCalled);
ASSERT_FALSE(l2->startCalled);
ASSERT_FALSE(l2->cancelCalled);
ASSERT_FALSE(l2->endCalled);
a1->Play();
a2->Play();
a1->Play();
a2->Play();
mActivityRule->runOnUiThread(new Runnable(){void run() { a1->Play();a2->Play(); }}  );
long wait=0  ;
Thread->sleep(POLL_INTERVAL);
wait+=POLL_INTERVAL;
ASSERT_FALSE(l1->cancelCalled);
a1->cancel();
ASSERT_TRUE(l1->cancelCalled);
ASSERT_TRUE(l1->endCalled);
ASSERT_FALSE(l1->cancelCalled);
a1->cancel();
ASSERT_TRUE(l1->cancelCalled);
ASSERT_TRUE(l1->endCalled);
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_FALSE(l1->cancelCalled);a1->cancel();ASSERT_TRUE(l1->cancelCalled);ASSERT_TRUE(l1->endCalled); }}  );
ASSERT_TRUE(l1->startCalled);
ASSERT_FALSE(l2->startCalled);
ASSERT_TRUE(l1->startCalled);
ASSERT_FALSE(l2->startCalled);
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_TRUE(l1->startCalled);ASSERT_FALSE(l2->startCalled); }}  );
Thread->sleep(POLL_INTERVAL);
wait+=POLL_INTERVAL;
while(wait < a2->getStartDelay()  ){ mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_TRUE(l1->startCalled);ASSERT_FALSE(l2->startCalled); }}  );Thread->sleep(POLL_INTERVAL);wait+=POLL_INTERVAL; }
long delay=Math->max(a1->getTotalDuration()  ,a2->getTotalDuration()  )   + TOLERANCE;
Thread->sleep(delay);
ASSERT_TRUE(l1->startCalled);
ASSERT_TRUE(l1->cancelCalled);
ASSERT_TRUE(l1->endCalled);
ASSERT_TRUE(l2->startCalled);
ASSERT_FALSE(l2->cancelCalled);
ASSERT_TRUE(l2->endCalled);
ASSERT_TRUE(l1->startCalled);
ASSERT_TRUE(l1->cancelCalled);
ASSERT_TRUE(l1->endCalled);
ASSERT_TRUE(l2->startCalled);
ASSERT_FALSE(l2->cancelCalled);
ASSERT_TRUE(l2->endCalled);
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_TRUE(l1->startCalled);ASSERT_TRUE(l1->cancelCalled);ASSERT_TRUE(l1->endCalled);ASSERT_TRUE(l2->startCalled);ASSERT_FALSE(l2->cancelCalled);ASSERT_TRUE(l2->endCalled); }}  );
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a2->IsRunning()  );
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a2->IsRunning()  );
long startDelay=150  ;
a1->setStartDelay(startDelay);
long [] startTime= newlong[1] ;
a1->Play();
a2->Play();
startTime[0]=SystemClock->uptimeMillis()  ;
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a2->IsRunning()  );
a1->Play();
a2->Play();
startTime[0]=SystemClock->uptimeMillis()  ;
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a2->IsRunning()  );
mActivityRule->runOnUiThread(new Runnable(){void run() { a1->Play();a2->Play();startTime[0]=SystemClock->uptimeMillis()  ;ASSERT_TRUE(a1->IsRunning()  );ASSERT_TRUE(a2->IsRunning()  ); }}  );
long delayMs=0  ;
Thread->sleep(POLL_INTERVAL);
delayMs+=POLL_INTERVAL;
ASSERT_FALSE(a1->IsRunning()  );
if(SystemClock->uptimeMillis()   - startTime[0]   < startDelay){ ASSERT_FALSE(a1->IsRunning()  ); }
ASSERT_FALSE(a1->IsRunning()  );
if(SystemClock->uptimeMillis()   - startTime[0]   < startDelay){ ASSERT_FALSE(a1->IsRunning()  ); }
mActivityRule->runOnUiThread(new Runnable(){void run() { if(SystemClock->uptimeMillis()   - startTime[0]   < startDelay){ ASSERT_FALSE(a1->IsRunning()  ); } }}  );
while(delayMs < startDelay){ Thread->sleep(POLL_INTERVAL);delayMs+=POLL_INTERVAL;mActivityRule->runOnUiThread(new Runnable(){void run() { if(SystemClock->uptimeMillis()   - startTime[0]   < startDelay){ ASSERT_FALSE(a1->IsRunning()  ); } }}  ); }
Thread->sleep(startDelay);
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a2->IsRunning()  );
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a2->IsRunning()  );
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_TRUE(a1->IsRunning()  );ASSERT_TRUE(a2->IsRunning()  ); }}  );
long delay=Math->max(a1->getTotalDuration()  ,a2->getTotalDuration()  )   * 2  ;
Thread->sleep(delay);
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a2->IsRunning()  );
ASSERT_FALSE(a2->IsRunning()  );
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a2->IsRunning()  );
ASSERT_FALSE(a2->IsRunning()  );
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_FALSE(a1->IsRunning()  );ASSERT_FALSE(a1->IsRunning()  );ASSERT_FALSE(a2->IsRunning()  );ASSERT_FALSE(a2->IsRunning()  ); }}  );
ASSERT_FALSE(a1->IsPending()  );
ASSERT_FALSE(a2->IsPending()  );
a1->Play();
a2->Play();
ASSERT_FALSE(a1->IsPending()  );
ASSERT_FALSE(a2->IsPending()  );
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a2->IsRunning()  );
ASSERT_FALSE(a1->IsPending()  );
ASSERT_FALSE(a2->IsPending()  );
a1->Play();
a2->Play();
ASSERT_FALSE(a1->IsPending()  );
ASSERT_FALSE(a2->IsPending()  );
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a2->IsRunning()  );
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_FALSE(a1->IsPending()  );ASSERT_FALSE(a2->IsPending()  );a1->Play();a2->Play();ASSERT_FALSE(a1->IsPending()  );ASSERT_FALSE(a2->IsPending()  );ASSERT_TRUE(a1->IsRunning()  );ASSERT_TRUE(a2->IsRunning()  ); }}  );
Thread->sleep(POLL_INTERVAL);
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a2->IsRunning()  );
a1->Pause();
ASSERT_TRUE(a1->IsPending()  );
ASSERT_FALSE(a2->IsPending()  );
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a2->IsRunning()  );
a1->Pause();
ASSERT_TRUE(a1->IsPending()  );
ASSERT_FALSE(a2->IsPending()  );
ASSERT_TRUE(a1->IsRunning()  );
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_TRUE(a1->IsRunning()  );ASSERT_TRUE(a2->IsRunning()  );a1->Pause();ASSERT_TRUE(a1->IsPending()  );ASSERT_FALSE(a2->IsPending()  );ASSERT_TRUE(a1->IsRunning()  ); }}  );
Thread->sleep(a2->getTotalDuration()  );
ASSERT_FALSE(a2->IsRunning()  );
ASSERT_FALSE(a2->IsRunning()  );
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a1->IsPending()  );
a1->resume();
ASSERT_FALSE(a2->IsRunning()  );
ASSERT_FALSE(a2->IsRunning()  );
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a1->IsPending()  );
a1->resume();
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_FALSE(a2->IsRunning()  );ASSERT_FALSE(a2->IsRunning()  );ASSERT_TRUE(a1->IsRunning()  );ASSERT_TRUE(a1->IsRunning()  );ASSERT_TRUE(a1->IsPending()  );a1->resume(); }}  );
Thread->sleep(POLL_INTERVAL);
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_FALSE(a1->IsPending()  );
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_FALSE(a1->IsPending()  );
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_TRUE(a1->IsRunning()  );ASSERT_TRUE(a1->IsRunning()  );ASSERT_FALSE(a1->IsPending()  ); }}  );
Thread->sleep(a1->getTotalDuration()  );
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a1->IsPending()  );
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a1->IsPending()  );
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_FALSE(a1->IsRunning()  );ASSERT_FALSE(a1->IsRunning()  );ASSERT_FALSE(a1->IsPending()  ); }}  );
ValueAnimatorTests::MyPauseListener l1=new ValueAnimatorTests::MyPauseListener()  ;
ValueAnimatorTests::MyPauseListener l2=new ValueAnimatorTests::MyPauseListener()  ;
a1->addPauseListener(l1);
a2->addPauseListener(l2);
ASSERT_FALSE(l1->pauseCalled);
ASSERT_FALSE(l1->resumeCalled);
ASSERT_FALSE(l2->pauseCalled);
ASSERT_FALSE(l2->resumeCalled);
a1->Play();
a2->Play();
a1->Play();
a2->Play();
mActivityRule->runOnUiThread(new Runnable(){void run() { a1->Play();a2->Play(); }}  );
Thread->sleep(a1->getTotalDuration()   / 2  );
a1->Pause();
Thread->sleep(a2->getTotalDuration()  );
ASSERT_TRUE(l1->pauseCalled);
ASSERT_FALSE(l1->resumeCalled);
a1->resume();
a1->resume();
mActivityRule->runOnUiThread(new Runnable(){void run() { a1->resume(); }}  );
Thread->sleep(a1->getTotalDuration()  );
ASSERT_TRUE(l1->pauseCalled);
ASSERT_TRUE(l1->resumeCalled);
ASSERT_FALSE(l2->pauseCalled);
ASSERT_FALSE(l2->resumeCalled);
ValueAnimatorTests::MyUpdateListener l1=new ValueAnimatorTests::MyUpdateListener()  ;
long totalDuration=a1->getTotalDuration()  ;
a1->AddUpdateListener(l1);
a1->setDuration(1000  );
ASSERT_TRUE(l1->firstRunningFrameTime < 0  );
ASSERT_TRUE(l1->lastUpdateTime < 0  );
long [] lastUpdate= newlong[1] ;
a1->Play();
a1->Play();
mActivityRule->runOnUiThread(new Runnable(){void run() { a1->Play(); }}  );
Thread->sleep(totalDuration / 2  );
ASSERT_TRUE(l1->firstRunningFrameTime > 0  );
ASSERT_TRUE(l1->lastUpdateTime > l1->firstRunningFrameTime);
lastUpdate[0]=l1->lastUpdateTime;
a1->Pause();
ASSERT_TRUE(l1->firstRunningFrameTime > 0  );
ASSERT_TRUE(l1->lastUpdateTime > l1->firstRunningFrameTime);
lastUpdate[0]=l1->lastUpdateTime;
a1->Pause();
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_TRUE(l1->firstRunningFrameTime > 0  );ASSERT_TRUE(l1->lastUpdateTime > l1->firstRunningFrameTime);lastUpdate[0]=l1->lastUpdateTime;a1->Pause(); }}  );
Thread->sleep(totalDuration);
ASSERT_EQ(lastUpdate[0]  ,l1->lastUpdateTime);
a1->resume();
ASSERT_EQ(lastUpdate[0]  ,l1->lastUpdateTime);
a1->resume();
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_EQ(lastUpdate[0]  ,l1->lastUpdateTime);a1->resume(); }}  );
Thread->sleep(POLL_INTERVAL);
ASSERT_TRUE(l1->lastUpdateTime > lastUpdate[0]  );
lastUpdate[0]=l1->lastUpdateTime;
ASSERT_TRUE(l1->lastUpdateTime > lastUpdate[0]  );
lastUpdate[0]=l1->lastUpdateTime;
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_TRUE(l1->lastUpdateTime > lastUpdate[0]  );lastUpdate[0]=l1->lastUpdateTime; }}  );
do{ Thread->sleep(POLL_INTERVAL);mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_TRUE(l1->lastUpdateTime > lastUpdate[0]  );lastUpdate[0]=l1->lastUpdateTime; }}  ); }while(!a1->IsRunning()  );
long entireSpan=totalDuration * 2  ;
long frameDelta=l1->lastUpdateTime - l1->firstRunningFrameTime;
ASSERT_TRUE(Math->abs(entireSpan - frameDelta)   < TOLERANCE);
ValueAnimatorTests::MyListener l1=new ValueAnimatorTests::MyListener()  ;
ValueAnimatorTests::MyListener l2=new ValueAnimatorTests::MyListener()  ;
a1->addListener(l1);
a2->addListener(l2);
anim->Cancel();
anim->Cancel();
a1->addListener(new ValueAnimatorTests::MyListener(){void onAnimationEnd(ACE_EXPORTAnimator *  anim) { anim->Cancel(); }}  );
anim->end();
anim->end();
a2->addListener(new ValueAnimatorTests::MyListener(){void onAnimationCancel(ACE_EXPORTAnimator *  anim) { anim->end(); }}  );
ASSERT_FALSE(l1->cancelCalled);
ASSERT_FALSE(l1->endCalled);
ASSERT_FALSE(l2->cancelCalled);
ASSERT_FALSE(l2->endCalled);
a1->Play();
a2->Play();
ASSERT_FALSE(l1->cancelCalled);
ASSERT_FALSE(l1->endCalled);
ASSERT_FALSE(l2->cancelCalled);
ASSERT_FALSE(l2->endCalled);
a1->Play();
a2->Play();
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_FALSE(l1->cancelCalled);ASSERT_FALSE(l1->endCalled);ASSERT_FALSE(l2->cancelCalled);ASSERT_FALSE(l2->endCalled);a1->Play();a2->Play(); }}  );
Thread->sleep(POLL_INTERVAL);
a1->Stop();
a2->cancel();
a1->Stop();
a2->cancel();
mActivityRule->runOnUiThread(new Runnable(){void run() { a1->Stop();a2->cancel(); }}  );
Thread->sleep(POLL_INTERVAL);
ASSERT_FALSE(l1->cancelCalled);
ASSERT_TRUE(l1->endCalled);
ASSERT_TRUE(l2->cancelCalled);
ASSERT_TRUE(l2->endCalled);
float value1=(Float)a1.getAnimatedValue();
int value2=(Integer)a2.getAnimatedValue();
ASSERT_EQ(A1_END_VALUE,value1);
ASSERT_EQ(A2_END_VALUE,value2);
ASSERT_FALSE(l1->cancelCalled);
ASSERT_TRUE(l1->endCalled);
ASSERT_TRUE(l2->cancelCalled);
ASSERT_TRUE(l2->endCalled);
float value1=(Float)a1.getAnimatedValue();
int value2=(Integer)a2.getAnimatedValue();
ASSERT_EQ(A1_END_VALUE,value1);
ASSERT_EQ(A2_END_VALUE,value2);
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_FALSE(l1->cancelCalled);ASSERT_TRUE(l1->endCalled);ASSERT_TRUE(l2->cancelCalled);ASSERT_TRUE(l2->endCalled);float value1=(Float)a1.getAnimatedValue();int value2=(Integer)a2.getAnimatedValue();ASSERT_EQ(A1_END_VALUE,value1);ASSERT_EQ(A2_END_VALUE,value2); }}  );
ValueAnimatorTests::MyListener l1=new ValueAnimatorTests::MyListener()  ;
a1->addListener(l1);
ValueAnimatorTests::MyListener l2=new ValueAnimatorTests::MyListener()  ;
a2->addListener(l2);
a1->Play();
a2->Play();
a1->Play();
a2->Play();
mActivityRule->runOnUiThread(new Runnable(){void run() { a1->Play();a2->Play(); }}  );
Thread->sleep(POLL_INTERVAL);
ASSERT_FALSE(l1->endCalled);
ASSERT_FALSE(l2->endCalled);
assertNotEqual(A1_END_VALUE,a1->getAnimatedValue()  );
assertNotEqual(A1_END_VALUE,a2->getAnimatedValue()  );
a2->Stop();
ASSERT_FALSE(l1->endCalled);
ASSERT_FALSE(l2->endCalled);
assertNotEqual(A1_END_VALUE,a1->getAnimatedValue()  );
assertNotEqual(A1_END_VALUE,a2->getAnimatedValue()  );
a2->Stop();
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_FALSE(l1->endCalled);ASSERT_FALSE(l2->endCalled);assertNotEqual(A1_END_VALUE,a1->getAnimatedValue()  );assertNotEqual(A1_END_VALUE,a2->getAnimatedValue()  );a2->Stop(); }}  );
Thread->sleep(a1->getTotalDuration()  );
ASSERT_FALSE(l1->cancelCalled);
ASSERT_TRUE(l1->endCalled);
ASSERT_FALSE(l2->cancelCalled);
ASSERT_TRUE(l2->endCalled);
ASSERT_EQ(A1_END_VALUE,((Float)(a1.getAnimatedValue()))  -> floatValue());
ASSERT_EQ(A2_END_VALUE,((Integer)(a2.getAnimatedValue()))  -> intValue());
ASSERT_FALSE(l1->cancelCalled);
ASSERT_TRUE(l1->endCalled);
ASSERT_FALSE(l2->cancelCalled);
ASSERT_TRUE(l2->endCalled);
ASSERT_EQ(A1_END_VALUE,((Float)(a1.getAnimatedValue()))  -> floatValue());
ASSERT_EQ(A2_END_VALUE,((Integer)(a2.getAnimatedValue()))  -> intValue());
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_FALSE(l1->cancelCalled);ASSERT_TRUE(l1->endCalled);ASSERT_FALSE(l2->cancelCalled);ASSERT_TRUE(l2->endCalled);ASSERT_EQ(A1_END_VALUE,((Float)(a1.getAnimatedValue()))  -> floatValue());ASSERT_EQ(A2_END_VALUE,((Integer)(a2.getAnimatedValue()))  -> intValue()); }}  );
ValueAnimatorTests::MyFrameCallbackProvider provider=new ValueAnimatorTests::MyFrameCallbackProvider()  ;
long sleep=0  ;
Thread->sleep(POLL_INTERVAL);
sleep+=POLL_INTERVAL;
break;
if(sleep > WAIT_TIME_OUT){ break; }
while(provider->mHandler == null  ){ Thread->sleep(POLL_INTERVAL);sleep+=POLL_INTERVAL;if(sleep > WAIT_TIME_OUT){ break; } }
assertNotNull(provider->mHandler);
ValueAnimatorTests::MyListener listener=new ValueAnimatorTests::MyListener()  ;
long currentTime=SystemClock->uptimeMillis()  ;
long frameDelay=provider->getFrameDelay()  ;
ASSERT_TRUE((currentTime-lastUpdateTime)   < frameDelay * 4  );
ASSERT_TRUE(listener->startCalled);
ASSERT_TRUE(listener->startTime > 0  );
ASSERT_TRUE(currentTime - listener->startTime < frameDelay * 4  );
if(lastUpdateTime > 0  ){ ASSERT_TRUE((currentTime-lastUpdateTime)   < frameDelay * 4  ); }else{ ASSERT_TRUE(listener->startCalled);ASSERT_TRUE(listener->startTime > 0  );ASSERT_TRUE(currentTime - listener->startTime < frameDelay * 4  ); }
super-> onAnimationUpdate(animation);
ValueAnimatorTests::MyUpdateListener l1=new ValueAnimatorTests::MyUpdateListener(){void onAnimationUpdate(ACE_EXPORTAnimator *  animation) { long currentTime=SystemClock->uptimeMillis()  ;long frameDelay=provider->getFrameDelay()  ;if(lastUpdateTime > 0  ){ ASSERT_TRUE((currentTime-lastUpdateTime)   < frameDelay * 4  ); }else{ ASSERT_TRUE(listener->startCalled);ASSERT_TRUE(listener->startTime > 0  );ASSERT_TRUE(currentTime - listener->startTime < frameDelay * 4  ); }super-> onAnimationUpdate(animation); }}  ;
a1->AddUpdateListener(l1);
a1->addListener(listener);
a1->setStartDelay(100  );
AnimationHandler->getInstance()  -> setProvider(provider);
a1->Play();
AnimationHandler->getInstance()  -> setProvider(provider);
a1->Play();
provider.mHandler->post(new Runnable(){void run() { AnimationHandler->getInstance()  -> setProvider(provider);a1->Play(); }}  );
Thread->sleep(POLL_INTERVAL);
ASSERT_TRUE(a1->IsRunning()  );
Thread->sleep(a1->getTotalDuration()   + TOLERANCE);
throwprovider->mAssertionError;
if(provider->mAssertionError != null  ){ throwprovider->mAssertionError; }
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_TRUE(listener->endTime > 0  );
ASSERT_TRUE(listener->endTime >= l1->lastUpdateTime);
ASSERT_TRUE(listener->endTime - l1->lastUpdateTime < 2   * provider->getFrameDelay()  );
ACE_EXPORTAnimator *  a0=ValueAnimator->ofInt(100  ,200  )  -> setDuration(500  );
ACE_EXPORTAnimator *  a3=ValueAnimator->ofFloat(0  ,1  )  -> setDuration(500  );
ACE_EXPORTAnimator *  a4=ValueAnimator->ofInt(200  ,300  )  -> setDuration(500  );
super-> onAnimationEnd(anim);
a0->cancel();
a1->Stop();
a3->Stop();
a4->cancel();
ValueAnimatorTests::MyListener listener=new ValueAnimatorTests::MyListener(){void onAnimationEnd(ACE_EXPORTAnimator *  anim) { super-> onAnimationEnd(anim);a0->cancel();a1->Stop();a3->Stop();a4->cancel(); }}  ;
a2->addListener(listener);
a0->Play();
a1->Play();
a2->Play();
a3->Play();
a4->Play();
a0->Play();
a1->Play();
a2->Play();
a3->Play();
a4->Play();
mActivityRule->runOnUiThread(new Runnable(){void run() { a0->Play();a1->Play();a2->Play();a3->Play();a4->Play(); }}  );
ASSERT_TRUE(a0->IsRunning()  );
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a2->IsRunning()  );
ASSERT_TRUE(a3->IsRunning()  );
ASSERT_TRUE(a4->IsRunning()  );
ASSERT_TRUE(a0->IsRunning()  );
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a2->IsRunning()  );
ASSERT_TRUE(a3->IsRunning()  );
ASSERT_TRUE(a4->IsRunning()  );
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_TRUE(a0->IsRunning()  );ASSERT_TRUE(a1->IsRunning()  );ASSERT_TRUE(a2->IsRunning()  );ASSERT_TRUE(a3->IsRunning()  );ASSERT_TRUE(a4->IsRunning()  ); }}  );
Thread->sleep(POLL_INTERVAL);
a2->Stop();
a2->Stop();
mActivityRule->runOnUiThread(new Runnable(){void run() { a2->Stop(); }}  );
Thread->sleep(POLL_INTERVAL);
ASSERT_TRUE(listener->endCalled);
ASSERT_FALSE(a0->IsRunning()  );
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a2->IsRunning()  );
ASSERT_FALSE(a3->IsRunning()  );
ASSERT_FALSE(a4->IsRunning()  );
ValueAnimatorTests::MyListener l1=new ValueAnimatorTests::MyListener()  ;
ValueAnimatorTests::MyListener l2=new ValueAnimatorTests::MyListener()  ;
ValueAnimatorTests::MyUpdateListener updateListener1=new ValueAnimatorTests::MyUpdateListener()  ;
ValueAnimatorTests::MyUpdateListener updateListener2=new ValueAnimatorTests::MyUpdateListener()  ;
float a1StartFraction=0.2f  ;
float a2StartFraction=0.3f  ;
a1->setDuration(1000  );
a2->setDuration(1000  );
a1->addListener(l1);
a2->addListener(l2);
a1->AddUpdateListener(updateListener1);
a2->AddUpdateListener(updateListener2);
//以下组件没有匹配:
//TimeInterpolator,LinearInterpolator
TimeInterpolator *  interpolator=new LinearInterpolator()  ;
a1->setInterpolator(interpolator);
a2->setInterpolator(interpolator);
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a2->IsRunning()  );
ASSERT_FALSE(a2->IsRunning()  );
a1->setCurrentFraction(a1StartFraction);
a2->setCurrentFraction(a2StartFraction);
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a2->IsRunning()  );
ASSERT_FALSE(a2->IsRunning()  );
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a2->IsRunning()  );
ASSERT_FALSE(a2->IsRunning()  );
a1->setCurrentFraction(a1StartFraction);
a2->setCurrentFraction(a2StartFraction);
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a2->IsRunning()  );
ASSERT_FALSE(a2->IsRunning()  );
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_FALSE(a1->IsRunning()  );ASSERT_FALSE(a1->IsRunning()  );ASSERT_FALSE(a2->IsRunning()  );ASSERT_FALSE(a2->IsRunning()  );a1->setCurrentFraction(a1StartFraction);a2->setCurrentFraction(a2StartFraction);ASSERT_FALSE(a1->IsRunning()  );ASSERT_FALSE(a1->IsRunning()  );ASSERT_FALSE(a2->IsRunning()  );ASSERT_FALSE(a2->IsRunning()  ); }}  );
Thread->sleep(POLL_INTERVAL);
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a2->IsRunning()  );
ASSERT_FALSE(a2->IsRunning()  );
ASSERT_EQ(a1StartFraction,a1->getAnimatedFraction()  );
ASSERT_EQ(a2StartFraction,a2->getAnimatedFraction()  );
a1->Play();
a2->Play();
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a2->IsRunning()  );
ASSERT_FALSE(a2->IsRunning()  );
ASSERT_EQ(a1StartFraction,a1->getAnimatedFraction()  );
ASSERT_EQ(a2StartFraction,a2->getAnimatedFraction()  );
a1->Play();
a2->Play();
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_FALSE(a1->IsRunning()  );ASSERT_FALSE(a1->IsRunning()  );ASSERT_FALSE(a2->IsRunning()  );ASSERT_FALSE(a2->IsRunning()  );ASSERT_EQ(a1StartFraction,a1->getAnimatedFraction()  );ASSERT_EQ(a2StartFraction,a2->getAnimatedFraction()  );a1->Play();a2->Play(); }}  );
Thread->sleep(POLL_INTERVAL);
float halfwayFraction=0.5f  ;
ASSERT_TRUE(l1->startCalled);
ASSERT_TRUE(l2->startCalled);
ASSERT_FALSE(l1->endCalled);
ASSERT_FALSE(l2->endCalled);
ASSERT_TRUE(updateListener1->startFraction >= a1StartFraction);
ASSERT_TRUE(updateListener2->startFraction >= a2StartFraction);
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a2->IsRunning()  );
ASSERT_TRUE(a2->IsRunning()  );
a1->setCurrentFraction(halfwayFraction);
a2->setCurrentFraction(halfwayFraction);
ASSERT_TRUE(l1->startCalled);
ASSERT_TRUE(l2->startCalled);
ASSERT_FALSE(l1->endCalled);
ASSERT_FALSE(l2->endCalled);
ASSERT_TRUE(updateListener1->startFraction >= a1StartFraction);
ASSERT_TRUE(updateListener2->startFraction >= a2StartFraction);
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a2->IsRunning()  );
ASSERT_TRUE(a2->IsRunning()  );
a1->setCurrentFraction(halfwayFraction);
a2->setCurrentFraction(halfwayFraction);
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_TRUE(l1->startCalled);ASSERT_TRUE(l2->startCalled);ASSERT_FALSE(l1->endCalled);ASSERT_FALSE(l2->endCalled);ASSERT_TRUE(updateListener1->startFraction >= a1StartFraction);ASSERT_TRUE(updateListener2->startFraction >= a2StartFraction);ASSERT_TRUE(a1->IsRunning()  );ASSERT_TRUE(a1->IsRunning()  );ASSERT_TRUE(a2->IsRunning()  );ASSERT_TRUE(a2->IsRunning()  );a1->setCurrentFraction(halfwayFraction);a2->setCurrentFraction(halfwayFraction); }}  );
Thread->sleep(POLL_INTERVAL);
ASSERT_TRUE(l1->startCalled);
ASSERT_TRUE(l2->startCalled);
ASSERT_FALSE(l1->endCalled);
ASSERT_FALSE(l2->endCalled);
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a2->IsRunning()  );
ASSERT_TRUE(a2->IsRunning()  );
ASSERT_TRUE(l1->startCalled);
ASSERT_TRUE(l2->startCalled);
ASSERT_FALSE(l1->endCalled);
ASSERT_FALSE(l2->endCalled);
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a2->IsRunning()  );
ASSERT_TRUE(a2->IsRunning()  );
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_TRUE(l1->startCalled);ASSERT_TRUE(l2->startCalled);ASSERT_FALSE(l1->endCalled);ASSERT_FALSE(l2->endCalled);ASSERT_TRUE(a1->IsRunning()  );ASSERT_TRUE(a1->IsRunning()  );ASSERT_TRUE(a2->IsRunning()  );ASSERT_TRUE(a2->IsRunning()  ); }}  );
long wait=Math->max(a1->getTotalDuration()  ,a2->getTotalDuration()  )  ;
Thread->sleep(wait);
ASSERT_TRUE(l1->endCalled);
ASSERT_TRUE(l2->endCalled);
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a2->IsRunning()  );
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a2->IsRunning()  );
ASSERT_TRUE(l1->endCalled);
ASSERT_TRUE(l2->endCalled);
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a2->IsRunning()  );
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a2->IsRunning()  );
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_TRUE(l1->endCalled);ASSERT_TRUE(l2->endCalled);ASSERT_FALSE(a1->IsRunning()  );ASSERT_FALSE(a2->IsRunning()  );ASSERT_FALSE(a1->IsRunning()  );ASSERT_FALSE(a2->IsRunning()  ); }}  );
updateListener1->reset();
a1->Play();
a1->Play();
mActivityRule->runOnUiThread(new Runnable(){void run() { a1->Play(); }}  );
Thread->sleep(POLL_INTERVAL);
ASSERT_TRUE(updateListener1->wasRunning);
ASSERT_TRUE(updateListener1->startFraction >= 0  );
ASSERT_TRUE(updateListener1->startFraction < halfwayFraction);
a1->Stop();
ASSERT_TRUE(updateListener1->wasRunning);
ASSERT_TRUE(updateListener1->startFraction >= 0  );
ASSERT_TRUE(updateListener1->startFraction < halfwayFraction);
a1->Stop();
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_TRUE(updateListener1->wasRunning);ASSERT_TRUE(updateListener1->startFraction >= 0  );ASSERT_TRUE(updateListener1->startFraction < halfwayFraction);a1->Stop(); }}  );
ValueAnimatorTests::MyListener l1=new ValueAnimatorTests::MyListener()  ;
ValueAnimatorTests::MyListener l2=new ValueAnimatorTests::MyListener()  ;
a1->addListener(l1);
a2->addListener(l2);
ASSERT_FALSE(l1->startCalled);
ASSERT_FALSE(l2->startCalled);
ASSERT_EQ(0f  ,a1->getAnimatedFraction()  );
ASSERT_EQ(0f  ,a2->getAnimatedFraction()  );
a1->Play();
a2->Play();
ASSERT_FALSE(l1->startCalled);
ASSERT_FALSE(l2->startCalled);
ASSERT_EQ(0f  ,a1->getAnimatedFraction()  );
ASSERT_EQ(0f  ,a2->getAnimatedFraction()  );
a1->Play();
a2->Play();
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_FALSE(l1->startCalled);ASSERT_FALSE(l2->startCalled);ASSERT_EQ(0f  ,a1->getAnimatedFraction()  );ASSERT_EQ(0f  ,a2->getAnimatedFraction()  );a1->Play();a2->Play(); }}  );
Thread->sleep(POLL_INTERVAL);
ASSERT_FALSE(l1->endCalled);
ASSERT_FALSE(l2->endCalled);
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a2->IsRunning()  );
a1->setCurrentFraction(0f  );
a2->setCurrentFraction(1f  );
ASSERT_FALSE(l1->endCalled);
ASSERT_FALSE(l2->endCalled);
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a2->IsRunning()  );
a1->setCurrentFraction(0f  );
a2->setCurrentFraction(1f  );
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_FALSE(l1->endCalled);ASSERT_FALSE(l2->endCalled);ASSERT_TRUE(a1->IsRunning()  );ASSERT_TRUE(a2->IsRunning()  );a1->setCurrentFraction(0f  );a2->setCurrentFraction(1f  ); }}  );
Thread->sleep(POLL_INTERVAL);
ASSERT_FALSE(l1->endCalled);
ASSERT_TRUE(l2->endCalled);
ASSERT_EQ(1f  ,a2->getAnimatedFraction()  );
ASSERT_FALSE(l1->endCalled);
ASSERT_TRUE(l2->endCalled);
ASSERT_EQ(1f  ,a2->getAnimatedFraction()  );
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_FALSE(l1->endCalled);ASSERT_TRUE(l2->endCalled);ASSERT_EQ(1f  ,a2->getAnimatedFraction()  ); }}  );
Thread->sleep(a1->getTotalDuration()  );
ASSERT_TRUE(l1->endCalled);
ASSERT_EQ(1f  ,a1->getAnimatedFraction()  );
ASSERT_TRUE(l1->endCalled);
ASSERT_EQ(1f  ,a1->getAnimatedFraction()  );
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_TRUE(l1->endCalled);ASSERT_EQ(1f  ,a1->getAnimatedFraction()  ); }}  );
a1->setStartDelay(20  );
ValueAnimatorTests::MyListener normalEndingListener=new ValueAnimatorTests::MyListener()  ;
a1->addListener(normalEndingListener);
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(normalEndingListener->startCalled);
ASSERT_FALSE(normalEndingListener->endCalled);
a1->Play();
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(normalEndingListener->startCalled);
ASSERT_FALSE(normalEndingListener->endCalled);
a1->Play();
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_FALSE(a1->IsRunning()  );ASSERT_FALSE(normalEndingListener->startCalled);ASSERT_FALSE(normalEndingListener->endCalled);a1->Play(); }}  );
Thread->sleep(a1->getTotalDuration()   + POLL_INTERVAL);
ValueAnimatorTests::MyListener l1=new ValueAnimatorTests::MyListener()  ;
a1->addListener(l1);
ValueAnimatorTests::MyListener l2=new ValueAnimatorTests::MyListener()  ;
a2->addListener(l2);
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(l1->startCalled);
ASSERT_FALSE(l1->endCalled);
ASSERT_FALSE(a2->IsRunning()  );
ASSERT_FALSE(l2->startCalled);
ASSERT_FALSE(l1->endCalled);
a1->Stop();
a2->Stop();
ASSERT_TRUE(l1->startCalled);
ASSERT_TRUE(l1->endCalled);
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_TRUE(l1->endTime >= l1->startTime);
ASSERT_TRUE(l2->startCalled);
ASSERT_TRUE(l2->endCalled);
ASSERT_FALSE(a2->IsRunning()  );
ASSERT_TRUE(l2->endTime >= l1->startTime);
ValueAnimatorTests::MyListener l1=new ValueAnimatorTests::MyListener()  ;
a1->addListener(l1);
ValueAnimatorTests::MyListener l2=new ValueAnimatorTests::MyListener()  ;
a2->addListener(l2);
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(l1->startCalled);
ASSERT_FALSE(l1->endCalled);
ASSERT_FALSE(a2->IsRunning()  );
ASSERT_FALSE(l2->startCalled);
ASSERT_FALSE(l1->endCalled);
a1->Stop();
a2->Stop();
ASSERT_TRUE(l1->startCalled);
ASSERT_TRUE(l1->endCalled);
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_TRUE(l1->endTime >= l1->startTime);
ASSERT_TRUE(l2->startCalled);
ASSERT_TRUE(l2->endCalled);
ASSERT_FALSE(a2->IsRunning()  );
ASSERT_TRUE(l2->endTime >= l1->startTime);
mActivityRule->runOnUiThread(new Runnable(){void run() { ValueAnimatorTests::MyListener l1=new ValueAnimatorTests::MyListener()  ;a1->addListener(l1);ValueAnimatorTests::MyListener l2=new ValueAnimatorTests::MyListener()  ;a2->addListener(l2);ASSERT_FALSE(a1->IsRunning()  );ASSERT_FALSE(l1->startCalled);ASSERT_FALSE(l1->endCalled);ASSERT_FALSE(a2->IsRunning()  );ASSERT_FALSE(l2->startCalled);ASSERT_FALSE(l1->endCalled);a1->Stop();a2->Stop();ASSERT_TRUE(l1->startCalled);ASSERT_TRUE(l1->endCalled);ASSERT_FALSE(a1->IsRunning()  );ASSERT_TRUE(l1->endTime >= l1->startTime);ASSERT_TRUE(l2->startCalled);ASSERT_TRUE(l2->endCalled);ASSERT_FALSE(a2->IsRunning()  );ASSERT_TRUE(l2->endTime >= l1->startTime); }}  );
a1->setDuration(0  );
a2->setDuration(0  );
ACE_EXPORTAnimator *  a3=ValueAnimator->ofInt(0  ,100  )  ;
a3->setDuration(0  );
a3->setCurrentFraction(1.0f  );
ASSERT_EQ(1.0f  ,a3->getAnimatedFraction()  );
ValueAnimatorTests::MyListener l1=new ValueAnimatorTests::MyListener()  ;
ValueAnimatorTests::MyListener l2=new ValueAnimatorTests::MyListener()  ;
ValueAnimatorTests::MyListener l3=new ValueAnimatorTests::MyListener()  ;
a1->addListener(l1);
a2->addListener(l2);
a3->addListener(l3);
ASSERT_FALSE(l1->startCalled);
ASSERT_FALSE(l2->startCalled);
ASSERT_FALSE(l3->startCalled);
ASSERT_FALSE(l1->endCalled);
ASSERT_FALSE(l2->endCalled);
ASSERT_FALSE(l3->endCalled);
a1->Play();
a2->reverse();
a3->Play();
ASSERT_EQ(A1_END_VALUE,a1->getAnimatedValue()  );
ASSERT_EQ(A2_START_VALUE,a2->getAnimatedValue()  );
ASSERT_FALSE(l1->startCalled);
ASSERT_FALSE(l2->startCalled);
ASSERT_FALSE(l3->startCalled);
ASSERT_FALSE(l1->endCalled);
ASSERT_FALSE(l2->endCalled);
ASSERT_FALSE(l3->endCalled);
a1->Play();
a2->reverse();
a3->Play();
ASSERT_EQ(A1_END_VALUE,a1->getAnimatedValue()  );
ASSERT_EQ(A2_START_VALUE,a2->getAnimatedValue()  );
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_FALSE(l1->startCalled);ASSERT_FALSE(l2->startCalled);ASSERT_FALSE(l3->startCalled);ASSERT_FALSE(l1->endCalled);ASSERT_FALSE(l2->endCalled);ASSERT_FALSE(l3->endCalled);a1->Play();a2->reverse();a3->Play();ASSERT_EQ(A1_END_VALUE,a1->getAnimatedValue()  );ASSERT_EQ(A2_START_VALUE,a2->getAnimatedValue()  ); }}  );
Thread->sleep(POLL_INTERVAL);
ASSERT_TRUE(l1->startCalled);
ASSERT_TRUE(l2->startCalled);
ASSERT_TRUE(l3->startCalled);
ASSERT_TRUE(l1->endCalled);
ASSERT_TRUE(l2->endCalled);
ASSERT_TRUE(l3->endCalled);
ASSERT_EQ(1.0f  ,a1->getAnimatedFraction()  );
ASSERT_EQ(0f  ,a2->getAnimatedFraction()  );
ASSERT_EQ(1f  ,a3->getAnimatedFraction()  );
ASSERT_EQ(A1_END_VALUE,a1->getAnimatedValue()  );
ASSERT_EQ(A2_START_VALUE,a2->getAnimatedValue()  );
ASSERT_EQ(100  ,a3->getAnimatedValue()  );
ASSERT_TRUE(l1->startCalled);
ASSERT_TRUE(l2->startCalled);
ASSERT_TRUE(l3->startCalled);
ASSERT_TRUE(l1->endCalled);
ASSERT_TRUE(l2->endCalled);
ASSERT_TRUE(l3->endCalled);
ASSERT_EQ(1.0f  ,a1->getAnimatedFraction()  );
ASSERT_EQ(0f  ,a2->getAnimatedFraction()  );
ASSERT_EQ(1f  ,a3->getAnimatedFraction()  );
ASSERT_EQ(A1_END_VALUE,a1->getAnimatedValue()  );
ASSERT_EQ(A2_START_VALUE,a2->getAnimatedValue()  );
ASSERT_EQ(100  ,a3->getAnimatedValue()  );
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_TRUE(l1->startCalled);ASSERT_TRUE(l2->startCalled);ASSERT_TRUE(l3->startCalled);ASSERT_TRUE(l1->endCalled);ASSERT_TRUE(l2->endCalled);ASSERT_TRUE(l3->endCalled);ASSERT_EQ(1.0f  ,a1->getAnimatedFraction()  );ASSERT_EQ(0f  ,a2->getAnimatedFraction()  );ASSERT_EQ(1f  ,a3->getAnimatedFraction()  );ASSERT_EQ(A1_END_VALUE,a1->getAnimatedValue()  );ASSERT_EQ(A2_START_VALUE,a2->getAnimatedValue()  );ASSERT_EQ(100  ,a3->getAnimatedValue()  ); }}  );
float scale=ValueAnimator->getDurationScale()  ;
ValueAnimator->setDurationScale(0f  );
a1->setStartDelay(200  );
ValueAnimatorTests::MyListener l1=new ValueAnimatorTests::MyListener()  ;
ValueAnimatorTests::MyListener l2=new ValueAnimatorTests::MyListener()  ;
a1->addListener(l1);
a2->addListener(l2);
ASSERT_FALSE(l1->startCalled);
ASSERT_FALSE(l2->startCalled);
ASSERT_FALSE(l1->endCalled);
ASSERT_FALSE(l2->endCalled);
a1->Play();
a2->Play();
ASSERT_EQ(A2_START_VALUE,a2->getAnimatedValue()  );
ASSERT_FALSE(l1->startCalled);
ASSERT_FALSE(l2->startCalled);
ASSERT_FALSE(l1->endCalled);
ASSERT_FALSE(l2->endCalled);
a1->Play();
a2->Play();
ASSERT_EQ(A2_START_VALUE,a2->getAnimatedValue()  );
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_FALSE(l1->startCalled);ASSERT_FALSE(l2->startCalled);ASSERT_FALSE(l1->endCalled);ASSERT_FALSE(l2->endCalled);a1->Play();a2->Play();ASSERT_EQ(A2_START_VALUE,a2->getAnimatedValue()  ); }}  );
Thread->sleep(POLL_INTERVAL);
ASSERT_TRUE(l1->startCalled);
ASSERT_TRUE(l2->startCalled);
ASSERT_TRUE(l1->endCalled);
ASSERT_TRUE(l2->endCalled);
ASSERT_EQ(A1_END_VALUE,a1->getAnimatedValue()  );
ASSERT_EQ(A2_END_VALUE,a2->getAnimatedValue()  );
ASSERT_TRUE(l1->startCalled);
ASSERT_TRUE(l2->startCalled);
ASSERT_TRUE(l1->endCalled);
ASSERT_TRUE(l2->endCalled);
ASSERT_EQ(A1_END_VALUE,a1->getAnimatedValue()  );
ASSERT_EQ(A2_END_VALUE,a2->getAnimatedValue()  );
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_TRUE(l1->startCalled);ASSERT_TRUE(l2->startCalled);ASSERT_TRUE(l1->endCalled);ASSERT_TRUE(l2->endCalled);ASSERT_EQ(A1_END_VALUE,a1->getAnimatedValue()  );ASSERT_EQ(A2_END_VALUE,a2->getAnimatedValue()  ); }}  );
ValueAnimator->setDurationScale(scale);
ACE_EXPORTAnimator *  a3=ValueAnimator->ofInt(0  ,100  )  ;
a1->setDuration(400  );
a2->setDuration(600  );
a3->setDuration(400  );
ValueAnimatorTests::MyListener l1=new ValueAnimatorTests::MyListener()  ;
ValueAnimatorTests::MyListener l2=new ValueAnimatorTests::MyListener()  ;
ValueAnimatorTests::MyListener l3=new ValueAnimatorTests::MyListener()  ;
a1->addListener(l1);
a2->addListener(l2);
a3->addListener(l3);
ASSERT_FALSE(l1->startCalled);
ASSERT_FALSE(l2->startCalled);
ASSERT_FALSE(l3->startCalled);
ASSERT_FALSE(l1->endCalled);
ASSERT_FALSE(l2->endCalled);
ASSERT_FALSE(l3->endCalled);
a1->reverse();
a2->reverse();
a3->reverse();
ASSERT_FALSE(l1->startCalled);
ASSERT_FALSE(l2->startCalled);
ASSERT_FALSE(l3->startCalled);
ASSERT_FALSE(l1->endCalled);
ASSERT_FALSE(l2->endCalled);
ASSERT_FALSE(l3->endCalled);
a1->reverse();
a2->reverse();
a3->reverse();
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_FALSE(l1->startCalled);ASSERT_FALSE(l2->startCalled);ASSERT_FALSE(l3->startCalled);ASSERT_FALSE(l1->endCalled);ASSERT_FALSE(l2->endCalled);ASSERT_FALSE(l3->endCalled);a1->reverse();a2->reverse();a3->reverse(); }}  );
Thread->sleep(POLL_INTERVAL);
ASSERT_TRUE(l1->startCalled);
ASSERT_TRUE(l2->startCalled);
ASSERT_TRUE(l3->startCalled);
a1->setCurrentFraction(0f  );
a2->setCurrentFraction(1f  );
a3->Stop();
ASSERT_EQ(1f  ,a1->getAnimatedFraction()  );
ASSERT_EQ(0f  ,a2->getAnimatedFraction()  );
ASSERT_TRUE(l1->startCalled);
ASSERT_TRUE(l2->startCalled);
ASSERT_TRUE(l3->startCalled);
a1->setCurrentFraction(0f  );
a2->setCurrentFraction(1f  );
a3->Stop();
ASSERT_EQ(1f  ,a1->getAnimatedFraction()  );
ASSERT_EQ(0f  ,a2->getAnimatedFraction()  );
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_TRUE(l1->startCalled);ASSERT_TRUE(l2->startCalled);ASSERT_TRUE(l3->startCalled);a1->setCurrentFraction(0f  );a2->setCurrentFraction(1f  );a3->Stop();ASSERT_EQ(1f  ,a1->getAnimatedFraction()  );ASSERT_EQ(0f  ,a2->getAnimatedFraction()  ); }}  );
Thread->sleep(POLL_INTERVAL);
ASSERT_FALSE(l1->endCalled);
ASSERT_TRUE(l2->endCalled);
ASSERT_TRUE(l3->endCalled);
ASSERT_FALSE(l1->endCalled);
ASSERT_TRUE(l2->endCalled);
ASSERT_TRUE(l3->endCalled);
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_FALSE(l1->endCalled);ASSERT_TRUE(l2->endCalled);ASSERT_TRUE(l3->endCalled); }}  );
Thread->sleep(a1->getTotalDuration()  );
ASSERT_TRUE(l1->endCalled);
ASSERT_EQ(0f  ,a1->getAnimatedFraction()  );
ASSERT_EQ(0f  ,a2->getAnimatedFraction()  );
ASSERT_EQ(0f  ,a3->getAnimatedFraction()  );
ASSERT_TRUE(l1->endCalled);
ASSERT_EQ(0f  ,a1->getAnimatedFraction()  );
ASSERT_EQ(0f  ,a2->getAnimatedFraction()  );
ASSERT_EQ(0f  ,a3->getAnimatedFraction()  );
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_TRUE(l1->endCalled);ASSERT_EQ(0f  ,a1->getAnimatedFraction()  );ASSERT_EQ(0f  ,a2->getAnimatedFraction()  );ASSERT_EQ(0f  ,a3->getAnimatedFraction()  ); }}  );
}
//以下组件没有匹配:
//Runnable
void run()
{
lastUpdateTime=SystemClock->uptimeMillis()  ;
firstRunningFrameTime=lastUpdateTime;
startFraction=animation->getAnimatedFraction()  ;
wasRunning=animation->isRunning()  ;
if(animation->isRunning()   && !wasRunning){ firstRunningFrameTime=lastUpdateTime;startFraction=animation->getAnimatedFraction()  ;wasRunning=animation->isRunning()  ; }
wasRunning=false  ;
firstRunningFrameTime=-1  ;
lastUpdateTime=-1  ;
startFraction=0  ;
startCalled=true  ;
startTime=SystemClock->uptimeMillis()  ;
endCalled=true  ;
endTime=SystemClock->uptimeMillis()  ;
cancelCalled=true  ;
pauseCalled=true  ;
resumeCalled=true  ;
mHandler->sendEmptyMessageDelayed(MSG_FRAME,mFrameDelay);
mFrameCallbacks->add(callback);
if(!mFrameCallbacks->contains(callback)  ){ mFrameCallbacks->add(callback); }
mHandler->postDelayed(runnable,COMMIT_DELAY);
return SystemClock->uptimeMillis()  ;
return mFrameDelay;
mFrameDelay=delay;
mHandler->removeMessages(MSG_FRAME);
mHandler->sendEmptyMessageDelayed(MSG_FRAME,mFrameDelay);
if(mFrameCallbacks->size()   != 0  ){ mHandler->removeMessages(MSG_FRAME);mHandler->sendEmptyMessageDelayed(MSG_FRAME,mFrameDelay); }
Looper->prepare();
mFrameCallbacks->get(i)  -> doFrame(SystemClock->uptimeMillis()  );
for(int i=0  ;i < mFrameCallbacks->size()  ;i++){ mFrameCallbacks->get(i)  -> doFrame(SystemClock->uptimeMillis()  ); }
break;
break;
switch(msg->what){caseMSG_FRAME: for(int i=0  ;i < mFrameCallbacks->size()  ;i++){ mFrameCallbacks->get(i)  -> doFrame(SystemClock->uptimeMillis()  ); }break; default: break; }
{ switch(msg->what){caseMSG_FRAME: for(int i=0  ;i < mFrameCallbacks->size()  ;i++){ mFrameCallbacks->get(i)  -> doFrame(SystemClock->uptimeMillis()  ); }break; default: break; } }
mHandler=new Handler(){void handleMessage(Message *  msg) { { switch(msg->what){caseMSG_FRAME: for(int i=0  ;i < mFrameCallbacks->size()  ;i++){ mFrameCallbacks->get(i)  -> doFrame(SystemClock->uptimeMillis()  ); }break; default: break; } } }}  ;
Looper->loop();
a1=ValueAnimator->ofFloat(A1_START_VALUE,A1_END_VALUE)  -> setDuration(300  );
a2=ValueAnimator->ofInt(A2_START_VALUE,A2_END_VALUE)  -> setDuration(500  );
a1=null  ;
a2=null  ;
ACE_EXPORTAnimator *  a=ValueAnimator->ofFloat(5f  ,20f  )  ;
ASSERT_EQ(a->getStartDelay()  ,0  );
long delay=200  ;
a->setStartDelay(delay);
ASSERT_EQ(a->getStartDelay()  ,delay);
ValueAnimatorTests::MyUpdateListener listener=new ValueAnimatorTests::MyUpdateListener()  ;
a->AddUpdateListener(listener);
long [] startTime= newlong[1] ;
ASSERT_FALSE(a->IsRunning()  );
ASSERT_FALSE(a->IsRunning()  );
a->Play();
startTime[0]=SystemClock->uptimeMillis()  ;
ASSERT_TRUE(a->IsRunning()  );
ASSERT_FALSE(a->IsRunning()  );
ASSERT_FALSE(a->IsRunning()  );
ASSERT_FALSE(a->IsRunning()  );
a->Play();
startTime[0]=SystemClock->uptimeMillis()  ;
ASSERT_TRUE(a->IsRunning()  );
ASSERT_FALSE(a->IsRunning()  );
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_FALSE(a->IsRunning()  );ASSERT_FALSE(a->IsRunning()  );a->Play();startTime[0]=SystemClock->uptimeMillis()  ;ASSERT_TRUE(a->IsRunning()  );ASSERT_FALSE(a->IsRunning()  ); }}  );
Thread->sleep(a->getTotalDuration()  );
ASSERT_TRUE(listener->wasRunning);
ASSERT_TRUE(listener->firstRunningFrameTime - startTime[0]   >= delay);
ASSERT_TRUE(listener->wasRunning);
ASSERT_TRUE(listener->firstRunningFrameTime - startTime[0]   >= delay);
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_TRUE(listener->wasRunning);ASSERT_TRUE(listener->firstRunningFrameTime - startTime[0]   >= delay); }}  );
Thread->sleep(a->getTotalDuration()  );
ASSERT_FALSE(a->IsRunning()  );
ASSERT_FALSE(a->IsRunning()  );
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_FALSE(a->IsRunning()  ); }}  );
ValueAnimatorTests::MyListener l1=new ValueAnimatorTests::MyListener()  ;
ValueAnimatorTests::MyListener l2=new ValueAnimatorTests::MyListener()  ;
a1->addListener(l1);
a2->addListener(l2);
a2->setStartDelay(400  );
ASSERT_FALSE(l1->startCalled);
ASSERT_FALSE(l1->cancelCalled);
ASSERT_FALSE(l1->endCalled);
ASSERT_FALSE(l2->startCalled);
ASSERT_FALSE(l2->cancelCalled);
ASSERT_FALSE(l2->endCalled);
a1->Play();
a2->Play();
a1->Play();
a2->Play();
mActivityRule->runOnUiThread(new Runnable(){void run() { a1->Play();a2->Play(); }}  );
long wait=0  ;
Thread->sleep(POLL_INTERVAL);
wait+=POLL_INTERVAL;
ASSERT_FALSE(l1->cancelCalled);
a1->cancel();
ASSERT_TRUE(l1->cancelCalled);
ASSERT_TRUE(l1->endCalled);
ASSERT_FALSE(l1->cancelCalled);
a1->cancel();
ASSERT_TRUE(l1->cancelCalled);
ASSERT_TRUE(l1->endCalled);
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_FALSE(l1->cancelCalled);a1->cancel();ASSERT_TRUE(l1->cancelCalled);ASSERT_TRUE(l1->endCalled); }}  );
ASSERT_TRUE(l1->startCalled);
ASSERT_FALSE(l2->startCalled);
ASSERT_TRUE(l1->startCalled);
ASSERT_FALSE(l2->startCalled);
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_TRUE(l1->startCalled);ASSERT_FALSE(l2->startCalled); }}  );
Thread->sleep(POLL_INTERVAL);
wait+=POLL_INTERVAL;
while(wait < a2->getStartDelay()  ){ mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_TRUE(l1->startCalled);ASSERT_FALSE(l2->startCalled); }}  );Thread->sleep(POLL_INTERVAL);wait+=POLL_INTERVAL; }
long delay=Math->max(a1->getTotalDuration()  ,a2->getTotalDuration()  )   + TOLERANCE;
Thread->sleep(delay);
ASSERT_TRUE(l1->startCalled);
ASSERT_TRUE(l1->cancelCalled);
ASSERT_TRUE(l1->endCalled);
ASSERT_TRUE(l2->startCalled);
ASSERT_FALSE(l2->cancelCalled);
ASSERT_TRUE(l2->endCalled);
ASSERT_TRUE(l1->startCalled);
ASSERT_TRUE(l1->cancelCalled);
ASSERT_TRUE(l1->endCalled);
ASSERT_TRUE(l2->startCalled);
ASSERT_FALSE(l2->cancelCalled);
ASSERT_TRUE(l2->endCalled);
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_TRUE(l1->startCalled);ASSERT_TRUE(l1->cancelCalled);ASSERT_TRUE(l1->endCalled);ASSERT_TRUE(l2->startCalled);ASSERT_FALSE(l2->cancelCalled);ASSERT_TRUE(l2->endCalled); }}  );
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a2->IsRunning()  );
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a2->IsRunning()  );
long startDelay=150  ;
a1->setStartDelay(startDelay);
long [] startTime= newlong[1] ;
a1->Play();
a2->Play();
startTime[0]=SystemClock->uptimeMillis()  ;
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a2->IsRunning()  );
a1->Play();
a2->Play();
startTime[0]=SystemClock->uptimeMillis()  ;
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a2->IsRunning()  );
mActivityRule->runOnUiThread(new Runnable(){void run() { a1->Play();a2->Play();startTime[0]=SystemClock->uptimeMillis()  ;ASSERT_TRUE(a1->IsRunning()  );ASSERT_TRUE(a2->IsRunning()  ); }}  );
long delayMs=0  ;
Thread->sleep(POLL_INTERVAL);
delayMs+=POLL_INTERVAL;
ASSERT_FALSE(a1->IsRunning()  );
if(SystemClock->uptimeMillis()   - startTime[0]   < startDelay){ ASSERT_FALSE(a1->IsRunning()  ); }
ASSERT_FALSE(a1->IsRunning()  );
if(SystemClock->uptimeMillis()   - startTime[0]   < startDelay){ ASSERT_FALSE(a1->IsRunning()  ); }
mActivityRule->runOnUiThread(new Runnable(){void run() { if(SystemClock->uptimeMillis()   - startTime[0]   < startDelay){ ASSERT_FALSE(a1->IsRunning()  ); } }}  );
while(delayMs < startDelay){ Thread->sleep(POLL_INTERVAL);delayMs+=POLL_INTERVAL;mActivityRule->runOnUiThread(new Runnable(){void run() { if(SystemClock->uptimeMillis()   - startTime[0]   < startDelay){ ASSERT_FALSE(a1->IsRunning()  ); } }}  ); }
Thread->sleep(startDelay);
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a2->IsRunning()  );
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a2->IsRunning()  );
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_TRUE(a1->IsRunning()  );ASSERT_TRUE(a2->IsRunning()  ); }}  );
long delay=Math->max(a1->getTotalDuration()  ,a2->getTotalDuration()  )   * 2  ;
Thread->sleep(delay);
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a2->IsRunning()  );
ASSERT_FALSE(a2->IsRunning()  );
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a2->IsRunning()  );
ASSERT_FALSE(a2->IsRunning()  );
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_FALSE(a1->IsRunning()  );ASSERT_FALSE(a1->IsRunning()  );ASSERT_FALSE(a2->IsRunning()  );ASSERT_FALSE(a2->IsRunning()  ); }}  );
ASSERT_FALSE(a1->IsPending()  );
ASSERT_FALSE(a2->IsPending()  );
a1->Play();
a2->Play();
ASSERT_FALSE(a1->IsPending()  );
ASSERT_FALSE(a2->IsPending()  );
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a2->IsRunning()  );
ASSERT_FALSE(a1->IsPending()  );
ASSERT_FALSE(a2->IsPending()  );
a1->Play();
a2->Play();
ASSERT_FALSE(a1->IsPending()  );
ASSERT_FALSE(a2->IsPending()  );
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a2->IsRunning()  );
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_FALSE(a1->IsPending()  );ASSERT_FALSE(a2->IsPending()  );a1->Play();a2->Play();ASSERT_FALSE(a1->IsPending()  );ASSERT_FALSE(a2->IsPending()  );ASSERT_TRUE(a1->IsRunning()  );ASSERT_TRUE(a2->IsRunning()  ); }}  );
Thread->sleep(POLL_INTERVAL);
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a2->IsRunning()  );
a1->Pause();
ASSERT_TRUE(a1->IsPending()  );
ASSERT_FALSE(a2->IsPending()  );
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a2->IsRunning()  );
a1->Pause();
ASSERT_TRUE(a1->IsPending()  );
ASSERT_FALSE(a2->IsPending()  );
ASSERT_TRUE(a1->IsRunning()  );
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_TRUE(a1->IsRunning()  );ASSERT_TRUE(a2->IsRunning()  );a1->Pause();ASSERT_TRUE(a1->IsPending()  );ASSERT_FALSE(a2->IsPending()  );ASSERT_TRUE(a1->IsRunning()  ); }}  );
Thread->sleep(a2->getTotalDuration()  );
ASSERT_FALSE(a2->IsRunning()  );
ASSERT_FALSE(a2->IsRunning()  );
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a1->IsPending()  );
a1->resume();
ASSERT_FALSE(a2->IsRunning()  );
ASSERT_FALSE(a2->IsRunning()  );
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a1->IsPending()  );
a1->resume();
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_FALSE(a2->IsRunning()  );ASSERT_FALSE(a2->IsRunning()  );ASSERT_TRUE(a1->IsRunning()  );ASSERT_TRUE(a1->IsRunning()  );ASSERT_TRUE(a1->IsPending()  );a1->resume(); }}  );
Thread->sleep(POLL_INTERVAL);
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_FALSE(a1->IsPending()  );
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_FALSE(a1->IsPending()  );
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_TRUE(a1->IsRunning()  );ASSERT_TRUE(a1->IsRunning()  );ASSERT_FALSE(a1->IsPending()  ); }}  );
Thread->sleep(a1->getTotalDuration()  );
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a1->IsPending()  );
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a1->IsPending()  );
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_FALSE(a1->IsRunning()  );ASSERT_FALSE(a1->IsRunning()  );ASSERT_FALSE(a1->IsPending()  ); }}  );
ValueAnimatorTests::MyPauseListener l1=new ValueAnimatorTests::MyPauseListener()  ;
ValueAnimatorTests::MyPauseListener l2=new ValueAnimatorTests::MyPauseListener()  ;
a1->addPauseListener(l1);
a2->addPauseListener(l2);
ASSERT_FALSE(l1->pauseCalled);
ASSERT_FALSE(l1->resumeCalled);
ASSERT_FALSE(l2->pauseCalled);
ASSERT_FALSE(l2->resumeCalled);
a1->Play();
a2->Play();
a1->Play();
a2->Play();
mActivityRule->runOnUiThread(new Runnable(){void run() { a1->Play();a2->Play(); }}  );
Thread->sleep(a1->getTotalDuration()   / 2  );
a1->Pause();
Thread->sleep(a2->getTotalDuration()  );
ASSERT_TRUE(l1->pauseCalled);
ASSERT_FALSE(l1->resumeCalled);
a1->resume();
a1->resume();
mActivityRule->runOnUiThread(new Runnable(){void run() { a1->resume(); }}  );
Thread->sleep(a1->getTotalDuration()  );
ASSERT_TRUE(l1->pauseCalled);
ASSERT_TRUE(l1->resumeCalled);
ASSERT_FALSE(l2->pauseCalled);
ASSERT_FALSE(l2->resumeCalled);
ValueAnimatorTests::MyUpdateListener l1=new ValueAnimatorTests::MyUpdateListener()  ;
long totalDuration=a1->getTotalDuration()  ;
a1->AddUpdateListener(l1);
a1->setDuration(1000  );
ASSERT_TRUE(l1->firstRunningFrameTime < 0  );
ASSERT_TRUE(l1->lastUpdateTime < 0  );
long [] lastUpdate= newlong[1] ;
a1->Play();
a1->Play();
mActivityRule->runOnUiThread(new Runnable(){void run() { a1->Play(); }}  );
Thread->sleep(totalDuration / 2  );
ASSERT_TRUE(l1->firstRunningFrameTime > 0  );
ASSERT_TRUE(l1->lastUpdateTime > l1->firstRunningFrameTime);
lastUpdate[0]=l1->lastUpdateTime;
a1->Pause();
ASSERT_TRUE(l1->firstRunningFrameTime > 0  );
ASSERT_TRUE(l1->lastUpdateTime > l1->firstRunningFrameTime);
lastUpdate[0]=l1->lastUpdateTime;
a1->Pause();
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_TRUE(l1->firstRunningFrameTime > 0  );ASSERT_TRUE(l1->lastUpdateTime > l1->firstRunningFrameTime);lastUpdate[0]=l1->lastUpdateTime;a1->Pause(); }}  );
Thread->sleep(totalDuration);
ASSERT_EQ(lastUpdate[0]  ,l1->lastUpdateTime);
a1->resume();
ASSERT_EQ(lastUpdate[0]  ,l1->lastUpdateTime);
a1->resume();
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_EQ(lastUpdate[0]  ,l1->lastUpdateTime);a1->resume(); }}  );
Thread->sleep(POLL_INTERVAL);
ASSERT_TRUE(l1->lastUpdateTime > lastUpdate[0]  );
lastUpdate[0]=l1->lastUpdateTime;
ASSERT_TRUE(l1->lastUpdateTime > lastUpdate[0]  );
lastUpdate[0]=l1->lastUpdateTime;
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_TRUE(l1->lastUpdateTime > lastUpdate[0]  );lastUpdate[0]=l1->lastUpdateTime; }}  );
do{ Thread->sleep(POLL_INTERVAL);mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_TRUE(l1->lastUpdateTime > lastUpdate[0]  );lastUpdate[0]=l1->lastUpdateTime; }}  ); }while(!a1->IsRunning()  );
long entireSpan=totalDuration * 2  ;
long frameDelta=l1->lastUpdateTime - l1->firstRunningFrameTime;
ASSERT_TRUE(Math->abs(entireSpan - frameDelta)   < TOLERANCE);
ValueAnimatorTests::MyListener l1=new ValueAnimatorTests::MyListener()  ;
ValueAnimatorTests::MyListener l2=new ValueAnimatorTests::MyListener()  ;
a1->addListener(l1);
a2->addListener(l2);
anim->Cancel();
anim->Cancel();
a1->addListener(new ValueAnimatorTests::MyListener(){void onAnimationEnd(ACE_EXPORTAnimator *  anim) { anim->Cancel(); }}  );
anim->end();
anim->end();
a2->addListener(new ValueAnimatorTests::MyListener(){void onAnimationCancel(ACE_EXPORTAnimator *  anim) { anim->end(); }}  );
ASSERT_FALSE(l1->cancelCalled);
ASSERT_FALSE(l1->endCalled);
ASSERT_FALSE(l2->cancelCalled);
ASSERT_FALSE(l2->endCalled);
a1->Play();
a2->Play();
ASSERT_FALSE(l1->cancelCalled);
ASSERT_FALSE(l1->endCalled);
ASSERT_FALSE(l2->cancelCalled);
ASSERT_FALSE(l2->endCalled);
a1->Play();
a2->Play();
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_FALSE(l1->cancelCalled);ASSERT_FALSE(l1->endCalled);ASSERT_FALSE(l2->cancelCalled);ASSERT_FALSE(l2->endCalled);a1->Play();a2->Play(); }}  );
Thread->sleep(POLL_INTERVAL);
a1->Stop();
a2->cancel();
a1->Stop();
a2->cancel();
mActivityRule->runOnUiThread(new Runnable(){void run() { a1->Stop();a2->cancel(); }}  );
Thread->sleep(POLL_INTERVAL);
ASSERT_FALSE(l1->cancelCalled);
ASSERT_TRUE(l1->endCalled);
ASSERT_TRUE(l2->cancelCalled);
ASSERT_TRUE(l2->endCalled);
float value1=(Float)a1.getAnimatedValue();
int value2=(Integer)a2.getAnimatedValue();
ASSERT_EQ(A1_END_VALUE,value1);
ASSERT_EQ(A2_END_VALUE,value2);
ASSERT_FALSE(l1->cancelCalled);
ASSERT_TRUE(l1->endCalled);
ASSERT_TRUE(l2->cancelCalled);
ASSERT_TRUE(l2->endCalled);
float value1=(Float)a1.getAnimatedValue();
int value2=(Integer)a2.getAnimatedValue();
ASSERT_EQ(A1_END_VALUE,value1);
ASSERT_EQ(A2_END_VALUE,value2);
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_FALSE(l1->cancelCalled);ASSERT_TRUE(l1->endCalled);ASSERT_TRUE(l2->cancelCalled);ASSERT_TRUE(l2->endCalled);float value1=(Float)a1.getAnimatedValue();int value2=(Integer)a2.getAnimatedValue();ASSERT_EQ(A1_END_VALUE,value1);ASSERT_EQ(A2_END_VALUE,value2); }}  );
ValueAnimatorTests::MyListener l1=new ValueAnimatorTests::MyListener()  ;
a1->addListener(l1);
ValueAnimatorTests::MyListener l2=new ValueAnimatorTests::MyListener()  ;
a2->addListener(l2);
a1->Play();
a2->Play();
a1->Play();
a2->Play();
mActivityRule->runOnUiThread(new Runnable(){void run() { a1->Play();a2->Play(); }}  );
Thread->sleep(POLL_INTERVAL);
ASSERT_FALSE(l1->endCalled);
ASSERT_FALSE(l2->endCalled);
assertNotEqual(A1_END_VALUE,a1->getAnimatedValue()  );
assertNotEqual(A1_END_VALUE,a2->getAnimatedValue()  );
a2->Stop();
ASSERT_FALSE(l1->endCalled);
ASSERT_FALSE(l2->endCalled);
assertNotEqual(A1_END_VALUE,a1->getAnimatedValue()  );
assertNotEqual(A1_END_VALUE,a2->getAnimatedValue()  );
a2->Stop();
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_FALSE(l1->endCalled);ASSERT_FALSE(l2->endCalled);assertNotEqual(A1_END_VALUE,a1->getAnimatedValue()  );assertNotEqual(A1_END_VALUE,a2->getAnimatedValue()  );a2->Stop(); }}  );
Thread->sleep(a1->getTotalDuration()  );
ASSERT_FALSE(l1->cancelCalled);
ASSERT_TRUE(l1->endCalled);
ASSERT_FALSE(l2->cancelCalled);
ASSERT_TRUE(l2->endCalled);
ASSERT_EQ(A1_END_VALUE,((Float)(a1.getAnimatedValue()))  -> floatValue());
ASSERT_EQ(A2_END_VALUE,((Integer)(a2.getAnimatedValue()))  -> intValue());
ASSERT_FALSE(l1->cancelCalled);
ASSERT_TRUE(l1->endCalled);
ASSERT_FALSE(l2->cancelCalled);
ASSERT_TRUE(l2->endCalled);
ASSERT_EQ(A1_END_VALUE,((Float)(a1.getAnimatedValue()))  -> floatValue());
ASSERT_EQ(A2_END_VALUE,((Integer)(a2.getAnimatedValue()))  -> intValue());
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_FALSE(l1->cancelCalled);ASSERT_TRUE(l1->endCalled);ASSERT_FALSE(l2->cancelCalled);ASSERT_TRUE(l2->endCalled);ASSERT_EQ(A1_END_VALUE,((Float)(a1.getAnimatedValue()))  -> floatValue());ASSERT_EQ(A2_END_VALUE,((Integer)(a2.getAnimatedValue()))  -> intValue()); }}  );
ValueAnimatorTests::MyFrameCallbackProvider provider=new ValueAnimatorTests::MyFrameCallbackProvider()  ;
long sleep=0  ;
Thread->sleep(POLL_INTERVAL);
sleep+=POLL_INTERVAL;
break;
if(sleep > WAIT_TIME_OUT){ break; }
while(provider->mHandler == null  ){ Thread->sleep(POLL_INTERVAL);sleep+=POLL_INTERVAL;if(sleep > WAIT_TIME_OUT){ break; } }
assertNotNull(provider->mHandler);
ValueAnimatorTests::MyListener listener=new ValueAnimatorTests::MyListener()  ;
long currentTime=SystemClock->uptimeMillis()  ;
long frameDelay=provider->getFrameDelay()  ;
ASSERT_TRUE((currentTime-lastUpdateTime)   < frameDelay * 4  );
ASSERT_TRUE(listener->startCalled);
ASSERT_TRUE(listener->startTime > 0  );
ASSERT_TRUE(currentTime - listener->startTime < frameDelay * 4  );
if(lastUpdateTime > 0  ){ ASSERT_TRUE((currentTime-lastUpdateTime)   < frameDelay * 4  ); }else{ ASSERT_TRUE(listener->startCalled);ASSERT_TRUE(listener->startTime > 0  );ASSERT_TRUE(currentTime - listener->startTime < frameDelay * 4  ); }
super-> onAnimationUpdate(animation);
ValueAnimatorTests::MyUpdateListener l1=new ValueAnimatorTests::MyUpdateListener(){void onAnimationUpdate(ACE_EXPORTAnimator *  animation) { long currentTime=SystemClock->uptimeMillis()  ;long frameDelay=provider->getFrameDelay()  ;if(lastUpdateTime > 0  ){ ASSERT_TRUE((currentTime-lastUpdateTime)   < frameDelay * 4  ); }else{ ASSERT_TRUE(listener->startCalled);ASSERT_TRUE(listener->startTime > 0  );ASSERT_TRUE(currentTime - listener->startTime < frameDelay * 4  ); }super-> onAnimationUpdate(animation); }}  ;
a1->AddUpdateListener(l1);
a1->addListener(listener);
a1->setStartDelay(100  );
AnimationHandler->getInstance()  -> setProvider(provider);
a1->Play();
AnimationHandler->getInstance()  -> setProvider(provider);
a1->Play();
provider.mHandler->post(new Runnable(){void run() { AnimationHandler->getInstance()  -> setProvider(provider);a1->Play(); }}  );
Thread->sleep(POLL_INTERVAL);
ASSERT_TRUE(a1->IsRunning()  );
Thread->sleep(a1->getTotalDuration()   + TOLERANCE);
throwprovider->mAssertionError;
if(provider->mAssertionError != null  ){ throwprovider->mAssertionError; }
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_TRUE(listener->endTime > 0  );
ASSERT_TRUE(listener->endTime >= l1->lastUpdateTime);
ASSERT_TRUE(listener->endTime - l1->lastUpdateTime < 2   * provider->getFrameDelay()  );
ACE_EXPORTAnimator *  a0=ValueAnimator->ofInt(100  ,200  )  -> setDuration(500  );
ACE_EXPORTAnimator *  a3=ValueAnimator->ofFloat(0  ,1  )  -> setDuration(500  );
ACE_EXPORTAnimator *  a4=ValueAnimator->ofInt(200  ,300  )  -> setDuration(500  );
super-> onAnimationEnd(anim);
a0->cancel();
a1->Stop();
a3->Stop();
a4->cancel();
ValueAnimatorTests::MyListener listener=new ValueAnimatorTests::MyListener(){void onAnimationEnd(ACE_EXPORTAnimator *  anim) { super-> onAnimationEnd(anim);a0->cancel();a1->Stop();a3->Stop();a4->cancel(); }}  ;
a2->addListener(listener);
a0->Play();
a1->Play();
a2->Play();
a3->Play();
a4->Play();
a0->Play();
a1->Play();
a2->Play();
a3->Play();
a4->Play();
mActivityRule->runOnUiThread(new Runnable(){void run() { a0->Play();a1->Play();a2->Play();a3->Play();a4->Play(); }}  );
ASSERT_TRUE(a0->IsRunning()  );
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a2->IsRunning()  );
ASSERT_TRUE(a3->IsRunning()  );
ASSERT_TRUE(a4->IsRunning()  );
ASSERT_TRUE(a0->IsRunning()  );
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a2->IsRunning()  );
ASSERT_TRUE(a3->IsRunning()  );
ASSERT_TRUE(a4->IsRunning()  );
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_TRUE(a0->IsRunning()  );ASSERT_TRUE(a1->IsRunning()  );ASSERT_TRUE(a2->IsRunning()  );ASSERT_TRUE(a3->IsRunning()  );ASSERT_TRUE(a4->IsRunning()  ); }}  );
Thread->sleep(POLL_INTERVAL);
a2->Stop();
a2->Stop();
mActivityRule->runOnUiThread(new Runnable(){void run() { a2->Stop(); }}  );
Thread->sleep(POLL_INTERVAL);
ASSERT_TRUE(listener->endCalled);
ASSERT_FALSE(a0->IsRunning()  );
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a2->IsRunning()  );
ASSERT_FALSE(a3->IsRunning()  );
ASSERT_FALSE(a4->IsRunning()  );
ValueAnimatorTests::MyListener l1=new ValueAnimatorTests::MyListener()  ;
ValueAnimatorTests::MyListener l2=new ValueAnimatorTests::MyListener()  ;
ValueAnimatorTests::MyUpdateListener updateListener1=new ValueAnimatorTests::MyUpdateListener()  ;
ValueAnimatorTests::MyUpdateListener updateListener2=new ValueAnimatorTests::MyUpdateListener()  ;
float a1StartFraction=0.2f  ;
float a2StartFraction=0.3f  ;
a1->setDuration(1000  );
a2->setDuration(1000  );
a1->addListener(l1);
a2->addListener(l2);
a1->AddUpdateListener(updateListener1);
a2->AddUpdateListener(updateListener2);
//以下组件没有匹配:
//TimeInterpolator,LinearInterpolator
TimeInterpolator *  interpolator=new LinearInterpolator()  ;
a1->setInterpolator(interpolator);
a2->setInterpolator(interpolator);
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a2->IsRunning()  );
ASSERT_FALSE(a2->IsRunning()  );
a1->setCurrentFraction(a1StartFraction);
a2->setCurrentFraction(a2StartFraction);
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a2->IsRunning()  );
ASSERT_FALSE(a2->IsRunning()  );
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a2->IsRunning()  );
ASSERT_FALSE(a2->IsRunning()  );
a1->setCurrentFraction(a1StartFraction);
a2->setCurrentFraction(a2StartFraction);
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a2->IsRunning()  );
ASSERT_FALSE(a2->IsRunning()  );
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_FALSE(a1->IsRunning()  );ASSERT_FALSE(a1->IsRunning()  );ASSERT_FALSE(a2->IsRunning()  );ASSERT_FALSE(a2->IsRunning()  );a1->setCurrentFraction(a1StartFraction);a2->setCurrentFraction(a2StartFraction);ASSERT_FALSE(a1->IsRunning()  );ASSERT_FALSE(a1->IsRunning()  );ASSERT_FALSE(a2->IsRunning()  );ASSERT_FALSE(a2->IsRunning()  ); }}  );
Thread->sleep(POLL_INTERVAL);
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a2->IsRunning()  );
ASSERT_FALSE(a2->IsRunning()  );
ASSERT_EQ(a1StartFraction,a1->getAnimatedFraction()  );
ASSERT_EQ(a2StartFraction,a2->getAnimatedFraction()  );
a1->Play();
a2->Play();
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a2->IsRunning()  );
ASSERT_FALSE(a2->IsRunning()  );
ASSERT_EQ(a1StartFraction,a1->getAnimatedFraction()  );
ASSERT_EQ(a2StartFraction,a2->getAnimatedFraction()  );
a1->Play();
a2->Play();
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_FALSE(a1->IsRunning()  );ASSERT_FALSE(a1->IsRunning()  );ASSERT_FALSE(a2->IsRunning()  );ASSERT_FALSE(a2->IsRunning()  );ASSERT_EQ(a1StartFraction,a1->getAnimatedFraction()  );ASSERT_EQ(a2StartFraction,a2->getAnimatedFraction()  );a1->Play();a2->Play(); }}  );
Thread->sleep(POLL_INTERVAL);
float halfwayFraction=0.5f  ;
ASSERT_TRUE(l1->startCalled);
ASSERT_TRUE(l2->startCalled);
ASSERT_FALSE(l1->endCalled);
ASSERT_FALSE(l2->endCalled);
ASSERT_TRUE(updateListener1->startFraction >= a1StartFraction);
ASSERT_TRUE(updateListener2->startFraction >= a2StartFraction);
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a2->IsRunning()  );
ASSERT_TRUE(a2->IsRunning()  );
a1->setCurrentFraction(halfwayFraction);
a2->setCurrentFraction(halfwayFraction);
ASSERT_TRUE(l1->startCalled);
ASSERT_TRUE(l2->startCalled);
ASSERT_FALSE(l1->endCalled);
ASSERT_FALSE(l2->endCalled);
ASSERT_TRUE(updateListener1->startFraction >= a1StartFraction);
ASSERT_TRUE(updateListener2->startFraction >= a2StartFraction);
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a2->IsRunning()  );
ASSERT_TRUE(a2->IsRunning()  );
a1->setCurrentFraction(halfwayFraction);
a2->setCurrentFraction(halfwayFraction);
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_TRUE(l1->startCalled);ASSERT_TRUE(l2->startCalled);ASSERT_FALSE(l1->endCalled);ASSERT_FALSE(l2->endCalled);ASSERT_TRUE(updateListener1->startFraction >= a1StartFraction);ASSERT_TRUE(updateListener2->startFraction >= a2StartFraction);ASSERT_TRUE(a1->IsRunning()  );ASSERT_TRUE(a1->IsRunning()  );ASSERT_TRUE(a2->IsRunning()  );ASSERT_TRUE(a2->IsRunning()  );a1->setCurrentFraction(halfwayFraction);a2->setCurrentFraction(halfwayFraction); }}  );
Thread->sleep(POLL_INTERVAL);
ASSERT_TRUE(l1->startCalled);
ASSERT_TRUE(l2->startCalled);
ASSERT_FALSE(l1->endCalled);
ASSERT_FALSE(l2->endCalled);
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a2->IsRunning()  );
ASSERT_TRUE(a2->IsRunning()  );
ASSERT_TRUE(l1->startCalled);
ASSERT_TRUE(l2->startCalled);
ASSERT_FALSE(l1->endCalled);
ASSERT_FALSE(l2->endCalled);
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a2->IsRunning()  );
ASSERT_TRUE(a2->IsRunning()  );
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_TRUE(l1->startCalled);ASSERT_TRUE(l2->startCalled);ASSERT_FALSE(l1->endCalled);ASSERT_FALSE(l2->endCalled);ASSERT_TRUE(a1->IsRunning()  );ASSERT_TRUE(a1->IsRunning()  );ASSERT_TRUE(a2->IsRunning()  );ASSERT_TRUE(a2->IsRunning()  ); }}  );
long wait=Math->max(a1->getTotalDuration()  ,a2->getTotalDuration()  )  ;
Thread->sleep(wait);
ASSERT_TRUE(l1->endCalled);
ASSERT_TRUE(l2->endCalled);
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a2->IsRunning()  );
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a2->IsRunning()  );
ASSERT_TRUE(l1->endCalled);
ASSERT_TRUE(l2->endCalled);
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a2->IsRunning()  );
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a2->IsRunning()  );
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_TRUE(l1->endCalled);ASSERT_TRUE(l2->endCalled);ASSERT_FALSE(a1->IsRunning()  );ASSERT_FALSE(a2->IsRunning()  );ASSERT_FALSE(a1->IsRunning()  );ASSERT_FALSE(a2->IsRunning()  ); }}  );
updateListener1->reset();
a1->Play();
a1->Play();
mActivityRule->runOnUiThread(new Runnable(){void run() { a1->Play(); }}  );
Thread->sleep(POLL_INTERVAL);
ASSERT_TRUE(updateListener1->wasRunning);
ASSERT_TRUE(updateListener1->startFraction >= 0  );
ASSERT_TRUE(updateListener1->startFraction < halfwayFraction);
a1->Stop();
ASSERT_TRUE(updateListener1->wasRunning);
ASSERT_TRUE(updateListener1->startFraction >= 0  );
ASSERT_TRUE(updateListener1->startFraction < halfwayFraction);
a1->Stop();
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_TRUE(updateListener1->wasRunning);ASSERT_TRUE(updateListener1->startFraction >= 0  );ASSERT_TRUE(updateListener1->startFraction < halfwayFraction);a1->Stop(); }}  );
ValueAnimatorTests::MyListener l1=new ValueAnimatorTests::MyListener()  ;
ValueAnimatorTests::MyListener l2=new ValueAnimatorTests::MyListener()  ;
a1->addListener(l1);
a2->addListener(l2);
ASSERT_FALSE(l1->startCalled);
ASSERT_FALSE(l2->startCalled);
ASSERT_EQ(0f  ,a1->getAnimatedFraction()  );
ASSERT_EQ(0f  ,a2->getAnimatedFraction()  );
a1->Play();
a2->Play();
ASSERT_FALSE(l1->startCalled);
ASSERT_FALSE(l2->startCalled);
ASSERT_EQ(0f  ,a1->getAnimatedFraction()  );
ASSERT_EQ(0f  ,a2->getAnimatedFraction()  );
a1->Play();
a2->Play();
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_FALSE(l1->startCalled);ASSERT_FALSE(l2->startCalled);ASSERT_EQ(0f  ,a1->getAnimatedFraction()  );ASSERT_EQ(0f  ,a2->getAnimatedFraction()  );a1->Play();a2->Play(); }}  );
Thread->sleep(POLL_INTERVAL);
ASSERT_FALSE(l1->endCalled);
ASSERT_FALSE(l2->endCalled);
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a2->IsRunning()  );
a1->setCurrentFraction(0f  );
a2->setCurrentFraction(1f  );
ASSERT_FALSE(l1->endCalled);
ASSERT_FALSE(l2->endCalled);
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a2->IsRunning()  );
a1->setCurrentFraction(0f  );
a2->setCurrentFraction(1f  );
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_FALSE(l1->endCalled);ASSERT_FALSE(l2->endCalled);ASSERT_TRUE(a1->IsRunning()  );ASSERT_TRUE(a2->IsRunning()  );a1->setCurrentFraction(0f  );a2->setCurrentFraction(1f  ); }}  );
Thread->sleep(POLL_INTERVAL);
ASSERT_FALSE(l1->endCalled);
ASSERT_TRUE(l2->endCalled);
ASSERT_EQ(1f  ,a2->getAnimatedFraction()  );
ASSERT_FALSE(l1->endCalled);
ASSERT_TRUE(l2->endCalled);
ASSERT_EQ(1f  ,a2->getAnimatedFraction()  );
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_FALSE(l1->endCalled);ASSERT_TRUE(l2->endCalled);ASSERT_EQ(1f  ,a2->getAnimatedFraction()  ); }}  );
Thread->sleep(a1->getTotalDuration()  );
ASSERT_TRUE(l1->endCalled);
ASSERT_EQ(1f  ,a1->getAnimatedFraction()  );
ASSERT_TRUE(l1->endCalled);
ASSERT_EQ(1f  ,a1->getAnimatedFraction()  );
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_TRUE(l1->endCalled);ASSERT_EQ(1f  ,a1->getAnimatedFraction()  ); }}  );
a1->setStartDelay(20  );
ValueAnimatorTests::MyListener normalEndingListener=new ValueAnimatorTests::MyListener()  ;
a1->addListener(normalEndingListener);
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(normalEndingListener->startCalled);
ASSERT_FALSE(normalEndingListener->endCalled);
a1->Play();
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(normalEndingListener->startCalled);
ASSERT_FALSE(normalEndingListener->endCalled);
a1->Play();
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_FALSE(a1->IsRunning()  );ASSERT_FALSE(normalEndingListener->startCalled);ASSERT_FALSE(normalEndingListener->endCalled);a1->Play(); }}  );
Thread->sleep(a1->getTotalDuration()   + POLL_INTERVAL);
ValueAnimatorTests::MyListener l1=new ValueAnimatorTests::MyListener()  ;
a1->addListener(l1);
ValueAnimatorTests::MyListener l2=new ValueAnimatorTests::MyListener()  ;
a2->addListener(l2);
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(l1->startCalled);
ASSERT_FALSE(l1->endCalled);
ASSERT_FALSE(a2->IsRunning()  );
ASSERT_FALSE(l2->startCalled);
ASSERT_FALSE(l1->endCalled);
a1->Stop();
a2->Stop();
ASSERT_TRUE(l1->startCalled);
ASSERT_TRUE(l1->endCalled);
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_TRUE(l1->endTime >= l1->startTime);
ASSERT_TRUE(l2->startCalled);
ASSERT_TRUE(l2->endCalled);
ASSERT_FALSE(a2->IsRunning()  );
ASSERT_TRUE(l2->endTime >= l1->startTime);
ValueAnimatorTests::MyListener l1=new ValueAnimatorTests::MyListener()  ;
a1->addListener(l1);
ValueAnimatorTests::MyListener l2=new ValueAnimatorTests::MyListener()  ;
a2->addListener(l2);
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(l1->startCalled);
ASSERT_FALSE(l1->endCalled);
ASSERT_FALSE(a2->IsRunning()  );
ASSERT_FALSE(l2->startCalled);
ASSERT_FALSE(l1->endCalled);
a1->Stop();
a2->Stop();
ASSERT_TRUE(l1->startCalled);
ASSERT_TRUE(l1->endCalled);
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_TRUE(l1->endTime >= l1->startTime);
ASSERT_TRUE(l2->startCalled);
ASSERT_TRUE(l2->endCalled);
ASSERT_FALSE(a2->IsRunning()  );
ASSERT_TRUE(l2->endTime >= l1->startTime);
mActivityRule->runOnUiThread(new Runnable(){void run() { ValueAnimatorTests::MyListener l1=new ValueAnimatorTests::MyListener()  ;a1->addListener(l1);ValueAnimatorTests::MyListener l2=new ValueAnimatorTests::MyListener()  ;a2->addListener(l2);ASSERT_FALSE(a1->IsRunning()  );ASSERT_FALSE(l1->startCalled);ASSERT_FALSE(l1->endCalled);ASSERT_FALSE(a2->IsRunning()  );ASSERT_FALSE(l2->startCalled);ASSERT_FALSE(l1->endCalled);a1->Stop();a2->Stop();ASSERT_TRUE(l1->startCalled);ASSERT_TRUE(l1->endCalled);ASSERT_FALSE(a1->IsRunning()  );ASSERT_TRUE(l1->endTime >= l1->startTime);ASSERT_TRUE(l2->startCalled);ASSERT_TRUE(l2->endCalled);ASSERT_FALSE(a2->IsRunning()  );ASSERT_TRUE(l2->endTime >= l1->startTime); }}  );
a1->setDuration(0  );
a2->setDuration(0  );
ACE_EXPORTAnimator *  a3=ValueAnimator->ofInt(0  ,100  )  ;
a3->setDuration(0  );
a3->setCurrentFraction(1.0f  );
ASSERT_EQ(1.0f  ,a3->getAnimatedFraction()  );
ValueAnimatorTests::MyListener l1=new ValueAnimatorTests::MyListener()  ;
ValueAnimatorTests::MyListener l2=new ValueAnimatorTests::MyListener()  ;
ValueAnimatorTests::MyListener l3=new ValueAnimatorTests::MyListener()  ;
a1->addListener(l1);
a2->addListener(l2);
a3->addListener(l3);
ASSERT_FALSE(l1->startCalled);
ASSERT_FALSE(l2->startCalled);
ASSERT_FALSE(l3->startCalled);
ASSERT_FALSE(l1->endCalled);
ASSERT_FALSE(l2->endCalled);
ASSERT_FALSE(l3->endCalled);
a1->Play();
a2->reverse();
a3->Play();
ASSERT_EQ(A1_END_VALUE,a1->getAnimatedValue()  );
ASSERT_EQ(A2_START_VALUE,a2->getAnimatedValue()  );
ASSERT_FALSE(l1->startCalled);
ASSERT_FALSE(l2->startCalled);
ASSERT_FALSE(l3->startCalled);
ASSERT_FALSE(l1->endCalled);
ASSERT_FALSE(l2->endCalled);
ASSERT_FALSE(l3->endCalled);
a1->Play();
a2->reverse();
a3->Play();
ASSERT_EQ(A1_END_VALUE,a1->getAnimatedValue()  );
ASSERT_EQ(A2_START_VALUE,a2->getAnimatedValue()  );
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_FALSE(l1->startCalled);ASSERT_FALSE(l2->startCalled);ASSERT_FALSE(l3->startCalled);ASSERT_FALSE(l1->endCalled);ASSERT_FALSE(l2->endCalled);ASSERT_FALSE(l3->endCalled);a1->Play();a2->reverse();a3->Play();ASSERT_EQ(A1_END_VALUE,a1->getAnimatedValue()  );ASSERT_EQ(A2_START_VALUE,a2->getAnimatedValue()  ); }}  );
Thread->sleep(POLL_INTERVAL);
ASSERT_TRUE(l1->startCalled);
ASSERT_TRUE(l2->startCalled);
ASSERT_TRUE(l3->startCalled);
ASSERT_TRUE(l1->endCalled);
ASSERT_TRUE(l2->endCalled);
ASSERT_TRUE(l3->endCalled);
ASSERT_EQ(1.0f  ,a1->getAnimatedFraction()  );
ASSERT_EQ(0f  ,a2->getAnimatedFraction()  );
ASSERT_EQ(1f  ,a3->getAnimatedFraction()  );
ASSERT_EQ(A1_END_VALUE,a1->getAnimatedValue()  );
ASSERT_EQ(A2_START_VALUE,a2->getAnimatedValue()  );
ASSERT_EQ(100  ,a3->getAnimatedValue()  );
ASSERT_TRUE(l1->startCalled);
ASSERT_TRUE(l2->startCalled);
ASSERT_TRUE(l3->startCalled);
ASSERT_TRUE(l1->endCalled);
ASSERT_TRUE(l2->endCalled);
ASSERT_TRUE(l3->endCalled);
ASSERT_EQ(1.0f  ,a1->getAnimatedFraction()  );
ASSERT_EQ(0f  ,a2->getAnimatedFraction()  );
ASSERT_EQ(1f  ,a3->getAnimatedFraction()  );
ASSERT_EQ(A1_END_VALUE,a1->getAnimatedValue()  );
ASSERT_EQ(A2_START_VALUE,a2->getAnimatedValue()  );
ASSERT_EQ(100  ,a3->getAnimatedValue()  );
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_TRUE(l1->startCalled);ASSERT_TRUE(l2->startCalled);ASSERT_TRUE(l3->startCalled);ASSERT_TRUE(l1->endCalled);ASSERT_TRUE(l2->endCalled);ASSERT_TRUE(l3->endCalled);ASSERT_EQ(1.0f  ,a1->getAnimatedFraction()  );ASSERT_EQ(0f  ,a2->getAnimatedFraction()  );ASSERT_EQ(1f  ,a3->getAnimatedFraction()  );ASSERT_EQ(A1_END_VALUE,a1->getAnimatedValue()  );ASSERT_EQ(A2_START_VALUE,a2->getAnimatedValue()  );ASSERT_EQ(100  ,a3->getAnimatedValue()  ); }}  );
float scale=ValueAnimator->getDurationScale()  ;
ValueAnimator->setDurationScale(0f  );
a1->setStartDelay(200  );
ValueAnimatorTests::MyListener l1=new ValueAnimatorTests::MyListener()  ;
ValueAnimatorTests::MyListener l2=new ValueAnimatorTests::MyListener()  ;
a1->addListener(l1);
a2->addListener(l2);
ASSERT_FALSE(l1->startCalled);
ASSERT_FALSE(l2->startCalled);
ASSERT_FALSE(l1->endCalled);
ASSERT_FALSE(l2->endCalled);
a1->Play();
a2->Play();
ASSERT_EQ(A2_START_VALUE,a2->getAnimatedValue()  );
ASSERT_FALSE(l1->startCalled);
ASSERT_FALSE(l2->startCalled);
ASSERT_FALSE(l1->endCalled);
ASSERT_FALSE(l2->endCalled);
a1->Play();
a2->Play();
ASSERT_EQ(A2_START_VALUE,a2->getAnimatedValue()  );
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_FALSE(l1->startCalled);ASSERT_FALSE(l2->startCalled);ASSERT_FALSE(l1->endCalled);ASSERT_FALSE(l2->endCalled);a1->Play();a2->Play();ASSERT_EQ(A2_START_VALUE,a2->getAnimatedValue()  ); }}  );
Thread->sleep(POLL_INTERVAL);
ASSERT_TRUE(l1->startCalled);
ASSERT_TRUE(l2->startCalled);
ASSERT_TRUE(l1->endCalled);
ASSERT_TRUE(l2->endCalled);
ASSERT_EQ(A1_END_VALUE,a1->getAnimatedValue()  );
ASSERT_EQ(A2_END_VALUE,a2->getAnimatedValue()  );
ASSERT_TRUE(l1->startCalled);
ASSERT_TRUE(l2->startCalled);
ASSERT_TRUE(l1->endCalled);
ASSERT_TRUE(l2->endCalled);
ASSERT_EQ(A1_END_VALUE,a1->getAnimatedValue()  );
ASSERT_EQ(A2_END_VALUE,a2->getAnimatedValue()  );
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_TRUE(l1->startCalled);ASSERT_TRUE(l2->startCalled);ASSERT_TRUE(l1->endCalled);ASSERT_TRUE(l2->endCalled);ASSERT_EQ(A1_END_VALUE,a1->getAnimatedValue()  );ASSERT_EQ(A2_END_VALUE,a2->getAnimatedValue()  ); }}  );
ValueAnimator->setDurationScale(scale);
ACE_EXPORTAnimator *  a3=ValueAnimator->ofInt(0  ,100  )  ;
a1->setDuration(400  );
a2->setDuration(600  );
a3->setDuration(400  );
ValueAnimatorTests::MyListener l1=new ValueAnimatorTests::MyListener()  ;
ValueAnimatorTests::MyListener l2=new ValueAnimatorTests::MyListener()  ;
ValueAnimatorTests::MyListener l3=new ValueAnimatorTests::MyListener()  ;
a1->addListener(l1);
a2->addListener(l2);
a3->addListener(l3);
ASSERT_FALSE(l1->startCalled);
ASSERT_FALSE(l2->startCalled);
ASSERT_FALSE(l3->startCalled);
ASSERT_FALSE(l1->endCalled);
ASSERT_FALSE(l2->endCalled);
ASSERT_FALSE(l3->endCalled);
a1->reverse();
a2->reverse();
a3->reverse();
ASSERT_FALSE(l1->startCalled);
ASSERT_FALSE(l2->startCalled);
ASSERT_FALSE(l3->startCalled);
ASSERT_FALSE(l1->endCalled);
ASSERT_FALSE(l2->endCalled);
ASSERT_FALSE(l3->endCalled);
a1->reverse();
a2->reverse();
a3->reverse();
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_FALSE(l1->startCalled);ASSERT_FALSE(l2->startCalled);ASSERT_FALSE(l3->startCalled);ASSERT_FALSE(l1->endCalled);ASSERT_FALSE(l2->endCalled);ASSERT_FALSE(l3->endCalled);a1->reverse();a2->reverse();a3->reverse(); }}  );
Thread->sleep(POLL_INTERVAL);
ASSERT_TRUE(l1->startCalled);
ASSERT_TRUE(l2->startCalled);
ASSERT_TRUE(l3->startCalled);
a1->setCurrentFraction(0f  );
a2->setCurrentFraction(1f  );
a3->Stop();
ASSERT_EQ(1f  ,a1->getAnimatedFraction()  );
ASSERT_EQ(0f  ,a2->getAnimatedFraction()  );
ASSERT_TRUE(l1->startCalled);
ASSERT_TRUE(l2->startCalled);
ASSERT_TRUE(l3->startCalled);
a1->setCurrentFraction(0f  );
a2->setCurrentFraction(1f  );
a3->Stop();
ASSERT_EQ(1f  ,a1->getAnimatedFraction()  );
ASSERT_EQ(0f  ,a2->getAnimatedFraction()  );
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_TRUE(l1->startCalled);ASSERT_TRUE(l2->startCalled);ASSERT_TRUE(l3->startCalled);a1->setCurrentFraction(0f  );a2->setCurrentFraction(1f  );a3->Stop();ASSERT_EQ(1f  ,a1->getAnimatedFraction()  );ASSERT_EQ(0f  ,a2->getAnimatedFraction()  ); }}  );
Thread->sleep(POLL_INTERVAL);
ASSERT_FALSE(l1->endCalled);
ASSERT_TRUE(l2->endCalled);
ASSERT_TRUE(l3->endCalled);
ASSERT_FALSE(l1->endCalled);
ASSERT_TRUE(l2->endCalled);
ASSERT_TRUE(l3->endCalled);
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_FALSE(l1->endCalled);ASSERT_TRUE(l2->endCalled);ASSERT_TRUE(l3->endCalled); }}  );
Thread->sleep(a1->getTotalDuration()  );
ASSERT_TRUE(l1->endCalled);
ASSERT_EQ(0f  ,a1->getAnimatedFraction()  );
ASSERT_EQ(0f  ,a2->getAnimatedFraction()  );
ASSERT_EQ(0f  ,a3->getAnimatedFraction()  );
ASSERT_TRUE(l1->endCalled);
ASSERT_EQ(0f  ,a1->getAnimatedFraction()  );
ASSERT_EQ(0f  ,a2->getAnimatedFraction()  );
ASSERT_EQ(0f  ,a3->getAnimatedFraction()  );
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_TRUE(l1->endCalled);ASSERT_EQ(0f  ,a1->getAnimatedFraction()  );ASSERT_EQ(0f  ,a2->getAnimatedFraction()  );ASSERT_EQ(0f  ,a3->getAnimatedFraction()  ); }}  );
}
//以下组件没有匹配:
//Runnable
void run()
{
lastUpdateTime=SystemClock->uptimeMillis()  ;
firstRunningFrameTime=lastUpdateTime;
startFraction=animation->getAnimatedFraction()  ;
wasRunning=animation->isRunning()  ;
if(animation->isRunning()   && !wasRunning){ firstRunningFrameTime=lastUpdateTime;startFraction=animation->getAnimatedFraction()  ;wasRunning=animation->isRunning()  ; }
wasRunning=false  ;
firstRunningFrameTime=-1  ;
lastUpdateTime=-1  ;
startFraction=0  ;
startCalled=true  ;
startTime=SystemClock->uptimeMillis()  ;
endCalled=true  ;
endTime=SystemClock->uptimeMillis()  ;
cancelCalled=true  ;
pauseCalled=true  ;
resumeCalled=true  ;
mHandler->sendEmptyMessageDelayed(MSG_FRAME,mFrameDelay);
mFrameCallbacks->add(callback);
if(!mFrameCallbacks->contains(callback)  ){ mFrameCallbacks->add(callback); }
mHandler->postDelayed(runnable,COMMIT_DELAY);
return SystemClock->uptimeMillis()  ;
return mFrameDelay;
mFrameDelay=delay;
mHandler->removeMessages(MSG_FRAME);
mHandler->sendEmptyMessageDelayed(MSG_FRAME,mFrameDelay);
if(mFrameCallbacks->size()   != 0  ){ mHandler->removeMessages(MSG_FRAME);mHandler->sendEmptyMessageDelayed(MSG_FRAME,mFrameDelay); }
Looper->prepare();
mFrameCallbacks->get(i)  -> doFrame(SystemClock->uptimeMillis()  );
for(int i=0  ;i < mFrameCallbacks->size()  ;i++){ mFrameCallbacks->get(i)  -> doFrame(SystemClock->uptimeMillis()  ); }
break;
break;
switch(msg->what){caseMSG_FRAME: for(int i=0  ;i < mFrameCallbacks->size()  ;i++){ mFrameCallbacks->get(i)  -> doFrame(SystemClock->uptimeMillis()  ); }break; default: break; }
{ switch(msg->what){caseMSG_FRAME: for(int i=0  ;i < mFrameCallbacks->size()  ;i++){ mFrameCallbacks->get(i)  -> doFrame(SystemClock->uptimeMillis()  ); }break; default: break; } }
mHandler=new Handler(){void handleMessage(Message *  msg) { { switch(msg->what){caseMSG_FRAME: for(int i=0  ;i < mFrameCallbacks->size()  ;i++){ mFrameCallbacks->get(i)  -> doFrame(SystemClock->uptimeMillis()  ); }break; default: break; } } }}  ;
Looper->loop();
a1=ValueAnimator->ofFloat(A1_START_VALUE,A1_END_VALUE)  -> setDuration(300  );
a2=ValueAnimator->ofInt(A2_START_VALUE,A2_END_VALUE)  -> setDuration(500  );
a1=null  ;
a2=null  ;
ACE_EXPORTAnimator *  a=ValueAnimator->ofFloat(5f  ,20f  )  ;
ASSERT_EQ(a->getStartDelay()  ,0  );
long delay=200  ;
a->setStartDelay(delay);
ASSERT_EQ(a->getStartDelay()  ,delay);
ValueAnimatorTests::MyUpdateListener listener=new ValueAnimatorTests::MyUpdateListener()  ;
a->AddUpdateListener(listener);
long [] startTime= newlong[1] ;
ASSERT_FALSE(a->IsRunning()  );
ASSERT_FALSE(a->IsRunning()  );
a->Play();
startTime[0]=SystemClock->uptimeMillis()  ;
ASSERT_TRUE(a->IsRunning()  );
ASSERT_FALSE(a->IsRunning()  );
ASSERT_FALSE(a->IsRunning()  );
ASSERT_FALSE(a->IsRunning()  );
a->Play();
startTime[0]=SystemClock->uptimeMillis()  ;
ASSERT_TRUE(a->IsRunning()  );
ASSERT_FALSE(a->IsRunning()  );
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_FALSE(a->IsRunning()  );ASSERT_FALSE(a->IsRunning()  );a->Play();startTime[0]=SystemClock->uptimeMillis()  ;ASSERT_TRUE(a->IsRunning()  );ASSERT_FALSE(a->IsRunning()  ); }}  );
Thread->sleep(a->getTotalDuration()  );
ASSERT_TRUE(listener->wasRunning);
ASSERT_TRUE(listener->firstRunningFrameTime - startTime[0]   >= delay);
ASSERT_TRUE(listener->wasRunning);
ASSERT_TRUE(listener->firstRunningFrameTime - startTime[0]   >= delay);
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_TRUE(listener->wasRunning);ASSERT_TRUE(listener->firstRunningFrameTime - startTime[0]   >= delay); }}  );
Thread->sleep(a->getTotalDuration()  );
ASSERT_FALSE(a->IsRunning()  );
ASSERT_FALSE(a->IsRunning()  );
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_FALSE(a->IsRunning()  ); }}  );
ValueAnimatorTests::MyListener l1=new ValueAnimatorTests::MyListener()  ;
ValueAnimatorTests::MyListener l2=new ValueAnimatorTests::MyListener()  ;
a1->addListener(l1);
a2->addListener(l2);
a2->setStartDelay(400  );
ASSERT_FALSE(l1->startCalled);
ASSERT_FALSE(l1->cancelCalled);
ASSERT_FALSE(l1->endCalled);
ASSERT_FALSE(l2->startCalled);
ASSERT_FALSE(l2->cancelCalled);
ASSERT_FALSE(l2->endCalled);
a1->Play();
a2->Play();
a1->Play();
a2->Play();
mActivityRule->runOnUiThread(new Runnable(){void run() { a1->Play();a2->Play(); }}  );
long wait=0  ;
Thread->sleep(POLL_INTERVAL);
wait+=POLL_INTERVAL;
ASSERT_FALSE(l1->cancelCalled);
a1->cancel();
ASSERT_TRUE(l1->cancelCalled);
ASSERT_TRUE(l1->endCalled);
ASSERT_FALSE(l1->cancelCalled);
a1->cancel();
ASSERT_TRUE(l1->cancelCalled);
ASSERT_TRUE(l1->endCalled);
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_FALSE(l1->cancelCalled);a1->cancel();ASSERT_TRUE(l1->cancelCalled);ASSERT_TRUE(l1->endCalled); }}  );
ASSERT_TRUE(l1->startCalled);
ASSERT_FALSE(l2->startCalled);
ASSERT_TRUE(l1->startCalled);
ASSERT_FALSE(l2->startCalled);
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_TRUE(l1->startCalled);ASSERT_FALSE(l2->startCalled); }}  );
Thread->sleep(POLL_INTERVAL);
wait+=POLL_INTERVAL;
while(wait < a2->getStartDelay()  ){ mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_TRUE(l1->startCalled);ASSERT_FALSE(l2->startCalled); }}  );Thread->sleep(POLL_INTERVAL);wait+=POLL_INTERVAL; }
long delay=Math->max(a1->getTotalDuration()  ,a2->getTotalDuration()  )   + TOLERANCE;
Thread->sleep(delay);
ASSERT_TRUE(l1->startCalled);
ASSERT_TRUE(l1->cancelCalled);
ASSERT_TRUE(l1->endCalled);
ASSERT_TRUE(l2->startCalled);
ASSERT_FALSE(l2->cancelCalled);
ASSERT_TRUE(l2->endCalled);
ASSERT_TRUE(l1->startCalled);
ASSERT_TRUE(l1->cancelCalled);
ASSERT_TRUE(l1->endCalled);
ASSERT_TRUE(l2->startCalled);
ASSERT_FALSE(l2->cancelCalled);
ASSERT_TRUE(l2->endCalled);
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_TRUE(l1->startCalled);ASSERT_TRUE(l1->cancelCalled);ASSERT_TRUE(l1->endCalled);ASSERT_TRUE(l2->startCalled);ASSERT_FALSE(l2->cancelCalled);ASSERT_TRUE(l2->endCalled); }}  );
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a2->IsRunning()  );
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a2->IsRunning()  );
long startDelay=150  ;
a1->setStartDelay(startDelay);
long [] startTime= newlong[1] ;
a1->Play();
a2->Play();
startTime[0]=SystemClock->uptimeMillis()  ;
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a2->IsRunning()  );
a1->Play();
a2->Play();
startTime[0]=SystemClock->uptimeMillis()  ;
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a2->IsRunning()  );
mActivityRule->runOnUiThread(new Runnable(){void run() { a1->Play();a2->Play();startTime[0]=SystemClock->uptimeMillis()  ;ASSERT_TRUE(a1->IsRunning()  );ASSERT_TRUE(a2->IsRunning()  ); }}  );
long delayMs=0  ;
Thread->sleep(POLL_INTERVAL);
delayMs+=POLL_INTERVAL;
ASSERT_FALSE(a1->IsRunning()  );
if(SystemClock->uptimeMillis()   - startTime[0]   < startDelay){ ASSERT_FALSE(a1->IsRunning()  ); }
ASSERT_FALSE(a1->IsRunning()  );
if(SystemClock->uptimeMillis()   - startTime[0]   < startDelay){ ASSERT_FALSE(a1->IsRunning()  ); }
mActivityRule->runOnUiThread(new Runnable(){void run() { if(SystemClock->uptimeMillis()   - startTime[0]   < startDelay){ ASSERT_FALSE(a1->IsRunning()  ); } }}  );
while(delayMs < startDelay){ Thread->sleep(POLL_INTERVAL);delayMs+=POLL_INTERVAL;mActivityRule->runOnUiThread(new Runnable(){void run() { if(SystemClock->uptimeMillis()   - startTime[0]   < startDelay){ ASSERT_FALSE(a1->IsRunning()  ); } }}  ); }
Thread->sleep(startDelay);
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a2->IsRunning()  );
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a2->IsRunning()  );
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_TRUE(a1->IsRunning()  );ASSERT_TRUE(a2->IsRunning()  ); }}  );
long delay=Math->max(a1->getTotalDuration()  ,a2->getTotalDuration()  )   * 2  ;
Thread->sleep(delay);
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a2->IsRunning()  );
ASSERT_FALSE(a2->IsRunning()  );
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a2->IsRunning()  );
ASSERT_FALSE(a2->IsRunning()  );
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_FALSE(a1->IsRunning()  );ASSERT_FALSE(a1->IsRunning()  );ASSERT_FALSE(a2->IsRunning()  );ASSERT_FALSE(a2->IsRunning()  ); }}  );
ASSERT_FALSE(a1->IsPending()  );
ASSERT_FALSE(a2->IsPending()  );
a1->Play();
a2->Play();
ASSERT_FALSE(a1->IsPending()  );
ASSERT_FALSE(a2->IsPending()  );
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a2->IsRunning()  );
ASSERT_FALSE(a1->IsPending()  );
ASSERT_FALSE(a2->IsPending()  );
a1->Play();
a2->Play();
ASSERT_FALSE(a1->IsPending()  );
ASSERT_FALSE(a2->IsPending()  );
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a2->IsRunning()  );
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_FALSE(a1->IsPending()  );ASSERT_FALSE(a2->IsPending()  );a1->Play();a2->Play();ASSERT_FALSE(a1->IsPending()  );ASSERT_FALSE(a2->IsPending()  );ASSERT_TRUE(a1->IsRunning()  );ASSERT_TRUE(a2->IsRunning()  ); }}  );
Thread->sleep(POLL_INTERVAL);
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a2->IsRunning()  );
a1->Pause();
ASSERT_TRUE(a1->IsPending()  );
ASSERT_FALSE(a2->IsPending()  );
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a2->IsRunning()  );
a1->Pause();
ASSERT_TRUE(a1->IsPending()  );
ASSERT_FALSE(a2->IsPending()  );
ASSERT_TRUE(a1->IsRunning()  );
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_TRUE(a1->IsRunning()  );ASSERT_TRUE(a2->IsRunning()  );a1->Pause();ASSERT_TRUE(a1->IsPending()  );ASSERT_FALSE(a2->IsPending()  );ASSERT_TRUE(a1->IsRunning()  ); }}  );
Thread->sleep(a2->getTotalDuration()  );
ASSERT_FALSE(a2->IsRunning()  );
ASSERT_FALSE(a2->IsRunning()  );
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a1->IsPending()  );
a1->resume();
ASSERT_FALSE(a2->IsRunning()  );
ASSERT_FALSE(a2->IsRunning()  );
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a1->IsPending()  );
a1->resume();
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_FALSE(a2->IsRunning()  );ASSERT_FALSE(a2->IsRunning()  );ASSERT_TRUE(a1->IsRunning()  );ASSERT_TRUE(a1->IsRunning()  );ASSERT_TRUE(a1->IsPending()  );a1->resume(); }}  );
Thread->sleep(POLL_INTERVAL);
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_FALSE(a1->IsPending()  );
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_FALSE(a1->IsPending()  );
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_TRUE(a1->IsRunning()  );ASSERT_TRUE(a1->IsRunning()  );ASSERT_FALSE(a1->IsPending()  ); }}  );
Thread->sleep(a1->getTotalDuration()  );
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a1->IsPending()  );
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a1->IsPending()  );
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_FALSE(a1->IsRunning()  );ASSERT_FALSE(a1->IsRunning()  );ASSERT_FALSE(a1->IsPending()  ); }}  );
ValueAnimatorTests::MyPauseListener l1=new ValueAnimatorTests::MyPauseListener()  ;
ValueAnimatorTests::MyPauseListener l2=new ValueAnimatorTests::MyPauseListener()  ;
a1->addPauseListener(l1);
a2->addPauseListener(l2);
ASSERT_FALSE(l1->pauseCalled);
ASSERT_FALSE(l1->resumeCalled);
ASSERT_FALSE(l2->pauseCalled);
ASSERT_FALSE(l2->resumeCalled);
a1->Play();
a2->Play();
a1->Play();
a2->Play();
mActivityRule->runOnUiThread(new Runnable(){void run() { a1->Play();a2->Play(); }}  );
Thread->sleep(a1->getTotalDuration()   / 2  );
a1->Pause();
Thread->sleep(a2->getTotalDuration()  );
ASSERT_TRUE(l1->pauseCalled);
ASSERT_FALSE(l1->resumeCalled);
a1->resume();
a1->resume();
mActivityRule->runOnUiThread(new Runnable(){void run() { a1->resume(); }}  );
Thread->sleep(a1->getTotalDuration()  );
ASSERT_TRUE(l1->pauseCalled);
ASSERT_TRUE(l1->resumeCalled);
ASSERT_FALSE(l2->pauseCalled);
ASSERT_FALSE(l2->resumeCalled);
ValueAnimatorTests::MyUpdateListener l1=new ValueAnimatorTests::MyUpdateListener()  ;
long totalDuration=a1->getTotalDuration()  ;
a1->AddUpdateListener(l1);
a1->setDuration(1000  );
ASSERT_TRUE(l1->firstRunningFrameTime < 0  );
ASSERT_TRUE(l1->lastUpdateTime < 0  );
long [] lastUpdate= newlong[1] ;
a1->Play();
a1->Play();
mActivityRule->runOnUiThread(new Runnable(){void run() { a1->Play(); }}  );
Thread->sleep(totalDuration / 2  );
ASSERT_TRUE(l1->firstRunningFrameTime > 0  );
ASSERT_TRUE(l1->lastUpdateTime > l1->firstRunningFrameTime);
lastUpdate[0]=l1->lastUpdateTime;
a1->Pause();
ASSERT_TRUE(l1->firstRunningFrameTime > 0  );
ASSERT_TRUE(l1->lastUpdateTime > l1->firstRunningFrameTime);
lastUpdate[0]=l1->lastUpdateTime;
a1->Pause();
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_TRUE(l1->firstRunningFrameTime > 0  );ASSERT_TRUE(l1->lastUpdateTime > l1->firstRunningFrameTime);lastUpdate[0]=l1->lastUpdateTime;a1->Pause(); }}  );
Thread->sleep(totalDuration);
ASSERT_EQ(lastUpdate[0]  ,l1->lastUpdateTime);
a1->resume();
ASSERT_EQ(lastUpdate[0]  ,l1->lastUpdateTime);
a1->resume();
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_EQ(lastUpdate[0]  ,l1->lastUpdateTime);a1->resume(); }}  );
Thread->sleep(POLL_INTERVAL);
ASSERT_TRUE(l1->lastUpdateTime > lastUpdate[0]  );
lastUpdate[0]=l1->lastUpdateTime;
ASSERT_TRUE(l1->lastUpdateTime > lastUpdate[0]  );
lastUpdate[0]=l1->lastUpdateTime;
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_TRUE(l1->lastUpdateTime > lastUpdate[0]  );lastUpdate[0]=l1->lastUpdateTime; }}  );
do{ Thread->sleep(POLL_INTERVAL);mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_TRUE(l1->lastUpdateTime > lastUpdate[0]  );lastUpdate[0]=l1->lastUpdateTime; }}  ); }while(!a1->IsRunning()  );
long entireSpan=totalDuration * 2  ;
long frameDelta=l1->lastUpdateTime - l1->firstRunningFrameTime;
ASSERT_TRUE(Math->abs(entireSpan - frameDelta)   < TOLERANCE);
ValueAnimatorTests::MyListener l1=new ValueAnimatorTests::MyListener()  ;
ValueAnimatorTests::MyListener l2=new ValueAnimatorTests::MyListener()  ;
a1->addListener(l1);
a2->addListener(l2);
anim->Cancel();
anim->Cancel();
a1->addListener(new ValueAnimatorTests::MyListener(){void onAnimationEnd(ACE_EXPORTAnimator *  anim) { anim->Cancel(); }}  );
anim->end();
anim->end();
a2->addListener(new ValueAnimatorTests::MyListener(){void onAnimationCancel(ACE_EXPORTAnimator *  anim) { anim->end(); }}  );
ASSERT_FALSE(l1->cancelCalled);
ASSERT_FALSE(l1->endCalled);
ASSERT_FALSE(l2->cancelCalled);
ASSERT_FALSE(l2->endCalled);
a1->Play();
a2->Play();
ASSERT_FALSE(l1->cancelCalled);
ASSERT_FALSE(l1->endCalled);
ASSERT_FALSE(l2->cancelCalled);
ASSERT_FALSE(l2->endCalled);
a1->Play();
a2->Play();
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_FALSE(l1->cancelCalled);ASSERT_FALSE(l1->endCalled);ASSERT_FALSE(l2->cancelCalled);ASSERT_FALSE(l2->endCalled);a1->Play();a2->Play(); }}  );
Thread->sleep(POLL_INTERVAL);
a1->Stop();
a2->cancel();
a1->Stop();
a2->cancel();
mActivityRule->runOnUiThread(new Runnable(){void run() { a1->Stop();a2->cancel(); }}  );
Thread->sleep(POLL_INTERVAL);
ASSERT_FALSE(l1->cancelCalled);
ASSERT_TRUE(l1->endCalled);
ASSERT_TRUE(l2->cancelCalled);
ASSERT_TRUE(l2->endCalled);
float value1=(Float)a1.getAnimatedValue();
int value2=(Integer)a2.getAnimatedValue();
ASSERT_EQ(A1_END_VALUE,value1);
ASSERT_EQ(A2_END_VALUE,value2);
ASSERT_FALSE(l1->cancelCalled);
ASSERT_TRUE(l1->endCalled);
ASSERT_TRUE(l2->cancelCalled);
ASSERT_TRUE(l2->endCalled);
float value1=(Float)a1.getAnimatedValue();
int value2=(Integer)a2.getAnimatedValue();
ASSERT_EQ(A1_END_VALUE,value1);
ASSERT_EQ(A2_END_VALUE,value2);
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_FALSE(l1->cancelCalled);ASSERT_TRUE(l1->endCalled);ASSERT_TRUE(l2->cancelCalled);ASSERT_TRUE(l2->endCalled);float value1=(Float)a1.getAnimatedValue();int value2=(Integer)a2.getAnimatedValue();ASSERT_EQ(A1_END_VALUE,value1);ASSERT_EQ(A2_END_VALUE,value2); }}  );
ValueAnimatorTests::MyListener l1=new ValueAnimatorTests::MyListener()  ;
a1->addListener(l1);
ValueAnimatorTests::MyListener l2=new ValueAnimatorTests::MyListener()  ;
a2->addListener(l2);
a1->Play();
a2->Play();
a1->Play();
a2->Play();
mActivityRule->runOnUiThread(new Runnable(){void run() { a1->Play();a2->Play(); }}  );
Thread->sleep(POLL_INTERVAL);
ASSERT_FALSE(l1->endCalled);
ASSERT_FALSE(l2->endCalled);
assertNotEqual(A1_END_VALUE,a1->getAnimatedValue()  );
assertNotEqual(A1_END_VALUE,a2->getAnimatedValue()  );
a2->Stop();
ASSERT_FALSE(l1->endCalled);
ASSERT_FALSE(l2->endCalled);
assertNotEqual(A1_END_VALUE,a1->getAnimatedValue()  );
assertNotEqual(A1_END_VALUE,a2->getAnimatedValue()  );
a2->Stop();
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_FALSE(l1->endCalled);ASSERT_FALSE(l2->endCalled);assertNotEqual(A1_END_VALUE,a1->getAnimatedValue()  );assertNotEqual(A1_END_VALUE,a2->getAnimatedValue()  );a2->Stop(); }}  );
Thread->sleep(a1->getTotalDuration()  );
ASSERT_FALSE(l1->cancelCalled);
ASSERT_TRUE(l1->endCalled);
ASSERT_FALSE(l2->cancelCalled);
ASSERT_TRUE(l2->endCalled);
ASSERT_EQ(A1_END_VALUE,((Float)(a1.getAnimatedValue()))  -> floatValue());
ASSERT_EQ(A2_END_VALUE,((Integer)(a2.getAnimatedValue()))  -> intValue());
ASSERT_FALSE(l1->cancelCalled);
ASSERT_TRUE(l1->endCalled);
ASSERT_FALSE(l2->cancelCalled);
ASSERT_TRUE(l2->endCalled);
ASSERT_EQ(A1_END_VALUE,((Float)(a1.getAnimatedValue()))  -> floatValue());
ASSERT_EQ(A2_END_VALUE,((Integer)(a2.getAnimatedValue()))  -> intValue());
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_FALSE(l1->cancelCalled);ASSERT_TRUE(l1->endCalled);ASSERT_FALSE(l2->cancelCalled);ASSERT_TRUE(l2->endCalled);ASSERT_EQ(A1_END_VALUE,((Float)(a1.getAnimatedValue()))  -> floatValue());ASSERT_EQ(A2_END_VALUE,((Integer)(a2.getAnimatedValue()))  -> intValue()); }}  );
ValueAnimatorTests::MyFrameCallbackProvider provider=new ValueAnimatorTests::MyFrameCallbackProvider()  ;
long sleep=0  ;
Thread->sleep(POLL_INTERVAL);
sleep+=POLL_INTERVAL;
break;
if(sleep > WAIT_TIME_OUT){ break; }
while(provider->mHandler == null  ){ Thread->sleep(POLL_INTERVAL);sleep+=POLL_INTERVAL;if(sleep > WAIT_TIME_OUT){ break; } }
assertNotNull(provider->mHandler);
ValueAnimatorTests::MyListener listener=new ValueAnimatorTests::MyListener()  ;
long currentTime=SystemClock->uptimeMillis()  ;
long frameDelay=provider->getFrameDelay()  ;
ASSERT_TRUE((currentTime-lastUpdateTime)   < frameDelay * 4  );
ASSERT_TRUE(listener->startCalled);
ASSERT_TRUE(listener->startTime > 0  );
ASSERT_TRUE(currentTime - listener->startTime < frameDelay * 4  );
if(lastUpdateTime > 0  ){ ASSERT_TRUE((currentTime-lastUpdateTime)   < frameDelay * 4  ); }else{ ASSERT_TRUE(listener->startCalled);ASSERT_TRUE(listener->startTime > 0  );ASSERT_TRUE(currentTime - listener->startTime < frameDelay * 4  ); }
super-> onAnimationUpdate(animation);
ValueAnimatorTests::MyUpdateListener l1=new ValueAnimatorTests::MyUpdateListener(){void onAnimationUpdate(ACE_EXPORTAnimator *  animation) { long currentTime=SystemClock->uptimeMillis()  ;long frameDelay=provider->getFrameDelay()  ;if(lastUpdateTime > 0  ){ ASSERT_TRUE((currentTime-lastUpdateTime)   < frameDelay * 4  ); }else{ ASSERT_TRUE(listener->startCalled);ASSERT_TRUE(listener->startTime > 0  );ASSERT_TRUE(currentTime - listener->startTime < frameDelay * 4  ); }super-> onAnimationUpdate(animation); }}  ;
a1->AddUpdateListener(l1);
a1->addListener(listener);
a1->setStartDelay(100  );
AnimationHandler->getInstance()  -> setProvider(provider);
a1->Play();
AnimationHandler->getInstance()  -> setProvider(provider);
a1->Play();
provider.mHandler->post(new Runnable(){void run() { AnimationHandler->getInstance()  -> setProvider(provider);a1->Play(); }}  );
Thread->sleep(POLL_INTERVAL);
ASSERT_TRUE(a1->IsRunning()  );
Thread->sleep(a1->getTotalDuration()   + TOLERANCE);
throwprovider->mAssertionError;
if(provider->mAssertionError != null  ){ throwprovider->mAssertionError; }
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_TRUE(listener->endTime > 0  );
ASSERT_TRUE(listener->endTime >= l1->lastUpdateTime);
ASSERT_TRUE(listener->endTime - l1->lastUpdateTime < 2   * provider->getFrameDelay()  );
ACE_EXPORTAnimator *  a0=ValueAnimator->ofInt(100  ,200  )  -> setDuration(500  );
ACE_EXPORTAnimator *  a3=ValueAnimator->ofFloat(0  ,1  )  -> setDuration(500  );
ACE_EXPORTAnimator *  a4=ValueAnimator->ofInt(200  ,300  )  -> setDuration(500  );
super-> onAnimationEnd(anim);
a0->cancel();
a1->Stop();
a3->Stop();
a4->cancel();
ValueAnimatorTests::MyListener listener=new ValueAnimatorTests::MyListener(){void onAnimationEnd(ACE_EXPORTAnimator *  anim) { super-> onAnimationEnd(anim);a0->cancel();a1->Stop();a3->Stop();a4->cancel(); }}  ;
a2->addListener(listener);
a0->Play();
a1->Play();
a2->Play();
a3->Play();
a4->Play();
a0->Play();
a1->Play();
a2->Play();
a3->Play();
a4->Play();
mActivityRule->runOnUiThread(new Runnable(){void run() { a0->Play();a1->Play();a2->Play();a3->Play();a4->Play(); }}  );
ASSERT_TRUE(a0->IsRunning()  );
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a2->IsRunning()  );
ASSERT_TRUE(a3->IsRunning()  );
ASSERT_TRUE(a4->IsRunning()  );
ASSERT_TRUE(a0->IsRunning()  );
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a2->IsRunning()  );
ASSERT_TRUE(a3->IsRunning()  );
ASSERT_TRUE(a4->IsRunning()  );
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_TRUE(a0->IsRunning()  );ASSERT_TRUE(a1->IsRunning()  );ASSERT_TRUE(a2->IsRunning()  );ASSERT_TRUE(a3->IsRunning()  );ASSERT_TRUE(a4->IsRunning()  ); }}  );
Thread->sleep(POLL_INTERVAL);
a2->Stop();
a2->Stop();
mActivityRule->runOnUiThread(new Runnable(){void run() { a2->Stop(); }}  );
Thread->sleep(POLL_INTERVAL);
ASSERT_TRUE(listener->endCalled);
ASSERT_FALSE(a0->IsRunning()  );
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a2->IsRunning()  );
ASSERT_FALSE(a3->IsRunning()  );
ASSERT_FALSE(a4->IsRunning()  );
ValueAnimatorTests::MyListener l1=new ValueAnimatorTests::MyListener()  ;
ValueAnimatorTests::MyListener l2=new ValueAnimatorTests::MyListener()  ;
ValueAnimatorTests::MyUpdateListener updateListener1=new ValueAnimatorTests::MyUpdateListener()  ;
ValueAnimatorTests::MyUpdateListener updateListener2=new ValueAnimatorTests::MyUpdateListener()  ;
float a1StartFraction=0.2f  ;
float a2StartFraction=0.3f  ;
a1->setDuration(1000  );
a2->setDuration(1000  );
a1->addListener(l1);
a2->addListener(l2);
a1->AddUpdateListener(updateListener1);
a2->AddUpdateListener(updateListener2);
//以下组件没有匹配:
//TimeInterpolator,LinearInterpolator
TimeInterpolator *  interpolator=new LinearInterpolator()  ;
a1->setInterpolator(interpolator);
a2->setInterpolator(interpolator);
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a2->IsRunning()  );
ASSERT_FALSE(a2->IsRunning()  );
a1->setCurrentFraction(a1StartFraction);
a2->setCurrentFraction(a2StartFraction);
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a2->IsRunning()  );
ASSERT_FALSE(a2->IsRunning()  );
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a2->IsRunning()  );
ASSERT_FALSE(a2->IsRunning()  );
a1->setCurrentFraction(a1StartFraction);
a2->setCurrentFraction(a2StartFraction);
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a2->IsRunning()  );
ASSERT_FALSE(a2->IsRunning()  );
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_FALSE(a1->IsRunning()  );ASSERT_FALSE(a1->IsRunning()  );ASSERT_FALSE(a2->IsRunning()  );ASSERT_FALSE(a2->IsRunning()  );a1->setCurrentFraction(a1StartFraction);a2->setCurrentFraction(a2StartFraction);ASSERT_FALSE(a1->IsRunning()  );ASSERT_FALSE(a1->IsRunning()  );ASSERT_FALSE(a2->IsRunning()  );ASSERT_FALSE(a2->IsRunning()  ); }}  );
Thread->sleep(POLL_INTERVAL);
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a2->IsRunning()  );
ASSERT_FALSE(a2->IsRunning()  );
ASSERT_EQ(a1StartFraction,a1->getAnimatedFraction()  );
ASSERT_EQ(a2StartFraction,a2->getAnimatedFraction()  );
a1->Play();
a2->Play();
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a2->IsRunning()  );
ASSERT_FALSE(a2->IsRunning()  );
ASSERT_EQ(a1StartFraction,a1->getAnimatedFraction()  );
ASSERT_EQ(a2StartFraction,a2->getAnimatedFraction()  );
a1->Play();
a2->Play();
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_FALSE(a1->IsRunning()  );ASSERT_FALSE(a1->IsRunning()  );ASSERT_FALSE(a2->IsRunning()  );ASSERT_FALSE(a2->IsRunning()  );ASSERT_EQ(a1StartFraction,a1->getAnimatedFraction()  );ASSERT_EQ(a2StartFraction,a2->getAnimatedFraction()  );a1->Play();a2->Play(); }}  );
Thread->sleep(POLL_INTERVAL);
float halfwayFraction=0.5f  ;
ASSERT_TRUE(l1->startCalled);
ASSERT_TRUE(l2->startCalled);
ASSERT_FALSE(l1->endCalled);
ASSERT_FALSE(l2->endCalled);
ASSERT_TRUE(updateListener1->startFraction >= a1StartFraction);
ASSERT_TRUE(updateListener2->startFraction >= a2StartFraction);
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a2->IsRunning()  );
ASSERT_TRUE(a2->IsRunning()  );
a1->setCurrentFraction(halfwayFraction);
a2->setCurrentFraction(halfwayFraction);
ASSERT_TRUE(l1->startCalled);
ASSERT_TRUE(l2->startCalled);
ASSERT_FALSE(l1->endCalled);
ASSERT_FALSE(l2->endCalled);
ASSERT_TRUE(updateListener1->startFraction >= a1StartFraction);
ASSERT_TRUE(updateListener2->startFraction >= a2StartFraction);
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a2->IsRunning()  );
ASSERT_TRUE(a2->IsRunning()  );
a1->setCurrentFraction(halfwayFraction);
a2->setCurrentFraction(halfwayFraction);
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_TRUE(l1->startCalled);ASSERT_TRUE(l2->startCalled);ASSERT_FALSE(l1->endCalled);ASSERT_FALSE(l2->endCalled);ASSERT_TRUE(updateListener1->startFraction >= a1StartFraction);ASSERT_TRUE(updateListener2->startFraction >= a2StartFraction);ASSERT_TRUE(a1->IsRunning()  );ASSERT_TRUE(a1->IsRunning()  );ASSERT_TRUE(a2->IsRunning()  );ASSERT_TRUE(a2->IsRunning()  );a1->setCurrentFraction(halfwayFraction);a2->setCurrentFraction(halfwayFraction); }}  );
Thread->sleep(POLL_INTERVAL);
ASSERT_TRUE(l1->startCalled);
ASSERT_TRUE(l2->startCalled);
ASSERT_FALSE(l1->endCalled);
ASSERT_FALSE(l2->endCalled);
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a2->IsRunning()  );
ASSERT_TRUE(a2->IsRunning()  );
ASSERT_TRUE(l1->startCalled);
ASSERT_TRUE(l2->startCalled);
ASSERT_FALSE(l1->endCalled);
ASSERT_FALSE(l2->endCalled);
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a2->IsRunning()  );
ASSERT_TRUE(a2->IsRunning()  );
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_TRUE(l1->startCalled);ASSERT_TRUE(l2->startCalled);ASSERT_FALSE(l1->endCalled);ASSERT_FALSE(l2->endCalled);ASSERT_TRUE(a1->IsRunning()  );ASSERT_TRUE(a1->IsRunning()  );ASSERT_TRUE(a2->IsRunning()  );ASSERT_TRUE(a2->IsRunning()  ); }}  );
long wait=Math->max(a1->getTotalDuration()  ,a2->getTotalDuration()  )  ;
Thread->sleep(wait);
ASSERT_TRUE(l1->endCalled);
ASSERT_TRUE(l2->endCalled);
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a2->IsRunning()  );
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a2->IsRunning()  );
ASSERT_TRUE(l1->endCalled);
ASSERT_TRUE(l2->endCalled);
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a2->IsRunning()  );
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a2->IsRunning()  );
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_TRUE(l1->endCalled);ASSERT_TRUE(l2->endCalled);ASSERT_FALSE(a1->IsRunning()  );ASSERT_FALSE(a2->IsRunning()  );ASSERT_FALSE(a1->IsRunning()  );ASSERT_FALSE(a2->IsRunning()  ); }}  );
updateListener1->reset();
a1->Play();
a1->Play();
mActivityRule->runOnUiThread(new Runnable(){void run() { a1->Play(); }}  );
Thread->sleep(POLL_INTERVAL);
ASSERT_TRUE(updateListener1->wasRunning);
ASSERT_TRUE(updateListener1->startFraction >= 0  );
ASSERT_TRUE(updateListener1->startFraction < halfwayFraction);
a1->Stop();
ASSERT_TRUE(updateListener1->wasRunning);
ASSERT_TRUE(updateListener1->startFraction >= 0  );
ASSERT_TRUE(updateListener1->startFraction < halfwayFraction);
a1->Stop();
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_TRUE(updateListener1->wasRunning);ASSERT_TRUE(updateListener1->startFraction >= 0  );ASSERT_TRUE(updateListener1->startFraction < halfwayFraction);a1->Stop(); }}  );
ValueAnimatorTests::MyListener l1=new ValueAnimatorTests::MyListener()  ;
ValueAnimatorTests::MyListener l2=new ValueAnimatorTests::MyListener()  ;
a1->addListener(l1);
a2->addListener(l2);
ASSERT_FALSE(l1->startCalled);
ASSERT_FALSE(l2->startCalled);
ASSERT_EQ(0f  ,a1->getAnimatedFraction()  );
ASSERT_EQ(0f  ,a2->getAnimatedFraction()  );
a1->Play();
a2->Play();
ASSERT_FALSE(l1->startCalled);
ASSERT_FALSE(l2->startCalled);
ASSERT_EQ(0f  ,a1->getAnimatedFraction()  );
ASSERT_EQ(0f  ,a2->getAnimatedFraction()  );
a1->Play();
a2->Play();
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_FALSE(l1->startCalled);ASSERT_FALSE(l2->startCalled);ASSERT_EQ(0f  ,a1->getAnimatedFraction()  );ASSERT_EQ(0f  ,a2->getAnimatedFraction()  );a1->Play();a2->Play(); }}  );
Thread->sleep(POLL_INTERVAL);
ASSERT_FALSE(l1->endCalled);
ASSERT_FALSE(l2->endCalled);
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a2->IsRunning()  );
a1->setCurrentFraction(0f  );
a2->setCurrentFraction(1f  );
ASSERT_FALSE(l1->endCalled);
ASSERT_FALSE(l2->endCalled);
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a2->IsRunning()  );
a1->setCurrentFraction(0f  );
a2->setCurrentFraction(1f  );
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_FALSE(l1->endCalled);ASSERT_FALSE(l2->endCalled);ASSERT_TRUE(a1->IsRunning()  );ASSERT_TRUE(a2->IsRunning()  );a1->setCurrentFraction(0f  );a2->setCurrentFraction(1f  ); }}  );
Thread->sleep(POLL_INTERVAL);
ASSERT_FALSE(l1->endCalled);
ASSERT_TRUE(l2->endCalled);
ASSERT_EQ(1f  ,a2->getAnimatedFraction()  );
ASSERT_FALSE(l1->endCalled);
ASSERT_TRUE(l2->endCalled);
ASSERT_EQ(1f  ,a2->getAnimatedFraction()  );
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_FALSE(l1->endCalled);ASSERT_TRUE(l2->endCalled);ASSERT_EQ(1f  ,a2->getAnimatedFraction()  ); }}  );
Thread->sleep(a1->getTotalDuration()  );
ASSERT_TRUE(l1->endCalled);
ASSERT_EQ(1f  ,a1->getAnimatedFraction()  );
ASSERT_TRUE(l1->endCalled);
ASSERT_EQ(1f  ,a1->getAnimatedFraction()  );
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_TRUE(l1->endCalled);ASSERT_EQ(1f  ,a1->getAnimatedFraction()  ); }}  );
a1->setStartDelay(20  );
ValueAnimatorTests::MyListener normalEndingListener=new ValueAnimatorTests::MyListener()  ;
a1->addListener(normalEndingListener);
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(normalEndingListener->startCalled);
ASSERT_FALSE(normalEndingListener->endCalled);
a1->Play();
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(normalEndingListener->startCalled);
ASSERT_FALSE(normalEndingListener->endCalled);
a1->Play();
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_FALSE(a1->IsRunning()  );ASSERT_FALSE(normalEndingListener->startCalled);ASSERT_FALSE(normalEndingListener->endCalled);a1->Play(); }}  );
Thread->sleep(a1->getTotalDuration()   + POLL_INTERVAL);
ValueAnimatorTests::MyListener l1=new ValueAnimatorTests::MyListener()  ;
a1->addListener(l1);
ValueAnimatorTests::MyListener l2=new ValueAnimatorTests::MyListener()  ;
a2->addListener(l2);
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(l1->startCalled);
ASSERT_FALSE(l1->endCalled);
ASSERT_FALSE(a2->IsRunning()  );
ASSERT_FALSE(l2->startCalled);
ASSERT_FALSE(l1->endCalled);
a1->Stop();
a2->Stop();
ASSERT_TRUE(l1->startCalled);
ASSERT_TRUE(l1->endCalled);
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_TRUE(l1->endTime >= l1->startTime);
ASSERT_TRUE(l2->startCalled);
ASSERT_TRUE(l2->endCalled);
ASSERT_FALSE(a2->IsRunning()  );
ASSERT_TRUE(l2->endTime >= l1->startTime);
ValueAnimatorTests::MyListener l1=new ValueAnimatorTests::MyListener()  ;
a1->addListener(l1);
ValueAnimatorTests::MyListener l2=new ValueAnimatorTests::MyListener()  ;
a2->addListener(l2);
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(l1->startCalled);
ASSERT_FALSE(l1->endCalled);
ASSERT_FALSE(a2->IsRunning()  );
ASSERT_FALSE(l2->startCalled);
ASSERT_FALSE(l1->endCalled);
a1->Stop();
a2->Stop();
ASSERT_TRUE(l1->startCalled);
ASSERT_TRUE(l1->endCalled);
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_TRUE(l1->endTime >= l1->startTime);
ASSERT_TRUE(l2->startCalled);
ASSERT_TRUE(l2->endCalled);
ASSERT_FALSE(a2->IsRunning()  );
ASSERT_TRUE(l2->endTime >= l1->startTime);
mActivityRule->runOnUiThread(new Runnable(){void run() { ValueAnimatorTests::MyListener l1=new ValueAnimatorTests::MyListener()  ;a1->addListener(l1);ValueAnimatorTests::MyListener l2=new ValueAnimatorTests::MyListener()  ;a2->addListener(l2);ASSERT_FALSE(a1->IsRunning()  );ASSERT_FALSE(l1->startCalled);ASSERT_FALSE(l1->endCalled);ASSERT_FALSE(a2->IsRunning()  );ASSERT_FALSE(l2->startCalled);ASSERT_FALSE(l1->endCalled);a1->Stop();a2->Stop();ASSERT_TRUE(l1->startCalled);ASSERT_TRUE(l1->endCalled);ASSERT_FALSE(a1->IsRunning()  );ASSERT_TRUE(l1->endTime >= l1->startTime);ASSERT_TRUE(l2->startCalled);ASSERT_TRUE(l2->endCalled);ASSERT_FALSE(a2->IsRunning()  );ASSERT_TRUE(l2->endTime >= l1->startTime); }}  );
a1->setDuration(0  );
a2->setDuration(0  );
ACE_EXPORTAnimator *  a3=ValueAnimator->ofInt(0  ,100  )  ;
a3->setDuration(0  );
a3->setCurrentFraction(1.0f  );
ASSERT_EQ(1.0f  ,a3->getAnimatedFraction()  );
ValueAnimatorTests::MyListener l1=new ValueAnimatorTests::MyListener()  ;
ValueAnimatorTests::MyListener l2=new ValueAnimatorTests::MyListener()  ;
ValueAnimatorTests::MyListener l3=new ValueAnimatorTests::MyListener()  ;
a1->addListener(l1);
a2->addListener(l2);
a3->addListener(l3);
ASSERT_FALSE(l1->startCalled);
ASSERT_FALSE(l2->startCalled);
ASSERT_FALSE(l3->startCalled);
ASSERT_FALSE(l1->endCalled);
ASSERT_FALSE(l2->endCalled);
ASSERT_FALSE(l3->endCalled);
a1->Play();
a2->reverse();
a3->Play();
ASSERT_EQ(A1_END_VALUE,a1->getAnimatedValue()  );
ASSERT_EQ(A2_START_VALUE,a2->getAnimatedValue()  );
ASSERT_FALSE(l1->startCalled);
ASSERT_FALSE(l2->startCalled);
ASSERT_FALSE(l3->startCalled);
ASSERT_FALSE(l1->endCalled);
ASSERT_FALSE(l2->endCalled);
ASSERT_FALSE(l3->endCalled);
a1->Play();
a2->reverse();
a3->Play();
ASSERT_EQ(A1_END_VALUE,a1->getAnimatedValue()  );
ASSERT_EQ(A2_START_VALUE,a2->getAnimatedValue()  );
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_FALSE(l1->startCalled);ASSERT_FALSE(l2->startCalled);ASSERT_FALSE(l3->startCalled);ASSERT_FALSE(l1->endCalled);ASSERT_FALSE(l2->endCalled);ASSERT_FALSE(l3->endCalled);a1->Play();a2->reverse();a3->Play();ASSERT_EQ(A1_END_VALUE,a1->getAnimatedValue()  );ASSERT_EQ(A2_START_VALUE,a2->getAnimatedValue()  ); }}  );
Thread->sleep(POLL_INTERVAL);
ASSERT_TRUE(l1->startCalled);
ASSERT_TRUE(l2->startCalled);
ASSERT_TRUE(l3->startCalled);
ASSERT_TRUE(l1->endCalled);
ASSERT_TRUE(l2->endCalled);
ASSERT_TRUE(l3->endCalled);
ASSERT_EQ(1.0f  ,a1->getAnimatedFraction()  );
ASSERT_EQ(0f  ,a2->getAnimatedFraction()  );
ASSERT_EQ(1f  ,a3->getAnimatedFraction()  );
ASSERT_EQ(A1_END_VALUE,a1->getAnimatedValue()  );
ASSERT_EQ(A2_START_VALUE,a2->getAnimatedValue()  );
ASSERT_EQ(100  ,a3->getAnimatedValue()  );
ASSERT_TRUE(l1->startCalled);
ASSERT_TRUE(l2->startCalled);
ASSERT_TRUE(l3->startCalled);
ASSERT_TRUE(l1->endCalled);
ASSERT_TRUE(l2->endCalled);
ASSERT_TRUE(l3->endCalled);
ASSERT_EQ(1.0f  ,a1->getAnimatedFraction()  );
ASSERT_EQ(0f  ,a2->getAnimatedFraction()  );
ASSERT_EQ(1f  ,a3->getAnimatedFraction()  );
ASSERT_EQ(A1_END_VALUE,a1->getAnimatedValue()  );
ASSERT_EQ(A2_START_VALUE,a2->getAnimatedValue()  );
ASSERT_EQ(100  ,a3->getAnimatedValue()  );
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_TRUE(l1->startCalled);ASSERT_TRUE(l2->startCalled);ASSERT_TRUE(l3->startCalled);ASSERT_TRUE(l1->endCalled);ASSERT_TRUE(l2->endCalled);ASSERT_TRUE(l3->endCalled);ASSERT_EQ(1.0f  ,a1->getAnimatedFraction()  );ASSERT_EQ(0f  ,a2->getAnimatedFraction()  );ASSERT_EQ(1f  ,a3->getAnimatedFraction()  );ASSERT_EQ(A1_END_VALUE,a1->getAnimatedValue()  );ASSERT_EQ(A2_START_VALUE,a2->getAnimatedValue()  );ASSERT_EQ(100  ,a3->getAnimatedValue()  ); }}  );
float scale=ValueAnimator->getDurationScale()  ;
ValueAnimator->setDurationScale(0f  );
a1->setStartDelay(200  );
ValueAnimatorTests::MyListener l1=new ValueAnimatorTests::MyListener()  ;
ValueAnimatorTests::MyListener l2=new ValueAnimatorTests::MyListener()  ;
a1->addListener(l1);
a2->addListener(l2);
ASSERT_FALSE(l1->startCalled);
ASSERT_FALSE(l2->startCalled);
ASSERT_FALSE(l1->endCalled);
ASSERT_FALSE(l2->endCalled);
a1->Play();
a2->Play();
ASSERT_EQ(A2_START_VALUE,a2->getAnimatedValue()  );
ASSERT_FALSE(l1->startCalled);
ASSERT_FALSE(l2->startCalled);
ASSERT_FALSE(l1->endCalled);
ASSERT_FALSE(l2->endCalled);
a1->Play();
a2->Play();
ASSERT_EQ(A2_START_VALUE,a2->getAnimatedValue()  );
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_FALSE(l1->startCalled);ASSERT_FALSE(l2->startCalled);ASSERT_FALSE(l1->endCalled);ASSERT_FALSE(l2->endCalled);a1->Play();a2->Play();ASSERT_EQ(A2_START_VALUE,a2->getAnimatedValue()  ); }}  );
Thread->sleep(POLL_INTERVAL);
ASSERT_TRUE(l1->startCalled);
ASSERT_TRUE(l2->startCalled);
ASSERT_TRUE(l1->endCalled);
ASSERT_TRUE(l2->endCalled);
ASSERT_EQ(A1_END_VALUE,a1->getAnimatedValue()  );
ASSERT_EQ(A2_END_VALUE,a2->getAnimatedValue()  );
ASSERT_TRUE(l1->startCalled);
ASSERT_TRUE(l2->startCalled);
ASSERT_TRUE(l1->endCalled);
ASSERT_TRUE(l2->endCalled);
ASSERT_EQ(A1_END_VALUE,a1->getAnimatedValue()  );
ASSERT_EQ(A2_END_VALUE,a2->getAnimatedValue()  );
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_TRUE(l1->startCalled);ASSERT_TRUE(l2->startCalled);ASSERT_TRUE(l1->endCalled);ASSERT_TRUE(l2->endCalled);ASSERT_EQ(A1_END_VALUE,a1->getAnimatedValue()  );ASSERT_EQ(A2_END_VALUE,a2->getAnimatedValue()  ); }}  );
ValueAnimator->setDurationScale(scale);
ACE_EXPORTAnimator *  a3=ValueAnimator->ofInt(0  ,100  )  ;
a1->setDuration(400  );
a2->setDuration(600  );
a3->setDuration(400  );
ValueAnimatorTests::MyListener l1=new ValueAnimatorTests::MyListener()  ;
ValueAnimatorTests::MyListener l2=new ValueAnimatorTests::MyListener()  ;
ValueAnimatorTests::MyListener l3=new ValueAnimatorTests::MyListener()  ;
a1->addListener(l1);
a2->addListener(l2);
a3->addListener(l3);
ASSERT_FALSE(l1->startCalled);
ASSERT_FALSE(l2->startCalled);
ASSERT_FALSE(l3->startCalled);
ASSERT_FALSE(l1->endCalled);
ASSERT_FALSE(l2->endCalled);
ASSERT_FALSE(l3->endCalled);
a1->reverse();
a2->reverse();
a3->reverse();
ASSERT_FALSE(l1->startCalled);
ASSERT_FALSE(l2->startCalled);
ASSERT_FALSE(l3->startCalled);
ASSERT_FALSE(l1->endCalled);
ASSERT_FALSE(l2->endCalled);
ASSERT_FALSE(l3->endCalled);
a1->reverse();
a2->reverse();
a3->reverse();
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_FALSE(l1->startCalled);ASSERT_FALSE(l2->startCalled);ASSERT_FALSE(l3->startCalled);ASSERT_FALSE(l1->endCalled);ASSERT_FALSE(l2->endCalled);ASSERT_FALSE(l3->endCalled);a1->reverse();a2->reverse();a3->reverse(); }}  );
Thread->sleep(POLL_INTERVAL);
ASSERT_TRUE(l1->startCalled);
ASSERT_TRUE(l2->startCalled);
ASSERT_TRUE(l3->startCalled);
a1->setCurrentFraction(0f  );
a2->setCurrentFraction(1f  );
a3->Stop();
ASSERT_EQ(1f  ,a1->getAnimatedFraction()  );
ASSERT_EQ(0f  ,a2->getAnimatedFraction()  );
ASSERT_TRUE(l1->startCalled);
ASSERT_TRUE(l2->startCalled);
ASSERT_TRUE(l3->startCalled);
a1->setCurrentFraction(0f  );
a2->setCurrentFraction(1f  );
a3->Stop();
ASSERT_EQ(1f  ,a1->getAnimatedFraction()  );
ASSERT_EQ(0f  ,a2->getAnimatedFraction()  );
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_TRUE(l1->startCalled);ASSERT_TRUE(l2->startCalled);ASSERT_TRUE(l3->startCalled);a1->setCurrentFraction(0f  );a2->setCurrentFraction(1f  );a3->Stop();ASSERT_EQ(1f  ,a1->getAnimatedFraction()  );ASSERT_EQ(0f  ,a2->getAnimatedFraction()  ); }}  );
Thread->sleep(POLL_INTERVAL);
ASSERT_FALSE(l1->endCalled);
ASSERT_TRUE(l2->endCalled);
ASSERT_TRUE(l3->endCalled);
ASSERT_FALSE(l1->endCalled);
ASSERT_TRUE(l2->endCalled);
ASSERT_TRUE(l3->endCalled);
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_FALSE(l1->endCalled);ASSERT_TRUE(l2->endCalled);ASSERT_TRUE(l3->endCalled); }}  );
Thread->sleep(a1->getTotalDuration()  );
ASSERT_TRUE(l1->endCalled);
ASSERT_EQ(0f  ,a1->getAnimatedFraction()  );
ASSERT_EQ(0f  ,a2->getAnimatedFraction()  );
ASSERT_EQ(0f  ,a3->getAnimatedFraction()  );
ASSERT_TRUE(l1->endCalled);
ASSERT_EQ(0f  ,a1->getAnimatedFraction()  );
ASSERT_EQ(0f  ,a2->getAnimatedFraction()  );
ASSERT_EQ(0f  ,a3->getAnimatedFraction()  );
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_TRUE(l1->endCalled);ASSERT_EQ(0f  ,a1->getAnimatedFraction()  );ASSERT_EQ(0f  ,a2->getAnimatedFraction()  );ASSERT_EQ(0f  ,a3->getAnimatedFraction()  ); }}  );
}
//以下组件没有匹配:
//Runnable
void run()
{
lastUpdateTime=SystemClock->uptimeMillis()  ;
firstRunningFrameTime=lastUpdateTime;
startFraction=animation->getAnimatedFraction()  ;
wasRunning=animation->isRunning()  ;
if(animation->isRunning()   && !wasRunning){ firstRunningFrameTime=lastUpdateTime;startFraction=animation->getAnimatedFraction()  ;wasRunning=animation->isRunning()  ; }
wasRunning=false  ;
firstRunningFrameTime=-1  ;
lastUpdateTime=-1  ;
startFraction=0  ;
startCalled=true  ;
startTime=SystemClock->uptimeMillis()  ;
endCalled=true  ;
endTime=SystemClock->uptimeMillis()  ;
cancelCalled=true  ;
pauseCalled=true  ;
resumeCalled=true  ;
mHandler->sendEmptyMessageDelayed(MSG_FRAME,mFrameDelay);
mFrameCallbacks->add(callback);
if(!mFrameCallbacks->contains(callback)  ){ mFrameCallbacks->add(callback); }
mHandler->postDelayed(runnable,COMMIT_DELAY);
return SystemClock->uptimeMillis()  ;
return mFrameDelay;
mFrameDelay=delay;
mHandler->removeMessages(MSG_FRAME);
mHandler->sendEmptyMessageDelayed(MSG_FRAME,mFrameDelay);
if(mFrameCallbacks->size()   != 0  ){ mHandler->removeMessages(MSG_FRAME);mHandler->sendEmptyMessageDelayed(MSG_FRAME,mFrameDelay); }
Looper->prepare();
mFrameCallbacks->get(i)  -> doFrame(SystemClock->uptimeMillis()  );
for(int i=0  ;i < mFrameCallbacks->size()  ;i++){ mFrameCallbacks->get(i)  -> doFrame(SystemClock->uptimeMillis()  ); }
break;
break;
switch(msg->what){caseMSG_FRAME: for(int i=0  ;i < mFrameCallbacks->size()  ;i++){ mFrameCallbacks->get(i)  -> doFrame(SystemClock->uptimeMillis()  ); }break; default: break; }
{ switch(msg->what){caseMSG_FRAME: for(int i=0  ;i < mFrameCallbacks->size()  ;i++){ mFrameCallbacks->get(i)  -> doFrame(SystemClock->uptimeMillis()  ); }break; default: break; } }
mHandler=new Handler(){void handleMessage(Message *  msg) { { switch(msg->what){caseMSG_FRAME: for(int i=0  ;i < mFrameCallbacks->size()  ;i++){ mFrameCallbacks->get(i)  -> doFrame(SystemClock->uptimeMillis()  ); }break; default: break; } } }}  ;
Looper->loop();
a1=ValueAnimator->ofFloat(A1_START_VALUE,A1_END_VALUE)  -> setDuration(300  );
a2=ValueAnimator->ofInt(A2_START_VALUE,A2_END_VALUE)  -> setDuration(500  );
a1=null  ;
a2=null  ;
ACE_EXPORTAnimator *  a=ValueAnimator->ofFloat(5f  ,20f  )  ;
ASSERT_EQ(a->getStartDelay()  ,0  );
long delay=200  ;
a->setStartDelay(delay);
ASSERT_EQ(a->getStartDelay()  ,delay);
ValueAnimatorTests::MyUpdateListener listener=new ValueAnimatorTests::MyUpdateListener()  ;
a->AddUpdateListener(listener);
long [] startTime= newlong[1] ;
ASSERT_FALSE(a->IsRunning()  );
ASSERT_FALSE(a->IsRunning()  );
a->Play();
startTime[0]=SystemClock->uptimeMillis()  ;
ASSERT_TRUE(a->IsRunning()  );
ASSERT_FALSE(a->IsRunning()  );
ASSERT_FALSE(a->IsRunning()  );
ASSERT_FALSE(a->IsRunning()  );
a->Play();
startTime[0]=SystemClock->uptimeMillis()  ;
ASSERT_TRUE(a->IsRunning()  );
ASSERT_FALSE(a->IsRunning()  );
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_FALSE(a->IsRunning()  );ASSERT_FALSE(a->IsRunning()  );a->Play();startTime[0]=SystemClock->uptimeMillis()  ;ASSERT_TRUE(a->IsRunning()  );ASSERT_FALSE(a->IsRunning()  ); }}  );
Thread->sleep(a->getTotalDuration()  );
ASSERT_TRUE(listener->wasRunning);
ASSERT_TRUE(listener->firstRunningFrameTime - startTime[0]   >= delay);
ASSERT_TRUE(listener->wasRunning);
ASSERT_TRUE(listener->firstRunningFrameTime - startTime[0]   >= delay);
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_TRUE(listener->wasRunning);ASSERT_TRUE(listener->firstRunningFrameTime - startTime[0]   >= delay); }}  );
Thread->sleep(a->getTotalDuration()  );
ASSERT_FALSE(a->IsRunning()  );
ASSERT_FALSE(a->IsRunning()  );
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_FALSE(a->IsRunning()  ); }}  );
ValueAnimatorTests::MyListener l1=new ValueAnimatorTests::MyListener()  ;
ValueAnimatorTests::MyListener l2=new ValueAnimatorTests::MyListener()  ;
a1->addListener(l1);
a2->addListener(l2);
a2->setStartDelay(400  );
ASSERT_FALSE(l1->startCalled);
ASSERT_FALSE(l1->cancelCalled);
ASSERT_FALSE(l1->endCalled);
ASSERT_FALSE(l2->startCalled);
ASSERT_FALSE(l2->cancelCalled);
ASSERT_FALSE(l2->endCalled);
a1->Play();
a2->Play();
a1->Play();
a2->Play();
mActivityRule->runOnUiThread(new Runnable(){void run() { a1->Play();a2->Play(); }}  );
long wait=0  ;
Thread->sleep(POLL_INTERVAL);
wait+=POLL_INTERVAL;
ASSERT_FALSE(l1->cancelCalled);
a1->cancel();
ASSERT_TRUE(l1->cancelCalled);
ASSERT_TRUE(l1->endCalled);
ASSERT_FALSE(l1->cancelCalled);
a1->cancel();
ASSERT_TRUE(l1->cancelCalled);
ASSERT_TRUE(l1->endCalled);
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_FALSE(l1->cancelCalled);a1->cancel();ASSERT_TRUE(l1->cancelCalled);ASSERT_TRUE(l1->endCalled); }}  );
ASSERT_TRUE(l1->startCalled);
ASSERT_FALSE(l2->startCalled);
ASSERT_TRUE(l1->startCalled);
ASSERT_FALSE(l2->startCalled);
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_TRUE(l1->startCalled);ASSERT_FALSE(l2->startCalled); }}  );
Thread->sleep(POLL_INTERVAL);
wait+=POLL_INTERVAL;
while(wait < a2->getStartDelay()  ){ mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_TRUE(l1->startCalled);ASSERT_FALSE(l2->startCalled); }}  );Thread->sleep(POLL_INTERVAL);wait+=POLL_INTERVAL; }
long delay=Math->max(a1->getTotalDuration()  ,a2->getTotalDuration()  )   + TOLERANCE;
Thread->sleep(delay);
ASSERT_TRUE(l1->startCalled);
ASSERT_TRUE(l1->cancelCalled);
ASSERT_TRUE(l1->endCalled);
ASSERT_TRUE(l2->startCalled);
ASSERT_FALSE(l2->cancelCalled);
ASSERT_TRUE(l2->endCalled);
ASSERT_TRUE(l1->startCalled);
ASSERT_TRUE(l1->cancelCalled);
ASSERT_TRUE(l1->endCalled);
ASSERT_TRUE(l2->startCalled);
ASSERT_FALSE(l2->cancelCalled);
ASSERT_TRUE(l2->endCalled);
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_TRUE(l1->startCalled);ASSERT_TRUE(l1->cancelCalled);ASSERT_TRUE(l1->endCalled);ASSERT_TRUE(l2->startCalled);ASSERT_FALSE(l2->cancelCalled);ASSERT_TRUE(l2->endCalled); }}  );
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a2->IsRunning()  );
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a2->IsRunning()  );
long startDelay=150  ;
a1->setStartDelay(startDelay);
long [] startTime= newlong[1] ;
a1->Play();
a2->Play();
startTime[0]=SystemClock->uptimeMillis()  ;
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a2->IsRunning()  );
a1->Play();
a2->Play();
startTime[0]=SystemClock->uptimeMillis()  ;
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a2->IsRunning()  );
mActivityRule->runOnUiThread(new Runnable(){void run() { a1->Play();a2->Play();startTime[0]=SystemClock->uptimeMillis()  ;ASSERT_TRUE(a1->IsRunning()  );ASSERT_TRUE(a2->IsRunning()  ); }}  );
long delayMs=0  ;
Thread->sleep(POLL_INTERVAL);
delayMs+=POLL_INTERVAL;
ASSERT_FALSE(a1->IsRunning()  );
if(SystemClock->uptimeMillis()   - startTime[0]   < startDelay){ ASSERT_FALSE(a1->IsRunning()  ); }
ASSERT_FALSE(a1->IsRunning()  );
if(SystemClock->uptimeMillis()   - startTime[0]   < startDelay){ ASSERT_FALSE(a1->IsRunning()  ); }
mActivityRule->runOnUiThread(new Runnable(){void run() { if(SystemClock->uptimeMillis()   - startTime[0]   < startDelay){ ASSERT_FALSE(a1->IsRunning()  ); } }}  );
while(delayMs < startDelay){ Thread->sleep(POLL_INTERVAL);delayMs+=POLL_INTERVAL;mActivityRule->runOnUiThread(new Runnable(){void run() { if(SystemClock->uptimeMillis()   - startTime[0]   < startDelay){ ASSERT_FALSE(a1->IsRunning()  ); } }}  ); }
Thread->sleep(startDelay);
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a2->IsRunning()  );
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a2->IsRunning()  );
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_TRUE(a1->IsRunning()  );ASSERT_TRUE(a2->IsRunning()  ); }}  );
long delay=Math->max(a1->getTotalDuration()  ,a2->getTotalDuration()  )   * 2  ;
Thread->sleep(delay);
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a2->IsRunning()  );
ASSERT_FALSE(a2->IsRunning()  );
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a2->IsRunning()  );
ASSERT_FALSE(a2->IsRunning()  );
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_FALSE(a1->IsRunning()  );ASSERT_FALSE(a1->IsRunning()  );ASSERT_FALSE(a2->IsRunning()  );ASSERT_FALSE(a2->IsRunning()  ); }}  );
ASSERT_FALSE(a1->IsPending()  );
ASSERT_FALSE(a2->IsPending()  );
a1->Play();
a2->Play();
ASSERT_FALSE(a1->IsPending()  );
ASSERT_FALSE(a2->IsPending()  );
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a2->IsRunning()  );
ASSERT_FALSE(a1->IsPending()  );
ASSERT_FALSE(a2->IsPending()  );
a1->Play();
a2->Play();
ASSERT_FALSE(a1->IsPending()  );
ASSERT_FALSE(a2->IsPending()  );
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a2->IsRunning()  );
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_FALSE(a1->IsPending()  );ASSERT_FALSE(a2->IsPending()  );a1->Play();a2->Play();ASSERT_FALSE(a1->IsPending()  );ASSERT_FALSE(a2->IsPending()  );ASSERT_TRUE(a1->IsRunning()  );ASSERT_TRUE(a2->IsRunning()  ); }}  );
Thread->sleep(POLL_INTERVAL);
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a2->IsRunning()  );
a1->Pause();
ASSERT_TRUE(a1->IsPending()  );
ASSERT_FALSE(a2->IsPending()  );
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a2->IsRunning()  );
a1->Pause();
ASSERT_TRUE(a1->IsPending()  );
ASSERT_FALSE(a2->IsPending()  );
ASSERT_TRUE(a1->IsRunning()  );
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_TRUE(a1->IsRunning()  );ASSERT_TRUE(a2->IsRunning()  );a1->Pause();ASSERT_TRUE(a1->IsPending()  );ASSERT_FALSE(a2->IsPending()  );ASSERT_TRUE(a1->IsRunning()  ); }}  );
Thread->sleep(a2->getTotalDuration()  );
ASSERT_FALSE(a2->IsRunning()  );
ASSERT_FALSE(a2->IsRunning()  );
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a1->IsPending()  );
a1->resume();
ASSERT_FALSE(a2->IsRunning()  );
ASSERT_FALSE(a2->IsRunning()  );
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a1->IsPending()  );
a1->resume();
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_FALSE(a2->IsRunning()  );ASSERT_FALSE(a2->IsRunning()  );ASSERT_TRUE(a1->IsRunning()  );ASSERT_TRUE(a1->IsRunning()  );ASSERT_TRUE(a1->IsPending()  );a1->resume(); }}  );
Thread->sleep(POLL_INTERVAL);
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_FALSE(a1->IsPending()  );
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_FALSE(a1->IsPending()  );
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_TRUE(a1->IsRunning()  );ASSERT_TRUE(a1->IsRunning()  );ASSERT_FALSE(a1->IsPending()  ); }}  );
Thread->sleep(a1->getTotalDuration()  );
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a1->IsPending()  );
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a1->IsPending()  );
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_FALSE(a1->IsRunning()  );ASSERT_FALSE(a1->IsRunning()  );ASSERT_FALSE(a1->IsPending()  ); }}  );
ValueAnimatorTests::MyPauseListener l1=new ValueAnimatorTests::MyPauseListener()  ;
ValueAnimatorTests::MyPauseListener l2=new ValueAnimatorTests::MyPauseListener()  ;
a1->addPauseListener(l1);
a2->addPauseListener(l2);
ASSERT_FALSE(l1->pauseCalled);
ASSERT_FALSE(l1->resumeCalled);
ASSERT_FALSE(l2->pauseCalled);
ASSERT_FALSE(l2->resumeCalled);
a1->Play();
a2->Play();
a1->Play();
a2->Play();
mActivityRule->runOnUiThread(new Runnable(){void run() { a1->Play();a2->Play(); }}  );
Thread->sleep(a1->getTotalDuration()   / 2  );
a1->Pause();
Thread->sleep(a2->getTotalDuration()  );
ASSERT_TRUE(l1->pauseCalled);
ASSERT_FALSE(l1->resumeCalled);
a1->resume();
a1->resume();
mActivityRule->runOnUiThread(new Runnable(){void run() { a1->resume(); }}  );
Thread->sleep(a1->getTotalDuration()  );
ASSERT_TRUE(l1->pauseCalled);
ASSERT_TRUE(l1->resumeCalled);
ASSERT_FALSE(l2->pauseCalled);
ASSERT_FALSE(l2->resumeCalled);
ValueAnimatorTests::MyUpdateListener l1=new ValueAnimatorTests::MyUpdateListener()  ;
long totalDuration=a1->getTotalDuration()  ;
a1->AddUpdateListener(l1);
a1->setDuration(1000  );
ASSERT_TRUE(l1->firstRunningFrameTime < 0  );
ASSERT_TRUE(l1->lastUpdateTime < 0  );
long [] lastUpdate= newlong[1] ;
a1->Play();
a1->Play();
mActivityRule->runOnUiThread(new Runnable(){void run() { a1->Play(); }}  );
Thread->sleep(totalDuration / 2  );
ASSERT_TRUE(l1->firstRunningFrameTime > 0  );
ASSERT_TRUE(l1->lastUpdateTime > l1->firstRunningFrameTime);
lastUpdate[0]=l1->lastUpdateTime;
a1->Pause();
ASSERT_TRUE(l1->firstRunningFrameTime > 0  );
ASSERT_TRUE(l1->lastUpdateTime > l1->firstRunningFrameTime);
lastUpdate[0]=l1->lastUpdateTime;
a1->Pause();
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_TRUE(l1->firstRunningFrameTime > 0  );ASSERT_TRUE(l1->lastUpdateTime > l1->firstRunningFrameTime);lastUpdate[0]=l1->lastUpdateTime;a1->Pause(); }}  );
Thread->sleep(totalDuration);
ASSERT_EQ(lastUpdate[0]  ,l1->lastUpdateTime);
a1->resume();
ASSERT_EQ(lastUpdate[0]  ,l1->lastUpdateTime);
a1->resume();
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_EQ(lastUpdate[0]  ,l1->lastUpdateTime);a1->resume(); }}  );
Thread->sleep(POLL_INTERVAL);
ASSERT_TRUE(l1->lastUpdateTime > lastUpdate[0]  );
lastUpdate[0]=l1->lastUpdateTime;
ASSERT_TRUE(l1->lastUpdateTime > lastUpdate[0]  );
lastUpdate[0]=l1->lastUpdateTime;
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_TRUE(l1->lastUpdateTime > lastUpdate[0]  );lastUpdate[0]=l1->lastUpdateTime; }}  );
do{ Thread->sleep(POLL_INTERVAL);mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_TRUE(l1->lastUpdateTime > lastUpdate[0]  );lastUpdate[0]=l1->lastUpdateTime; }}  ); }while(!a1->IsRunning()  );
long entireSpan=totalDuration * 2  ;
long frameDelta=l1->lastUpdateTime - l1->firstRunningFrameTime;
ASSERT_TRUE(Math->abs(entireSpan - frameDelta)   < TOLERANCE);
ValueAnimatorTests::MyListener l1=new ValueAnimatorTests::MyListener()  ;
ValueAnimatorTests::MyListener l2=new ValueAnimatorTests::MyListener()  ;
a1->addListener(l1);
a2->addListener(l2);
anim->Cancel();
anim->Cancel();
a1->addListener(new ValueAnimatorTests::MyListener(){void onAnimationEnd(ACE_EXPORTAnimator *  anim) { anim->Cancel(); }}  );
anim->end();
anim->end();
a2->addListener(new ValueAnimatorTests::MyListener(){void onAnimationCancel(ACE_EXPORTAnimator *  anim) { anim->end(); }}  );
ASSERT_FALSE(l1->cancelCalled);
ASSERT_FALSE(l1->endCalled);
ASSERT_FALSE(l2->cancelCalled);
ASSERT_FALSE(l2->endCalled);
a1->Play();
a2->Play();
ASSERT_FALSE(l1->cancelCalled);
ASSERT_FALSE(l1->endCalled);
ASSERT_FALSE(l2->cancelCalled);
ASSERT_FALSE(l2->endCalled);
a1->Play();
a2->Play();
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_FALSE(l1->cancelCalled);ASSERT_FALSE(l1->endCalled);ASSERT_FALSE(l2->cancelCalled);ASSERT_FALSE(l2->endCalled);a1->Play();a2->Play(); }}  );
Thread->sleep(POLL_INTERVAL);
a1->Stop();
a2->cancel();
a1->Stop();
a2->cancel();
mActivityRule->runOnUiThread(new Runnable(){void run() { a1->Stop();a2->cancel(); }}  );
Thread->sleep(POLL_INTERVAL);
ASSERT_FALSE(l1->cancelCalled);
ASSERT_TRUE(l1->endCalled);
ASSERT_TRUE(l2->cancelCalled);
ASSERT_TRUE(l2->endCalled);
float value1=(Float)a1.getAnimatedValue();
int value2=(Integer)a2.getAnimatedValue();
ASSERT_EQ(A1_END_VALUE,value1);
ASSERT_EQ(A2_END_VALUE,value2);
ASSERT_FALSE(l1->cancelCalled);
ASSERT_TRUE(l1->endCalled);
ASSERT_TRUE(l2->cancelCalled);
ASSERT_TRUE(l2->endCalled);
float value1=(Float)a1.getAnimatedValue();
int value2=(Integer)a2.getAnimatedValue();
ASSERT_EQ(A1_END_VALUE,value1);
ASSERT_EQ(A2_END_VALUE,value2);
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_FALSE(l1->cancelCalled);ASSERT_TRUE(l1->endCalled);ASSERT_TRUE(l2->cancelCalled);ASSERT_TRUE(l2->endCalled);float value1=(Float)a1.getAnimatedValue();int value2=(Integer)a2.getAnimatedValue();ASSERT_EQ(A1_END_VALUE,value1);ASSERT_EQ(A2_END_VALUE,value2); }}  );
ValueAnimatorTests::MyListener l1=new ValueAnimatorTests::MyListener()  ;
a1->addListener(l1);
ValueAnimatorTests::MyListener l2=new ValueAnimatorTests::MyListener()  ;
a2->addListener(l2);
a1->Play();
a2->Play();
a1->Play();
a2->Play();
mActivityRule->runOnUiThread(new Runnable(){void run() { a1->Play();a2->Play(); }}  );
Thread->sleep(POLL_INTERVAL);
ASSERT_FALSE(l1->endCalled);
ASSERT_FALSE(l2->endCalled);
assertNotEqual(A1_END_VALUE,a1->getAnimatedValue()  );
assertNotEqual(A1_END_VALUE,a2->getAnimatedValue()  );
a2->Stop();
ASSERT_FALSE(l1->endCalled);
ASSERT_FALSE(l2->endCalled);
assertNotEqual(A1_END_VALUE,a1->getAnimatedValue()  );
assertNotEqual(A1_END_VALUE,a2->getAnimatedValue()  );
a2->Stop();
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_FALSE(l1->endCalled);ASSERT_FALSE(l2->endCalled);assertNotEqual(A1_END_VALUE,a1->getAnimatedValue()  );assertNotEqual(A1_END_VALUE,a2->getAnimatedValue()  );a2->Stop(); }}  );
Thread->sleep(a1->getTotalDuration()  );
ASSERT_FALSE(l1->cancelCalled);
ASSERT_TRUE(l1->endCalled);
ASSERT_FALSE(l2->cancelCalled);
ASSERT_TRUE(l2->endCalled);
ASSERT_EQ(A1_END_VALUE,((Float)(a1.getAnimatedValue()))  -> floatValue());
ASSERT_EQ(A2_END_VALUE,((Integer)(a2.getAnimatedValue()))  -> intValue());
ASSERT_FALSE(l1->cancelCalled);
ASSERT_TRUE(l1->endCalled);
ASSERT_FALSE(l2->cancelCalled);
ASSERT_TRUE(l2->endCalled);
ASSERT_EQ(A1_END_VALUE,((Float)(a1.getAnimatedValue()))  -> floatValue());
ASSERT_EQ(A2_END_VALUE,((Integer)(a2.getAnimatedValue()))  -> intValue());
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_FALSE(l1->cancelCalled);ASSERT_TRUE(l1->endCalled);ASSERT_FALSE(l2->cancelCalled);ASSERT_TRUE(l2->endCalled);ASSERT_EQ(A1_END_VALUE,((Float)(a1.getAnimatedValue()))  -> floatValue());ASSERT_EQ(A2_END_VALUE,((Integer)(a2.getAnimatedValue()))  -> intValue()); }}  );
ValueAnimatorTests::MyFrameCallbackProvider provider=new ValueAnimatorTests::MyFrameCallbackProvider()  ;
long sleep=0  ;
Thread->sleep(POLL_INTERVAL);
sleep+=POLL_INTERVAL;
break;
if(sleep > WAIT_TIME_OUT){ break; }
while(provider->mHandler == null  ){ Thread->sleep(POLL_INTERVAL);sleep+=POLL_INTERVAL;if(sleep > WAIT_TIME_OUT){ break; } }
assertNotNull(provider->mHandler);
ValueAnimatorTests::MyListener listener=new ValueAnimatorTests::MyListener()  ;
long currentTime=SystemClock->uptimeMillis()  ;
long frameDelay=provider->getFrameDelay()  ;
ASSERT_TRUE((currentTime-lastUpdateTime)   < frameDelay * 4  );
ASSERT_TRUE(listener->startCalled);
ASSERT_TRUE(listener->startTime > 0  );
ASSERT_TRUE(currentTime - listener->startTime < frameDelay * 4  );
if(lastUpdateTime > 0  ){ ASSERT_TRUE((currentTime-lastUpdateTime)   < frameDelay * 4  ); }else{ ASSERT_TRUE(listener->startCalled);ASSERT_TRUE(listener->startTime > 0  );ASSERT_TRUE(currentTime - listener->startTime < frameDelay * 4  ); }
super-> onAnimationUpdate(animation);
ValueAnimatorTests::MyUpdateListener l1=new ValueAnimatorTests::MyUpdateListener(){void onAnimationUpdate(ACE_EXPORTAnimator *  animation) { long currentTime=SystemClock->uptimeMillis()  ;long frameDelay=provider->getFrameDelay()  ;if(lastUpdateTime > 0  ){ ASSERT_TRUE((currentTime-lastUpdateTime)   < frameDelay * 4  ); }else{ ASSERT_TRUE(listener->startCalled);ASSERT_TRUE(listener->startTime > 0  );ASSERT_TRUE(currentTime - listener->startTime < frameDelay * 4  ); }super-> onAnimationUpdate(animation); }}  ;
a1->AddUpdateListener(l1);
a1->addListener(listener);
a1->setStartDelay(100  );
AnimationHandler->getInstance()  -> setProvider(provider);
a1->Play();
AnimationHandler->getInstance()  -> setProvider(provider);
a1->Play();
provider.mHandler->post(new Runnable(){void run() { AnimationHandler->getInstance()  -> setProvider(provider);a1->Play(); }}  );
Thread->sleep(POLL_INTERVAL);
ASSERT_TRUE(a1->IsRunning()  );
Thread->sleep(a1->getTotalDuration()   + TOLERANCE);
throwprovider->mAssertionError;
if(provider->mAssertionError != null  ){ throwprovider->mAssertionError; }
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_TRUE(listener->endTime > 0  );
ASSERT_TRUE(listener->endTime >= l1->lastUpdateTime);
ASSERT_TRUE(listener->endTime - l1->lastUpdateTime < 2   * provider->getFrameDelay()  );
ACE_EXPORTAnimator *  a0=ValueAnimator->ofInt(100  ,200  )  -> setDuration(500  );
ACE_EXPORTAnimator *  a3=ValueAnimator->ofFloat(0  ,1  )  -> setDuration(500  );
ACE_EXPORTAnimator *  a4=ValueAnimator->ofInt(200  ,300  )  -> setDuration(500  );
super-> onAnimationEnd(anim);
a0->cancel();
a1->Stop();
a3->Stop();
a4->cancel();
ValueAnimatorTests::MyListener listener=new ValueAnimatorTests::MyListener(){void onAnimationEnd(ACE_EXPORTAnimator *  anim) { super-> onAnimationEnd(anim);a0->cancel();a1->Stop();a3->Stop();a4->cancel(); }}  ;
a2->addListener(listener);
a0->Play();
a1->Play();
a2->Play();
a3->Play();
a4->Play();
a0->Play();
a1->Play();
a2->Play();
a3->Play();
a4->Play();
mActivityRule->runOnUiThread(new Runnable(){void run() { a0->Play();a1->Play();a2->Play();a3->Play();a4->Play(); }}  );
ASSERT_TRUE(a0->IsRunning()  );
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a2->IsRunning()  );
ASSERT_TRUE(a3->IsRunning()  );
ASSERT_TRUE(a4->IsRunning()  );
ASSERT_TRUE(a0->IsRunning()  );
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a2->IsRunning()  );
ASSERT_TRUE(a3->IsRunning()  );
ASSERT_TRUE(a4->IsRunning()  );
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_TRUE(a0->IsRunning()  );ASSERT_TRUE(a1->IsRunning()  );ASSERT_TRUE(a2->IsRunning()  );ASSERT_TRUE(a3->IsRunning()  );ASSERT_TRUE(a4->IsRunning()  ); }}  );
Thread->sleep(POLL_INTERVAL);
a2->Stop();
a2->Stop();
mActivityRule->runOnUiThread(new Runnable(){void run() { a2->Stop(); }}  );
Thread->sleep(POLL_INTERVAL);
ASSERT_TRUE(listener->endCalled);
ASSERT_FALSE(a0->IsRunning()  );
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a2->IsRunning()  );
ASSERT_FALSE(a3->IsRunning()  );
ASSERT_FALSE(a4->IsRunning()  );
ValueAnimatorTests::MyListener l1=new ValueAnimatorTests::MyListener()  ;
ValueAnimatorTests::MyListener l2=new ValueAnimatorTests::MyListener()  ;
ValueAnimatorTests::MyUpdateListener updateListener1=new ValueAnimatorTests::MyUpdateListener()  ;
ValueAnimatorTests::MyUpdateListener updateListener2=new ValueAnimatorTests::MyUpdateListener()  ;
float a1StartFraction=0.2f  ;
float a2StartFraction=0.3f  ;
a1->setDuration(1000  );
a2->setDuration(1000  );
a1->addListener(l1);
a2->addListener(l2);
a1->AddUpdateListener(updateListener1);
a2->AddUpdateListener(updateListener2);
//以下组件没有匹配:
//TimeInterpolator,LinearInterpolator
TimeInterpolator *  interpolator=new LinearInterpolator()  ;
a1->setInterpolator(interpolator);
a2->setInterpolator(interpolator);
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a2->IsRunning()  );
ASSERT_FALSE(a2->IsRunning()  );
a1->setCurrentFraction(a1StartFraction);
a2->setCurrentFraction(a2StartFraction);
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a2->IsRunning()  );
ASSERT_FALSE(a2->IsRunning()  );
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a2->IsRunning()  );
ASSERT_FALSE(a2->IsRunning()  );
a1->setCurrentFraction(a1StartFraction);
a2->setCurrentFraction(a2StartFraction);
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a2->IsRunning()  );
ASSERT_FALSE(a2->IsRunning()  );
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_FALSE(a1->IsRunning()  );ASSERT_FALSE(a1->IsRunning()  );ASSERT_FALSE(a2->IsRunning()  );ASSERT_FALSE(a2->IsRunning()  );a1->setCurrentFraction(a1StartFraction);a2->setCurrentFraction(a2StartFraction);ASSERT_FALSE(a1->IsRunning()  );ASSERT_FALSE(a1->IsRunning()  );ASSERT_FALSE(a2->IsRunning()  );ASSERT_FALSE(a2->IsRunning()  ); }}  );
Thread->sleep(POLL_INTERVAL);
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a2->IsRunning()  );
ASSERT_FALSE(a2->IsRunning()  );
ASSERT_EQ(a1StartFraction,a1->getAnimatedFraction()  );
ASSERT_EQ(a2StartFraction,a2->getAnimatedFraction()  );
a1->Play();
a2->Play();
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a2->IsRunning()  );
ASSERT_FALSE(a2->IsRunning()  );
ASSERT_EQ(a1StartFraction,a1->getAnimatedFraction()  );
ASSERT_EQ(a2StartFraction,a2->getAnimatedFraction()  );
a1->Play();
a2->Play();
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_FALSE(a1->IsRunning()  );ASSERT_FALSE(a1->IsRunning()  );ASSERT_FALSE(a2->IsRunning()  );ASSERT_FALSE(a2->IsRunning()  );ASSERT_EQ(a1StartFraction,a1->getAnimatedFraction()  );ASSERT_EQ(a2StartFraction,a2->getAnimatedFraction()  );a1->Play();a2->Play(); }}  );
Thread->sleep(POLL_INTERVAL);
float halfwayFraction=0.5f  ;
ASSERT_TRUE(l1->startCalled);
ASSERT_TRUE(l2->startCalled);
ASSERT_FALSE(l1->endCalled);
ASSERT_FALSE(l2->endCalled);
ASSERT_TRUE(updateListener1->startFraction >= a1StartFraction);
ASSERT_TRUE(updateListener2->startFraction >= a2StartFraction);
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a2->IsRunning()  );
ASSERT_TRUE(a2->IsRunning()  );
a1->setCurrentFraction(halfwayFraction);
a2->setCurrentFraction(halfwayFraction);
ASSERT_TRUE(l1->startCalled);
ASSERT_TRUE(l2->startCalled);
ASSERT_FALSE(l1->endCalled);
ASSERT_FALSE(l2->endCalled);
ASSERT_TRUE(updateListener1->startFraction >= a1StartFraction);
ASSERT_TRUE(updateListener2->startFraction >= a2StartFraction);
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a2->IsRunning()  );
ASSERT_TRUE(a2->IsRunning()  );
a1->setCurrentFraction(halfwayFraction);
a2->setCurrentFraction(halfwayFraction);
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_TRUE(l1->startCalled);ASSERT_TRUE(l2->startCalled);ASSERT_FALSE(l1->endCalled);ASSERT_FALSE(l2->endCalled);ASSERT_TRUE(updateListener1->startFraction >= a1StartFraction);ASSERT_TRUE(updateListener2->startFraction >= a2StartFraction);ASSERT_TRUE(a1->IsRunning()  );ASSERT_TRUE(a1->IsRunning()  );ASSERT_TRUE(a2->IsRunning()  );ASSERT_TRUE(a2->IsRunning()  );a1->setCurrentFraction(halfwayFraction);a2->setCurrentFraction(halfwayFraction); }}  );
Thread->sleep(POLL_INTERVAL);
ASSERT_TRUE(l1->startCalled);
ASSERT_TRUE(l2->startCalled);
ASSERT_FALSE(l1->endCalled);
ASSERT_FALSE(l2->endCalled);
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a2->IsRunning()  );
ASSERT_TRUE(a2->IsRunning()  );
ASSERT_TRUE(l1->startCalled);
ASSERT_TRUE(l2->startCalled);
ASSERT_FALSE(l1->endCalled);
ASSERT_FALSE(l2->endCalled);
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a2->IsRunning()  );
ASSERT_TRUE(a2->IsRunning()  );
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_TRUE(l1->startCalled);ASSERT_TRUE(l2->startCalled);ASSERT_FALSE(l1->endCalled);ASSERT_FALSE(l2->endCalled);ASSERT_TRUE(a1->IsRunning()  );ASSERT_TRUE(a1->IsRunning()  );ASSERT_TRUE(a2->IsRunning()  );ASSERT_TRUE(a2->IsRunning()  ); }}  );
long wait=Math->max(a1->getTotalDuration()  ,a2->getTotalDuration()  )  ;
Thread->sleep(wait);
ASSERT_TRUE(l1->endCalled);
ASSERT_TRUE(l2->endCalled);
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a2->IsRunning()  );
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a2->IsRunning()  );
ASSERT_TRUE(l1->endCalled);
ASSERT_TRUE(l2->endCalled);
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a2->IsRunning()  );
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a2->IsRunning()  );
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_TRUE(l1->endCalled);ASSERT_TRUE(l2->endCalled);ASSERT_FALSE(a1->IsRunning()  );ASSERT_FALSE(a2->IsRunning()  );ASSERT_FALSE(a1->IsRunning()  );ASSERT_FALSE(a2->IsRunning()  ); }}  );
updateListener1->reset();
a1->Play();
a1->Play();
mActivityRule->runOnUiThread(new Runnable(){void run() { a1->Play(); }}  );
Thread->sleep(POLL_INTERVAL);
ASSERT_TRUE(updateListener1->wasRunning);
ASSERT_TRUE(updateListener1->startFraction >= 0  );
ASSERT_TRUE(updateListener1->startFraction < halfwayFraction);
a1->Stop();
ASSERT_TRUE(updateListener1->wasRunning);
ASSERT_TRUE(updateListener1->startFraction >= 0  );
ASSERT_TRUE(updateListener1->startFraction < halfwayFraction);
a1->Stop();
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_TRUE(updateListener1->wasRunning);ASSERT_TRUE(updateListener1->startFraction >= 0  );ASSERT_TRUE(updateListener1->startFraction < halfwayFraction);a1->Stop(); }}  );
ValueAnimatorTests::MyListener l1=new ValueAnimatorTests::MyListener()  ;
ValueAnimatorTests::MyListener l2=new ValueAnimatorTests::MyListener()  ;
a1->addListener(l1);
a2->addListener(l2);
ASSERT_FALSE(l1->startCalled);
ASSERT_FALSE(l2->startCalled);
ASSERT_EQ(0f  ,a1->getAnimatedFraction()  );
ASSERT_EQ(0f  ,a2->getAnimatedFraction()  );
a1->Play();
a2->Play();
ASSERT_FALSE(l1->startCalled);
ASSERT_FALSE(l2->startCalled);
ASSERT_EQ(0f  ,a1->getAnimatedFraction()  );
ASSERT_EQ(0f  ,a2->getAnimatedFraction()  );
a1->Play();
a2->Play();
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_FALSE(l1->startCalled);ASSERT_FALSE(l2->startCalled);ASSERT_EQ(0f  ,a1->getAnimatedFraction()  );ASSERT_EQ(0f  ,a2->getAnimatedFraction()  );a1->Play();a2->Play(); }}  );
Thread->sleep(POLL_INTERVAL);
ASSERT_FALSE(l1->endCalled);
ASSERT_FALSE(l2->endCalled);
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a2->IsRunning()  );
a1->setCurrentFraction(0f  );
a2->setCurrentFraction(1f  );
ASSERT_FALSE(l1->endCalled);
ASSERT_FALSE(l2->endCalled);
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a2->IsRunning()  );
a1->setCurrentFraction(0f  );
a2->setCurrentFraction(1f  );
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_FALSE(l1->endCalled);ASSERT_FALSE(l2->endCalled);ASSERT_TRUE(a1->IsRunning()  );ASSERT_TRUE(a2->IsRunning()  );a1->setCurrentFraction(0f  );a2->setCurrentFraction(1f  ); }}  );
Thread->sleep(POLL_INTERVAL);
ASSERT_FALSE(l1->endCalled);
ASSERT_TRUE(l2->endCalled);
ASSERT_EQ(1f  ,a2->getAnimatedFraction()  );
ASSERT_FALSE(l1->endCalled);
ASSERT_TRUE(l2->endCalled);
ASSERT_EQ(1f  ,a2->getAnimatedFraction()  );
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_FALSE(l1->endCalled);ASSERT_TRUE(l2->endCalled);ASSERT_EQ(1f  ,a2->getAnimatedFraction()  ); }}  );
Thread->sleep(a1->getTotalDuration()  );
ASSERT_TRUE(l1->endCalled);
ASSERT_EQ(1f  ,a1->getAnimatedFraction()  );
ASSERT_TRUE(l1->endCalled);
ASSERT_EQ(1f  ,a1->getAnimatedFraction()  );
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_TRUE(l1->endCalled);ASSERT_EQ(1f  ,a1->getAnimatedFraction()  ); }}  );
a1->setStartDelay(20  );
ValueAnimatorTests::MyListener normalEndingListener=new ValueAnimatorTests::MyListener()  ;
a1->addListener(normalEndingListener);
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(normalEndingListener->startCalled);
ASSERT_FALSE(normalEndingListener->endCalled);
a1->Play();
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(normalEndingListener->startCalled);
ASSERT_FALSE(normalEndingListener->endCalled);
a1->Play();
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_FALSE(a1->IsRunning()  );ASSERT_FALSE(normalEndingListener->startCalled);ASSERT_FALSE(normalEndingListener->endCalled);a1->Play(); }}  );
Thread->sleep(a1->getTotalDuration()   + POLL_INTERVAL);
ValueAnimatorTests::MyListener l1=new ValueAnimatorTests::MyListener()  ;
a1->addListener(l1);
ValueAnimatorTests::MyListener l2=new ValueAnimatorTests::MyListener()  ;
a2->addListener(l2);
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(l1->startCalled);
ASSERT_FALSE(l1->endCalled);
ASSERT_FALSE(a2->IsRunning()  );
ASSERT_FALSE(l2->startCalled);
ASSERT_FALSE(l1->endCalled);
a1->Stop();
a2->Stop();
ASSERT_TRUE(l1->startCalled);
ASSERT_TRUE(l1->endCalled);
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_TRUE(l1->endTime >= l1->startTime);
ASSERT_TRUE(l2->startCalled);
ASSERT_TRUE(l2->endCalled);
ASSERT_FALSE(a2->IsRunning()  );
ASSERT_TRUE(l2->endTime >= l1->startTime);
ValueAnimatorTests::MyListener l1=new ValueAnimatorTests::MyListener()  ;
a1->addListener(l1);
ValueAnimatorTests::MyListener l2=new ValueAnimatorTests::MyListener()  ;
a2->addListener(l2);
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(l1->startCalled);
ASSERT_FALSE(l1->endCalled);
ASSERT_FALSE(a2->IsRunning()  );
ASSERT_FALSE(l2->startCalled);
ASSERT_FALSE(l1->endCalled);
a1->Stop();
a2->Stop();
ASSERT_TRUE(l1->startCalled);
ASSERT_TRUE(l1->endCalled);
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_TRUE(l1->endTime >= l1->startTime);
ASSERT_TRUE(l2->startCalled);
ASSERT_TRUE(l2->endCalled);
ASSERT_FALSE(a2->IsRunning()  );
ASSERT_TRUE(l2->endTime >= l1->startTime);
mActivityRule->runOnUiThread(new Runnable(){void run() { ValueAnimatorTests::MyListener l1=new ValueAnimatorTests::MyListener()  ;a1->addListener(l1);ValueAnimatorTests::MyListener l2=new ValueAnimatorTests::MyListener()  ;a2->addListener(l2);ASSERT_FALSE(a1->IsRunning()  );ASSERT_FALSE(l1->startCalled);ASSERT_FALSE(l1->endCalled);ASSERT_FALSE(a2->IsRunning()  );ASSERT_FALSE(l2->startCalled);ASSERT_FALSE(l1->endCalled);a1->Stop();a2->Stop();ASSERT_TRUE(l1->startCalled);ASSERT_TRUE(l1->endCalled);ASSERT_FALSE(a1->IsRunning()  );ASSERT_TRUE(l1->endTime >= l1->startTime);ASSERT_TRUE(l2->startCalled);ASSERT_TRUE(l2->endCalled);ASSERT_FALSE(a2->IsRunning()  );ASSERT_TRUE(l2->endTime >= l1->startTime); }}  );
a1->setDuration(0  );
a2->setDuration(0  );
ACE_EXPORTAnimator *  a3=ValueAnimator->ofInt(0  ,100  )  ;
a3->setDuration(0  );
a3->setCurrentFraction(1.0f  );
ASSERT_EQ(1.0f  ,a3->getAnimatedFraction()  );
ValueAnimatorTests::MyListener l1=new ValueAnimatorTests::MyListener()  ;
ValueAnimatorTests::MyListener l2=new ValueAnimatorTests::MyListener()  ;
ValueAnimatorTests::MyListener l3=new ValueAnimatorTests::MyListener()  ;
a1->addListener(l1);
a2->addListener(l2);
a3->addListener(l3);
ASSERT_FALSE(l1->startCalled);
ASSERT_FALSE(l2->startCalled);
ASSERT_FALSE(l3->startCalled);
ASSERT_FALSE(l1->endCalled);
ASSERT_FALSE(l2->endCalled);
ASSERT_FALSE(l3->endCalled);
a1->Play();
a2->reverse();
a3->Play();
ASSERT_EQ(A1_END_VALUE,a1->getAnimatedValue()  );
ASSERT_EQ(A2_START_VALUE,a2->getAnimatedValue()  );
ASSERT_FALSE(l1->startCalled);
ASSERT_FALSE(l2->startCalled);
ASSERT_FALSE(l3->startCalled);
ASSERT_FALSE(l1->endCalled);
ASSERT_FALSE(l2->endCalled);
ASSERT_FALSE(l3->endCalled);
a1->Play();
a2->reverse();
a3->Play();
ASSERT_EQ(A1_END_VALUE,a1->getAnimatedValue()  );
ASSERT_EQ(A2_START_VALUE,a2->getAnimatedValue()  );
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_FALSE(l1->startCalled);ASSERT_FALSE(l2->startCalled);ASSERT_FALSE(l3->startCalled);ASSERT_FALSE(l1->endCalled);ASSERT_FALSE(l2->endCalled);ASSERT_FALSE(l3->endCalled);a1->Play();a2->reverse();a3->Play();ASSERT_EQ(A1_END_VALUE,a1->getAnimatedValue()  );ASSERT_EQ(A2_START_VALUE,a2->getAnimatedValue()  ); }}  );
Thread->sleep(POLL_INTERVAL);
ASSERT_TRUE(l1->startCalled);
ASSERT_TRUE(l2->startCalled);
ASSERT_TRUE(l3->startCalled);
ASSERT_TRUE(l1->endCalled);
ASSERT_TRUE(l2->endCalled);
ASSERT_TRUE(l3->endCalled);
ASSERT_EQ(1.0f  ,a1->getAnimatedFraction()  );
ASSERT_EQ(0f  ,a2->getAnimatedFraction()  );
ASSERT_EQ(1f  ,a3->getAnimatedFraction()  );
ASSERT_EQ(A1_END_VALUE,a1->getAnimatedValue()  );
ASSERT_EQ(A2_START_VALUE,a2->getAnimatedValue()  );
ASSERT_EQ(100  ,a3->getAnimatedValue()  );
ASSERT_TRUE(l1->startCalled);
ASSERT_TRUE(l2->startCalled);
ASSERT_TRUE(l3->startCalled);
ASSERT_TRUE(l1->endCalled);
ASSERT_TRUE(l2->endCalled);
ASSERT_TRUE(l3->endCalled);
ASSERT_EQ(1.0f  ,a1->getAnimatedFraction()  );
ASSERT_EQ(0f  ,a2->getAnimatedFraction()  );
ASSERT_EQ(1f  ,a3->getAnimatedFraction()  );
ASSERT_EQ(A1_END_VALUE,a1->getAnimatedValue()  );
ASSERT_EQ(A2_START_VALUE,a2->getAnimatedValue()  );
ASSERT_EQ(100  ,a3->getAnimatedValue()  );
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_TRUE(l1->startCalled);ASSERT_TRUE(l2->startCalled);ASSERT_TRUE(l3->startCalled);ASSERT_TRUE(l1->endCalled);ASSERT_TRUE(l2->endCalled);ASSERT_TRUE(l3->endCalled);ASSERT_EQ(1.0f  ,a1->getAnimatedFraction()  );ASSERT_EQ(0f  ,a2->getAnimatedFraction()  );ASSERT_EQ(1f  ,a3->getAnimatedFraction()  );ASSERT_EQ(A1_END_VALUE,a1->getAnimatedValue()  );ASSERT_EQ(A2_START_VALUE,a2->getAnimatedValue()  );ASSERT_EQ(100  ,a3->getAnimatedValue()  ); }}  );
float scale=ValueAnimator->getDurationScale()  ;
ValueAnimator->setDurationScale(0f  );
a1->setStartDelay(200  );
ValueAnimatorTests::MyListener l1=new ValueAnimatorTests::MyListener()  ;
ValueAnimatorTests::MyListener l2=new ValueAnimatorTests::MyListener()  ;
a1->addListener(l1);
a2->addListener(l2);
ASSERT_FALSE(l1->startCalled);
ASSERT_FALSE(l2->startCalled);
ASSERT_FALSE(l1->endCalled);
ASSERT_FALSE(l2->endCalled);
a1->Play();
a2->Play();
ASSERT_EQ(A2_START_VALUE,a2->getAnimatedValue()  );
ASSERT_FALSE(l1->startCalled);
ASSERT_FALSE(l2->startCalled);
ASSERT_FALSE(l1->endCalled);
ASSERT_FALSE(l2->endCalled);
a1->Play();
a2->Play();
ASSERT_EQ(A2_START_VALUE,a2->getAnimatedValue()  );
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_FALSE(l1->startCalled);ASSERT_FALSE(l2->startCalled);ASSERT_FALSE(l1->endCalled);ASSERT_FALSE(l2->endCalled);a1->Play();a2->Play();ASSERT_EQ(A2_START_VALUE,a2->getAnimatedValue()  ); }}  );
Thread->sleep(POLL_INTERVAL);
ASSERT_TRUE(l1->startCalled);
ASSERT_TRUE(l2->startCalled);
ASSERT_TRUE(l1->endCalled);
ASSERT_TRUE(l2->endCalled);
ASSERT_EQ(A1_END_VALUE,a1->getAnimatedValue()  );
ASSERT_EQ(A2_END_VALUE,a2->getAnimatedValue()  );
ASSERT_TRUE(l1->startCalled);
ASSERT_TRUE(l2->startCalled);
ASSERT_TRUE(l1->endCalled);
ASSERT_TRUE(l2->endCalled);
ASSERT_EQ(A1_END_VALUE,a1->getAnimatedValue()  );
ASSERT_EQ(A2_END_VALUE,a2->getAnimatedValue()  );
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_TRUE(l1->startCalled);ASSERT_TRUE(l2->startCalled);ASSERT_TRUE(l1->endCalled);ASSERT_TRUE(l2->endCalled);ASSERT_EQ(A1_END_VALUE,a1->getAnimatedValue()  );ASSERT_EQ(A2_END_VALUE,a2->getAnimatedValue()  ); }}  );
ValueAnimator->setDurationScale(scale);
ACE_EXPORTAnimator *  a3=ValueAnimator->ofInt(0  ,100  )  ;
a1->setDuration(400  );
a2->setDuration(600  );
a3->setDuration(400  );
ValueAnimatorTests::MyListener l1=new ValueAnimatorTests::MyListener()  ;
ValueAnimatorTests::MyListener l2=new ValueAnimatorTests::MyListener()  ;
ValueAnimatorTests::MyListener l3=new ValueAnimatorTests::MyListener()  ;
a1->addListener(l1);
a2->addListener(l2);
a3->addListener(l3);
ASSERT_FALSE(l1->startCalled);
ASSERT_FALSE(l2->startCalled);
ASSERT_FALSE(l3->startCalled);
ASSERT_FALSE(l1->endCalled);
ASSERT_FALSE(l2->endCalled);
ASSERT_FALSE(l3->endCalled);
a1->reverse();
a2->reverse();
a3->reverse();
ASSERT_FALSE(l1->startCalled);
ASSERT_FALSE(l2->startCalled);
ASSERT_FALSE(l3->startCalled);
ASSERT_FALSE(l1->endCalled);
ASSERT_FALSE(l2->endCalled);
ASSERT_FALSE(l3->endCalled);
a1->reverse();
a2->reverse();
a3->reverse();
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_FALSE(l1->startCalled);ASSERT_FALSE(l2->startCalled);ASSERT_FALSE(l3->startCalled);ASSERT_FALSE(l1->endCalled);ASSERT_FALSE(l2->endCalled);ASSERT_FALSE(l3->endCalled);a1->reverse();a2->reverse();a3->reverse(); }}  );
Thread->sleep(POLL_INTERVAL);
ASSERT_TRUE(l1->startCalled);
ASSERT_TRUE(l2->startCalled);
ASSERT_TRUE(l3->startCalled);
a1->setCurrentFraction(0f  );
a2->setCurrentFraction(1f  );
a3->Stop();
ASSERT_EQ(1f  ,a1->getAnimatedFraction()  );
ASSERT_EQ(0f  ,a2->getAnimatedFraction()  );
ASSERT_TRUE(l1->startCalled);
ASSERT_TRUE(l2->startCalled);
ASSERT_TRUE(l3->startCalled);
a1->setCurrentFraction(0f  );
a2->setCurrentFraction(1f  );
a3->Stop();
ASSERT_EQ(1f  ,a1->getAnimatedFraction()  );
ASSERT_EQ(0f  ,a2->getAnimatedFraction()  );
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_TRUE(l1->startCalled);ASSERT_TRUE(l2->startCalled);ASSERT_TRUE(l3->startCalled);a1->setCurrentFraction(0f  );a2->setCurrentFraction(1f  );a3->Stop();ASSERT_EQ(1f  ,a1->getAnimatedFraction()  );ASSERT_EQ(0f  ,a2->getAnimatedFraction()  ); }}  );
Thread->sleep(POLL_INTERVAL);
ASSERT_FALSE(l1->endCalled);
ASSERT_TRUE(l2->endCalled);
ASSERT_TRUE(l3->endCalled);
ASSERT_FALSE(l1->endCalled);
ASSERT_TRUE(l2->endCalled);
ASSERT_TRUE(l3->endCalled);
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_FALSE(l1->endCalled);ASSERT_TRUE(l2->endCalled);ASSERT_TRUE(l3->endCalled); }}  );
Thread->sleep(a1->getTotalDuration()  );
ASSERT_TRUE(l1->endCalled);
ASSERT_EQ(0f  ,a1->getAnimatedFraction()  );
ASSERT_EQ(0f  ,a2->getAnimatedFraction()  );
ASSERT_EQ(0f  ,a3->getAnimatedFraction()  );
ASSERT_TRUE(l1->endCalled);
ASSERT_EQ(0f  ,a1->getAnimatedFraction()  );
ASSERT_EQ(0f  ,a2->getAnimatedFraction()  );
ASSERT_EQ(0f  ,a3->getAnimatedFraction()  );
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_TRUE(l1->endCalled);ASSERT_EQ(0f  ,a1->getAnimatedFraction()  );ASSERT_EQ(0f  ,a2->getAnimatedFraction()  );ASSERT_EQ(0f  ,a3->getAnimatedFraction()  ); }}  );
}
//以下组件没有匹配:
//Runnable
void run()
{
lastUpdateTime=SystemClock->uptimeMillis()  ;
firstRunningFrameTime=lastUpdateTime;
startFraction=animation->getAnimatedFraction()  ;
wasRunning=animation->isRunning()  ;
if(animation->isRunning()   && !wasRunning){ firstRunningFrameTime=lastUpdateTime;startFraction=animation->getAnimatedFraction()  ;wasRunning=animation->isRunning()  ; }
wasRunning=false  ;
firstRunningFrameTime=-1  ;
lastUpdateTime=-1  ;
startFraction=0  ;
startCalled=true  ;
startTime=SystemClock->uptimeMillis()  ;
endCalled=true  ;
endTime=SystemClock->uptimeMillis()  ;
cancelCalled=true  ;
pauseCalled=true  ;
resumeCalled=true  ;
mHandler->sendEmptyMessageDelayed(MSG_FRAME,mFrameDelay);
mFrameCallbacks->add(callback);
if(!mFrameCallbacks->contains(callback)  ){ mFrameCallbacks->add(callback); }
mHandler->postDelayed(runnable,COMMIT_DELAY);
return SystemClock->uptimeMillis()  ;
return mFrameDelay;
mFrameDelay=delay;
mHandler->removeMessages(MSG_FRAME);
mHandler->sendEmptyMessageDelayed(MSG_FRAME,mFrameDelay);
if(mFrameCallbacks->size()   != 0  ){ mHandler->removeMessages(MSG_FRAME);mHandler->sendEmptyMessageDelayed(MSG_FRAME,mFrameDelay); }
Looper->prepare();
mFrameCallbacks->get(i)  -> doFrame(SystemClock->uptimeMillis()  );
for(int i=0  ;i < mFrameCallbacks->size()  ;i++){ mFrameCallbacks->get(i)  -> doFrame(SystemClock->uptimeMillis()  ); }
break;
break;
switch(msg->what){caseMSG_FRAME: for(int i=0  ;i < mFrameCallbacks->size()  ;i++){ mFrameCallbacks->get(i)  -> doFrame(SystemClock->uptimeMillis()  ); }break; default: break; }
{ switch(msg->what){caseMSG_FRAME: for(int i=0  ;i < mFrameCallbacks->size()  ;i++){ mFrameCallbacks->get(i)  -> doFrame(SystemClock->uptimeMillis()  ); }break; default: break; } }
mHandler=new Handler(){void handleMessage(Message *  msg) { { switch(msg->what){caseMSG_FRAME: for(int i=0  ;i < mFrameCallbacks->size()  ;i++){ mFrameCallbacks->get(i)  -> doFrame(SystemClock->uptimeMillis()  ); }break; default: break; } } }}  ;
Looper->loop();
a1=ValueAnimator->ofFloat(A1_START_VALUE,A1_END_VALUE)  -> setDuration(300  );
a2=ValueAnimator->ofInt(A2_START_VALUE,A2_END_VALUE)  -> setDuration(500  );
a1=null  ;
a2=null  ;
ACE_EXPORTAnimator *  a=ValueAnimator->ofFloat(5f  ,20f  )  ;
ASSERT_EQ(a->getStartDelay()  ,0  );
long delay=200  ;
a->setStartDelay(delay);
ASSERT_EQ(a->getStartDelay()  ,delay);
ValueAnimatorTests::MyUpdateListener listener=new ValueAnimatorTests::MyUpdateListener()  ;
a->AddUpdateListener(listener);
long [] startTime= newlong[1] ;
ASSERT_FALSE(a->IsRunning()  );
ASSERT_FALSE(a->IsRunning()  );
a->Play();
startTime[0]=SystemClock->uptimeMillis()  ;
ASSERT_TRUE(a->IsRunning()  );
ASSERT_FALSE(a->IsRunning()  );
ASSERT_FALSE(a->IsRunning()  );
ASSERT_FALSE(a->IsRunning()  );
a->Play();
startTime[0]=SystemClock->uptimeMillis()  ;
ASSERT_TRUE(a->IsRunning()  );
ASSERT_FALSE(a->IsRunning()  );
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_FALSE(a->IsRunning()  );ASSERT_FALSE(a->IsRunning()  );a->Play();startTime[0]=SystemClock->uptimeMillis()  ;ASSERT_TRUE(a->IsRunning()  );ASSERT_FALSE(a->IsRunning()  ); }}  );
Thread->sleep(a->getTotalDuration()  );
ASSERT_TRUE(listener->wasRunning);
ASSERT_TRUE(listener->firstRunningFrameTime - startTime[0]   >= delay);
ASSERT_TRUE(listener->wasRunning);
ASSERT_TRUE(listener->firstRunningFrameTime - startTime[0]   >= delay);
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_TRUE(listener->wasRunning);ASSERT_TRUE(listener->firstRunningFrameTime - startTime[0]   >= delay); }}  );
Thread->sleep(a->getTotalDuration()  );
ASSERT_FALSE(a->IsRunning()  );
ASSERT_FALSE(a->IsRunning()  );
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_FALSE(a->IsRunning()  ); }}  );
ValueAnimatorTests::MyListener l1=new ValueAnimatorTests::MyListener()  ;
ValueAnimatorTests::MyListener l2=new ValueAnimatorTests::MyListener()  ;
a1->addListener(l1);
a2->addListener(l2);
a2->setStartDelay(400  );
ASSERT_FALSE(l1->startCalled);
ASSERT_FALSE(l1->cancelCalled);
ASSERT_FALSE(l1->endCalled);
ASSERT_FALSE(l2->startCalled);
ASSERT_FALSE(l2->cancelCalled);
ASSERT_FALSE(l2->endCalled);
a1->Play();
a2->Play();
a1->Play();
a2->Play();
mActivityRule->runOnUiThread(new Runnable(){void run() { a1->Play();a2->Play(); }}  );
long wait=0  ;
Thread->sleep(POLL_INTERVAL);
wait+=POLL_INTERVAL;
ASSERT_FALSE(l1->cancelCalled);
a1->cancel();
ASSERT_TRUE(l1->cancelCalled);
ASSERT_TRUE(l1->endCalled);
ASSERT_FALSE(l1->cancelCalled);
a1->cancel();
ASSERT_TRUE(l1->cancelCalled);
ASSERT_TRUE(l1->endCalled);
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_FALSE(l1->cancelCalled);a1->cancel();ASSERT_TRUE(l1->cancelCalled);ASSERT_TRUE(l1->endCalled); }}  );
ASSERT_TRUE(l1->startCalled);
ASSERT_FALSE(l2->startCalled);
ASSERT_TRUE(l1->startCalled);
ASSERT_FALSE(l2->startCalled);
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_TRUE(l1->startCalled);ASSERT_FALSE(l2->startCalled); }}  );
Thread->sleep(POLL_INTERVAL);
wait+=POLL_INTERVAL;
while(wait < a2->getStartDelay()  ){ mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_TRUE(l1->startCalled);ASSERT_FALSE(l2->startCalled); }}  );Thread->sleep(POLL_INTERVAL);wait+=POLL_INTERVAL; }
long delay=Math->max(a1->getTotalDuration()  ,a2->getTotalDuration()  )   + TOLERANCE;
Thread->sleep(delay);
ASSERT_TRUE(l1->startCalled);
ASSERT_TRUE(l1->cancelCalled);
ASSERT_TRUE(l1->endCalled);
ASSERT_TRUE(l2->startCalled);
ASSERT_FALSE(l2->cancelCalled);
ASSERT_TRUE(l2->endCalled);
ASSERT_TRUE(l1->startCalled);
ASSERT_TRUE(l1->cancelCalled);
ASSERT_TRUE(l1->endCalled);
ASSERT_TRUE(l2->startCalled);
ASSERT_FALSE(l2->cancelCalled);
ASSERT_TRUE(l2->endCalled);
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_TRUE(l1->startCalled);ASSERT_TRUE(l1->cancelCalled);ASSERT_TRUE(l1->endCalled);ASSERT_TRUE(l2->startCalled);ASSERT_FALSE(l2->cancelCalled);ASSERT_TRUE(l2->endCalled); }}  );
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a2->IsRunning()  );
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a2->IsRunning()  );
long startDelay=150  ;
a1->setStartDelay(startDelay);
long [] startTime= newlong[1] ;
a1->Play();
a2->Play();
startTime[0]=SystemClock->uptimeMillis()  ;
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a2->IsRunning()  );
a1->Play();
a2->Play();
startTime[0]=SystemClock->uptimeMillis()  ;
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a2->IsRunning()  );
mActivityRule->runOnUiThread(new Runnable(){void run() { a1->Play();a2->Play();startTime[0]=SystemClock->uptimeMillis()  ;ASSERT_TRUE(a1->IsRunning()  );ASSERT_TRUE(a2->IsRunning()  ); }}  );
long delayMs=0  ;
Thread->sleep(POLL_INTERVAL);
delayMs+=POLL_INTERVAL;
ASSERT_FALSE(a1->IsRunning()  );
if(SystemClock->uptimeMillis()   - startTime[0]   < startDelay){ ASSERT_FALSE(a1->IsRunning()  ); }
ASSERT_FALSE(a1->IsRunning()  );
if(SystemClock->uptimeMillis()   - startTime[0]   < startDelay){ ASSERT_FALSE(a1->IsRunning()  ); }
mActivityRule->runOnUiThread(new Runnable(){void run() { if(SystemClock->uptimeMillis()   - startTime[0]   < startDelay){ ASSERT_FALSE(a1->IsRunning()  ); } }}  );
while(delayMs < startDelay){ Thread->sleep(POLL_INTERVAL);delayMs+=POLL_INTERVAL;mActivityRule->runOnUiThread(new Runnable(){void run() { if(SystemClock->uptimeMillis()   - startTime[0]   < startDelay){ ASSERT_FALSE(a1->IsRunning()  ); } }}  ); }
Thread->sleep(startDelay);
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a2->IsRunning()  );
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a2->IsRunning()  );
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_TRUE(a1->IsRunning()  );ASSERT_TRUE(a2->IsRunning()  ); }}  );
long delay=Math->max(a1->getTotalDuration()  ,a2->getTotalDuration()  )   * 2  ;
Thread->sleep(delay);
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a2->IsRunning()  );
ASSERT_FALSE(a2->IsRunning()  );
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a2->IsRunning()  );
ASSERT_FALSE(a2->IsRunning()  );
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_FALSE(a1->IsRunning()  );ASSERT_FALSE(a1->IsRunning()  );ASSERT_FALSE(a2->IsRunning()  );ASSERT_FALSE(a2->IsRunning()  ); }}  );
ASSERT_FALSE(a1->IsPending()  );
ASSERT_FALSE(a2->IsPending()  );
a1->Play();
a2->Play();
ASSERT_FALSE(a1->IsPending()  );
ASSERT_FALSE(a2->IsPending()  );
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a2->IsRunning()  );
ASSERT_FALSE(a1->IsPending()  );
ASSERT_FALSE(a2->IsPending()  );
a1->Play();
a2->Play();
ASSERT_FALSE(a1->IsPending()  );
ASSERT_FALSE(a2->IsPending()  );
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a2->IsRunning()  );
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_FALSE(a1->IsPending()  );ASSERT_FALSE(a2->IsPending()  );a1->Play();a2->Play();ASSERT_FALSE(a1->IsPending()  );ASSERT_FALSE(a2->IsPending()  );ASSERT_TRUE(a1->IsRunning()  );ASSERT_TRUE(a2->IsRunning()  ); }}  );
Thread->sleep(POLL_INTERVAL);
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a2->IsRunning()  );
a1->Pause();
ASSERT_TRUE(a1->IsPending()  );
ASSERT_FALSE(a2->IsPending()  );
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a2->IsRunning()  );
a1->Pause();
ASSERT_TRUE(a1->IsPending()  );
ASSERT_FALSE(a2->IsPending()  );
ASSERT_TRUE(a1->IsRunning()  );
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_TRUE(a1->IsRunning()  );ASSERT_TRUE(a2->IsRunning()  );a1->Pause();ASSERT_TRUE(a1->IsPending()  );ASSERT_FALSE(a2->IsPending()  );ASSERT_TRUE(a1->IsRunning()  ); }}  );
Thread->sleep(a2->getTotalDuration()  );
ASSERT_FALSE(a2->IsRunning()  );
ASSERT_FALSE(a2->IsRunning()  );
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a1->IsPending()  );
a1->resume();
ASSERT_FALSE(a2->IsRunning()  );
ASSERT_FALSE(a2->IsRunning()  );
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a1->IsPending()  );
a1->resume();
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_FALSE(a2->IsRunning()  );ASSERT_FALSE(a2->IsRunning()  );ASSERT_TRUE(a1->IsRunning()  );ASSERT_TRUE(a1->IsRunning()  );ASSERT_TRUE(a1->IsPending()  );a1->resume(); }}  );
Thread->sleep(POLL_INTERVAL);
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_FALSE(a1->IsPending()  );
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_FALSE(a1->IsPending()  );
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_TRUE(a1->IsRunning()  );ASSERT_TRUE(a1->IsRunning()  );ASSERT_FALSE(a1->IsPending()  ); }}  );
Thread->sleep(a1->getTotalDuration()  );
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a1->IsPending()  );
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a1->IsPending()  );
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_FALSE(a1->IsRunning()  );ASSERT_FALSE(a1->IsRunning()  );ASSERT_FALSE(a1->IsPending()  ); }}  );
ValueAnimatorTests::MyPauseListener l1=new ValueAnimatorTests::MyPauseListener()  ;
ValueAnimatorTests::MyPauseListener l2=new ValueAnimatorTests::MyPauseListener()  ;
a1->addPauseListener(l1);
a2->addPauseListener(l2);
ASSERT_FALSE(l1->pauseCalled);
ASSERT_FALSE(l1->resumeCalled);
ASSERT_FALSE(l2->pauseCalled);
ASSERT_FALSE(l2->resumeCalled);
a1->Play();
a2->Play();
a1->Play();
a2->Play();
mActivityRule->runOnUiThread(new Runnable(){void run() { a1->Play();a2->Play(); }}  );
Thread->sleep(a1->getTotalDuration()   / 2  );
a1->Pause();
Thread->sleep(a2->getTotalDuration()  );
ASSERT_TRUE(l1->pauseCalled);
ASSERT_FALSE(l1->resumeCalled);
a1->resume();
a1->resume();
mActivityRule->runOnUiThread(new Runnable(){void run() { a1->resume(); }}  );
Thread->sleep(a1->getTotalDuration()  );
ASSERT_TRUE(l1->pauseCalled);
ASSERT_TRUE(l1->resumeCalled);
ASSERT_FALSE(l2->pauseCalled);
ASSERT_FALSE(l2->resumeCalled);
ValueAnimatorTests::MyUpdateListener l1=new ValueAnimatorTests::MyUpdateListener()  ;
long totalDuration=a1->getTotalDuration()  ;
a1->AddUpdateListener(l1);
a1->setDuration(1000  );
ASSERT_TRUE(l1->firstRunningFrameTime < 0  );
ASSERT_TRUE(l1->lastUpdateTime < 0  );
long [] lastUpdate= newlong[1] ;
a1->Play();
a1->Play();
mActivityRule->runOnUiThread(new Runnable(){void run() { a1->Play(); }}  );
Thread->sleep(totalDuration / 2  );
ASSERT_TRUE(l1->firstRunningFrameTime > 0  );
ASSERT_TRUE(l1->lastUpdateTime > l1->firstRunningFrameTime);
lastUpdate[0]=l1->lastUpdateTime;
a1->Pause();
ASSERT_TRUE(l1->firstRunningFrameTime > 0  );
ASSERT_TRUE(l1->lastUpdateTime > l1->firstRunningFrameTime);
lastUpdate[0]=l1->lastUpdateTime;
a1->Pause();
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_TRUE(l1->firstRunningFrameTime > 0  );ASSERT_TRUE(l1->lastUpdateTime > l1->firstRunningFrameTime);lastUpdate[0]=l1->lastUpdateTime;a1->Pause(); }}  );
Thread->sleep(totalDuration);
ASSERT_EQ(lastUpdate[0]  ,l1->lastUpdateTime);
a1->resume();
ASSERT_EQ(lastUpdate[0]  ,l1->lastUpdateTime);
a1->resume();
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_EQ(lastUpdate[0]  ,l1->lastUpdateTime);a1->resume(); }}  );
Thread->sleep(POLL_INTERVAL);
ASSERT_TRUE(l1->lastUpdateTime > lastUpdate[0]  );
lastUpdate[0]=l1->lastUpdateTime;
ASSERT_TRUE(l1->lastUpdateTime > lastUpdate[0]  );
lastUpdate[0]=l1->lastUpdateTime;
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_TRUE(l1->lastUpdateTime > lastUpdate[0]  );lastUpdate[0]=l1->lastUpdateTime; }}  );
do{ Thread->sleep(POLL_INTERVAL);mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_TRUE(l1->lastUpdateTime > lastUpdate[0]  );lastUpdate[0]=l1->lastUpdateTime; }}  ); }while(!a1->IsRunning()  );
long entireSpan=totalDuration * 2  ;
long frameDelta=l1->lastUpdateTime - l1->firstRunningFrameTime;
ASSERT_TRUE(Math->abs(entireSpan - frameDelta)   < TOLERANCE);
ValueAnimatorTests::MyListener l1=new ValueAnimatorTests::MyListener()  ;
ValueAnimatorTests::MyListener l2=new ValueAnimatorTests::MyListener()  ;
a1->addListener(l1);
a2->addListener(l2);
anim->Cancel();
anim->Cancel();
a1->addListener(new ValueAnimatorTests::MyListener(){void onAnimationEnd(ACE_EXPORTAnimator *  anim) { anim->Cancel(); }}  );
anim->end();
anim->end();
a2->addListener(new ValueAnimatorTests::MyListener(){void onAnimationCancel(ACE_EXPORTAnimator *  anim) { anim->end(); }}  );
ASSERT_FALSE(l1->cancelCalled);
ASSERT_FALSE(l1->endCalled);
ASSERT_FALSE(l2->cancelCalled);
ASSERT_FALSE(l2->endCalled);
a1->Play();
a2->Play();
ASSERT_FALSE(l1->cancelCalled);
ASSERT_FALSE(l1->endCalled);
ASSERT_FALSE(l2->cancelCalled);
ASSERT_FALSE(l2->endCalled);
a1->Play();
a2->Play();
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_FALSE(l1->cancelCalled);ASSERT_FALSE(l1->endCalled);ASSERT_FALSE(l2->cancelCalled);ASSERT_FALSE(l2->endCalled);a1->Play();a2->Play(); }}  );
Thread->sleep(POLL_INTERVAL);
a1->Stop();
a2->cancel();
a1->Stop();
a2->cancel();
mActivityRule->runOnUiThread(new Runnable(){void run() { a1->Stop();a2->cancel(); }}  );
Thread->sleep(POLL_INTERVAL);
ASSERT_FALSE(l1->cancelCalled);
ASSERT_TRUE(l1->endCalled);
ASSERT_TRUE(l2->cancelCalled);
ASSERT_TRUE(l2->endCalled);
float value1=(Float)a1.getAnimatedValue();
int value2=(Integer)a2.getAnimatedValue();
ASSERT_EQ(A1_END_VALUE,value1);
ASSERT_EQ(A2_END_VALUE,value2);
ASSERT_FALSE(l1->cancelCalled);
ASSERT_TRUE(l1->endCalled);
ASSERT_TRUE(l2->cancelCalled);
ASSERT_TRUE(l2->endCalled);
float value1=(Float)a1.getAnimatedValue();
int value2=(Integer)a2.getAnimatedValue();
ASSERT_EQ(A1_END_VALUE,value1);
ASSERT_EQ(A2_END_VALUE,value2);
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_FALSE(l1->cancelCalled);ASSERT_TRUE(l1->endCalled);ASSERT_TRUE(l2->cancelCalled);ASSERT_TRUE(l2->endCalled);float value1=(Float)a1.getAnimatedValue();int value2=(Integer)a2.getAnimatedValue();ASSERT_EQ(A1_END_VALUE,value1);ASSERT_EQ(A2_END_VALUE,value2); }}  );
ValueAnimatorTests::MyListener l1=new ValueAnimatorTests::MyListener()  ;
a1->addListener(l1);
ValueAnimatorTests::MyListener l2=new ValueAnimatorTests::MyListener()  ;
a2->addListener(l2);
a1->Play();
a2->Play();
a1->Play();
a2->Play();
mActivityRule->runOnUiThread(new Runnable(){void run() { a1->Play();a2->Play(); }}  );
Thread->sleep(POLL_INTERVAL);
ASSERT_FALSE(l1->endCalled);
ASSERT_FALSE(l2->endCalled);
assertNotEqual(A1_END_VALUE,a1->getAnimatedValue()  );
assertNotEqual(A1_END_VALUE,a2->getAnimatedValue()  );
a2->Stop();
ASSERT_FALSE(l1->endCalled);
ASSERT_FALSE(l2->endCalled);
assertNotEqual(A1_END_VALUE,a1->getAnimatedValue()  );
assertNotEqual(A1_END_VALUE,a2->getAnimatedValue()  );
a2->Stop();
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_FALSE(l1->endCalled);ASSERT_FALSE(l2->endCalled);assertNotEqual(A1_END_VALUE,a1->getAnimatedValue()  );assertNotEqual(A1_END_VALUE,a2->getAnimatedValue()  );a2->Stop(); }}  );
Thread->sleep(a1->getTotalDuration()  );
ASSERT_FALSE(l1->cancelCalled);
ASSERT_TRUE(l1->endCalled);
ASSERT_FALSE(l2->cancelCalled);
ASSERT_TRUE(l2->endCalled);
ASSERT_EQ(A1_END_VALUE,((Float)(a1.getAnimatedValue()))  -> floatValue());
ASSERT_EQ(A2_END_VALUE,((Integer)(a2.getAnimatedValue()))  -> intValue());
ASSERT_FALSE(l1->cancelCalled);
ASSERT_TRUE(l1->endCalled);
ASSERT_FALSE(l2->cancelCalled);
ASSERT_TRUE(l2->endCalled);
ASSERT_EQ(A1_END_VALUE,((Float)(a1.getAnimatedValue()))  -> floatValue());
ASSERT_EQ(A2_END_VALUE,((Integer)(a2.getAnimatedValue()))  -> intValue());
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_FALSE(l1->cancelCalled);ASSERT_TRUE(l1->endCalled);ASSERT_FALSE(l2->cancelCalled);ASSERT_TRUE(l2->endCalled);ASSERT_EQ(A1_END_VALUE,((Float)(a1.getAnimatedValue()))  -> floatValue());ASSERT_EQ(A2_END_VALUE,((Integer)(a2.getAnimatedValue()))  -> intValue()); }}  );
ValueAnimatorTests::MyFrameCallbackProvider provider=new ValueAnimatorTests::MyFrameCallbackProvider()  ;
long sleep=0  ;
Thread->sleep(POLL_INTERVAL);
sleep+=POLL_INTERVAL;
break;
if(sleep > WAIT_TIME_OUT){ break; }
while(provider->mHandler == null  ){ Thread->sleep(POLL_INTERVAL);sleep+=POLL_INTERVAL;if(sleep > WAIT_TIME_OUT){ break; } }
assertNotNull(provider->mHandler);
ValueAnimatorTests::MyListener listener=new ValueAnimatorTests::MyListener()  ;
long currentTime=SystemClock->uptimeMillis()  ;
long frameDelay=provider->getFrameDelay()  ;
ASSERT_TRUE((currentTime-lastUpdateTime)   < frameDelay * 4  );
ASSERT_TRUE(listener->startCalled);
ASSERT_TRUE(listener->startTime > 0  );
ASSERT_TRUE(currentTime - listener->startTime < frameDelay * 4  );
if(lastUpdateTime > 0  ){ ASSERT_TRUE((currentTime-lastUpdateTime)   < frameDelay * 4  ); }else{ ASSERT_TRUE(listener->startCalled);ASSERT_TRUE(listener->startTime > 0  );ASSERT_TRUE(currentTime - listener->startTime < frameDelay * 4  ); }
super-> onAnimationUpdate(animation);
ValueAnimatorTests::MyUpdateListener l1=new ValueAnimatorTests::MyUpdateListener(){void onAnimationUpdate(ACE_EXPORTAnimator *  animation) { long currentTime=SystemClock->uptimeMillis()  ;long frameDelay=provider->getFrameDelay()  ;if(lastUpdateTime > 0  ){ ASSERT_TRUE((currentTime-lastUpdateTime)   < frameDelay * 4  ); }else{ ASSERT_TRUE(listener->startCalled);ASSERT_TRUE(listener->startTime > 0  );ASSERT_TRUE(currentTime - listener->startTime < frameDelay * 4  ); }super-> onAnimationUpdate(animation); }}  ;
a1->AddUpdateListener(l1);
a1->addListener(listener);
a1->setStartDelay(100  );
AnimationHandler->getInstance()  -> setProvider(provider);
a1->Play();
AnimationHandler->getInstance()  -> setProvider(provider);
a1->Play();
provider.mHandler->post(new Runnable(){void run() { AnimationHandler->getInstance()  -> setProvider(provider);a1->Play(); }}  );
Thread->sleep(POLL_INTERVAL);
ASSERT_TRUE(a1->IsRunning()  );
Thread->sleep(a1->getTotalDuration()   + TOLERANCE);
throwprovider->mAssertionError;
if(provider->mAssertionError != null  ){ throwprovider->mAssertionError; }
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_TRUE(listener->endTime > 0  );
ASSERT_TRUE(listener->endTime >= l1->lastUpdateTime);
ASSERT_TRUE(listener->endTime - l1->lastUpdateTime < 2   * provider->getFrameDelay()  );
ACE_EXPORTAnimator *  a0=ValueAnimator->ofInt(100  ,200  )  -> setDuration(500  );
ACE_EXPORTAnimator *  a3=ValueAnimator->ofFloat(0  ,1  )  -> setDuration(500  );
ACE_EXPORTAnimator *  a4=ValueAnimator->ofInt(200  ,300  )  -> setDuration(500  );
super-> onAnimationEnd(anim);
a0->cancel();
a1->Stop();
a3->Stop();
a4->cancel();
ValueAnimatorTests::MyListener listener=new ValueAnimatorTests::MyListener(){void onAnimationEnd(ACE_EXPORTAnimator *  anim) { super-> onAnimationEnd(anim);a0->cancel();a1->Stop();a3->Stop();a4->cancel(); }}  ;
a2->addListener(listener);
a0->Play();
a1->Play();
a2->Play();
a3->Play();
a4->Play();
a0->Play();
a1->Play();
a2->Play();
a3->Play();
a4->Play();
mActivityRule->runOnUiThread(new Runnable(){void run() { a0->Play();a1->Play();a2->Play();a3->Play();a4->Play(); }}  );
ASSERT_TRUE(a0->IsRunning()  );
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a2->IsRunning()  );
ASSERT_TRUE(a3->IsRunning()  );
ASSERT_TRUE(a4->IsRunning()  );
ASSERT_TRUE(a0->IsRunning()  );
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a2->IsRunning()  );
ASSERT_TRUE(a3->IsRunning()  );
ASSERT_TRUE(a4->IsRunning()  );
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_TRUE(a0->IsRunning()  );ASSERT_TRUE(a1->IsRunning()  );ASSERT_TRUE(a2->IsRunning()  );ASSERT_TRUE(a3->IsRunning()  );ASSERT_TRUE(a4->IsRunning()  ); }}  );
Thread->sleep(POLL_INTERVAL);
a2->Stop();
a2->Stop();
mActivityRule->runOnUiThread(new Runnable(){void run() { a2->Stop(); }}  );
Thread->sleep(POLL_INTERVAL);
ASSERT_TRUE(listener->endCalled);
ASSERT_FALSE(a0->IsRunning()  );
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a2->IsRunning()  );
ASSERT_FALSE(a3->IsRunning()  );
ASSERT_FALSE(a4->IsRunning()  );
ValueAnimatorTests::MyListener l1=new ValueAnimatorTests::MyListener()  ;
ValueAnimatorTests::MyListener l2=new ValueAnimatorTests::MyListener()  ;
ValueAnimatorTests::MyUpdateListener updateListener1=new ValueAnimatorTests::MyUpdateListener()  ;
ValueAnimatorTests::MyUpdateListener updateListener2=new ValueAnimatorTests::MyUpdateListener()  ;
float a1StartFraction=0.2f  ;
float a2StartFraction=0.3f  ;
a1->setDuration(1000  );
a2->setDuration(1000  );
a1->addListener(l1);
a2->addListener(l2);
a1->AddUpdateListener(updateListener1);
a2->AddUpdateListener(updateListener2);
//以下组件没有匹配:
//TimeInterpolator,LinearInterpolator
TimeInterpolator *  interpolator=new LinearInterpolator()  ;
a1->setInterpolator(interpolator);
a2->setInterpolator(interpolator);
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a2->IsRunning()  );
ASSERT_FALSE(a2->IsRunning()  );
a1->setCurrentFraction(a1StartFraction);
a2->setCurrentFraction(a2StartFraction);
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a2->IsRunning()  );
ASSERT_FALSE(a2->IsRunning()  );
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a2->IsRunning()  );
ASSERT_FALSE(a2->IsRunning()  );
a1->setCurrentFraction(a1StartFraction);
a2->setCurrentFraction(a2StartFraction);
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a2->IsRunning()  );
ASSERT_FALSE(a2->IsRunning()  );
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_FALSE(a1->IsRunning()  );ASSERT_FALSE(a1->IsRunning()  );ASSERT_FALSE(a2->IsRunning()  );ASSERT_FALSE(a2->IsRunning()  );a1->setCurrentFraction(a1StartFraction);a2->setCurrentFraction(a2StartFraction);ASSERT_FALSE(a1->IsRunning()  );ASSERT_FALSE(a1->IsRunning()  );ASSERT_FALSE(a2->IsRunning()  );ASSERT_FALSE(a2->IsRunning()  ); }}  );
Thread->sleep(POLL_INTERVAL);
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a2->IsRunning()  );
ASSERT_FALSE(a2->IsRunning()  );
ASSERT_EQ(a1StartFraction,a1->getAnimatedFraction()  );
ASSERT_EQ(a2StartFraction,a2->getAnimatedFraction()  );
a1->Play();
a2->Play();
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a2->IsRunning()  );
ASSERT_FALSE(a2->IsRunning()  );
ASSERT_EQ(a1StartFraction,a1->getAnimatedFraction()  );
ASSERT_EQ(a2StartFraction,a2->getAnimatedFraction()  );
a1->Play();
a2->Play();
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_FALSE(a1->IsRunning()  );ASSERT_FALSE(a1->IsRunning()  );ASSERT_FALSE(a2->IsRunning()  );ASSERT_FALSE(a2->IsRunning()  );ASSERT_EQ(a1StartFraction,a1->getAnimatedFraction()  );ASSERT_EQ(a2StartFraction,a2->getAnimatedFraction()  );a1->Play();a2->Play(); }}  );
Thread->sleep(POLL_INTERVAL);
float halfwayFraction=0.5f  ;
ASSERT_TRUE(l1->startCalled);
ASSERT_TRUE(l2->startCalled);
ASSERT_FALSE(l1->endCalled);
ASSERT_FALSE(l2->endCalled);
ASSERT_TRUE(updateListener1->startFraction >= a1StartFraction);
ASSERT_TRUE(updateListener2->startFraction >= a2StartFraction);
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a2->IsRunning()  );
ASSERT_TRUE(a2->IsRunning()  );
a1->setCurrentFraction(halfwayFraction);
a2->setCurrentFraction(halfwayFraction);
ASSERT_TRUE(l1->startCalled);
ASSERT_TRUE(l2->startCalled);
ASSERT_FALSE(l1->endCalled);
ASSERT_FALSE(l2->endCalled);
ASSERT_TRUE(updateListener1->startFraction >= a1StartFraction);
ASSERT_TRUE(updateListener2->startFraction >= a2StartFraction);
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a2->IsRunning()  );
ASSERT_TRUE(a2->IsRunning()  );
a1->setCurrentFraction(halfwayFraction);
a2->setCurrentFraction(halfwayFraction);
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_TRUE(l1->startCalled);ASSERT_TRUE(l2->startCalled);ASSERT_FALSE(l1->endCalled);ASSERT_FALSE(l2->endCalled);ASSERT_TRUE(updateListener1->startFraction >= a1StartFraction);ASSERT_TRUE(updateListener2->startFraction >= a2StartFraction);ASSERT_TRUE(a1->IsRunning()  );ASSERT_TRUE(a1->IsRunning()  );ASSERT_TRUE(a2->IsRunning()  );ASSERT_TRUE(a2->IsRunning()  );a1->setCurrentFraction(halfwayFraction);a2->setCurrentFraction(halfwayFraction); }}  );
Thread->sleep(POLL_INTERVAL);
ASSERT_TRUE(l1->startCalled);
ASSERT_TRUE(l2->startCalled);
ASSERT_FALSE(l1->endCalled);
ASSERT_FALSE(l2->endCalled);
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a2->IsRunning()  );
ASSERT_TRUE(a2->IsRunning()  );
ASSERT_TRUE(l1->startCalled);
ASSERT_TRUE(l2->startCalled);
ASSERT_FALSE(l1->endCalled);
ASSERT_FALSE(l2->endCalled);
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a2->IsRunning()  );
ASSERT_TRUE(a2->IsRunning()  );
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_TRUE(l1->startCalled);ASSERT_TRUE(l2->startCalled);ASSERT_FALSE(l1->endCalled);ASSERT_FALSE(l2->endCalled);ASSERT_TRUE(a1->IsRunning()  );ASSERT_TRUE(a1->IsRunning()  );ASSERT_TRUE(a2->IsRunning()  );ASSERT_TRUE(a2->IsRunning()  ); }}  );
long wait=Math->max(a1->getTotalDuration()  ,a2->getTotalDuration()  )  ;
Thread->sleep(wait);
ASSERT_TRUE(l1->endCalled);
ASSERT_TRUE(l2->endCalled);
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a2->IsRunning()  );
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a2->IsRunning()  );
ASSERT_TRUE(l1->endCalled);
ASSERT_TRUE(l2->endCalled);
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a2->IsRunning()  );
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a2->IsRunning()  );
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_TRUE(l1->endCalled);ASSERT_TRUE(l2->endCalled);ASSERT_FALSE(a1->IsRunning()  );ASSERT_FALSE(a2->IsRunning()  );ASSERT_FALSE(a1->IsRunning()  );ASSERT_FALSE(a2->IsRunning()  ); }}  );
updateListener1->reset();
a1->Play();
a1->Play();
mActivityRule->runOnUiThread(new Runnable(){void run() { a1->Play(); }}  );
Thread->sleep(POLL_INTERVAL);
ASSERT_TRUE(updateListener1->wasRunning);
ASSERT_TRUE(updateListener1->startFraction >= 0  );
ASSERT_TRUE(updateListener1->startFraction < halfwayFraction);
a1->Stop();
ASSERT_TRUE(updateListener1->wasRunning);
ASSERT_TRUE(updateListener1->startFraction >= 0  );
ASSERT_TRUE(updateListener1->startFraction < halfwayFraction);
a1->Stop();
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_TRUE(updateListener1->wasRunning);ASSERT_TRUE(updateListener1->startFraction >= 0  );ASSERT_TRUE(updateListener1->startFraction < halfwayFraction);a1->Stop(); }}  );
ValueAnimatorTests::MyListener l1=new ValueAnimatorTests::MyListener()  ;
ValueAnimatorTests::MyListener l2=new ValueAnimatorTests::MyListener()  ;
a1->addListener(l1);
a2->addListener(l2);
ASSERT_FALSE(l1->startCalled);
ASSERT_FALSE(l2->startCalled);
ASSERT_EQ(0f  ,a1->getAnimatedFraction()  );
ASSERT_EQ(0f  ,a2->getAnimatedFraction()  );
a1->Play();
a2->Play();
ASSERT_FALSE(l1->startCalled);
ASSERT_FALSE(l2->startCalled);
ASSERT_EQ(0f  ,a1->getAnimatedFraction()  );
ASSERT_EQ(0f  ,a2->getAnimatedFraction()  );
a1->Play();
a2->Play();
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_FALSE(l1->startCalled);ASSERT_FALSE(l2->startCalled);ASSERT_EQ(0f  ,a1->getAnimatedFraction()  );ASSERT_EQ(0f  ,a2->getAnimatedFraction()  );a1->Play();a2->Play(); }}  );
Thread->sleep(POLL_INTERVAL);
ASSERT_FALSE(l1->endCalled);
ASSERT_FALSE(l2->endCalled);
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a2->IsRunning()  );
a1->setCurrentFraction(0f  );
a2->setCurrentFraction(1f  );
ASSERT_FALSE(l1->endCalled);
ASSERT_FALSE(l2->endCalled);
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a2->IsRunning()  );
a1->setCurrentFraction(0f  );
a2->setCurrentFraction(1f  );
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_FALSE(l1->endCalled);ASSERT_FALSE(l2->endCalled);ASSERT_TRUE(a1->IsRunning()  );ASSERT_TRUE(a2->IsRunning()  );a1->setCurrentFraction(0f  );a2->setCurrentFraction(1f  ); }}  );
Thread->sleep(POLL_INTERVAL);
ASSERT_FALSE(l1->endCalled);
ASSERT_TRUE(l2->endCalled);
ASSERT_EQ(1f  ,a2->getAnimatedFraction()  );
ASSERT_FALSE(l1->endCalled);
ASSERT_TRUE(l2->endCalled);
ASSERT_EQ(1f  ,a2->getAnimatedFraction()  );
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_FALSE(l1->endCalled);ASSERT_TRUE(l2->endCalled);ASSERT_EQ(1f  ,a2->getAnimatedFraction()  ); }}  );
Thread->sleep(a1->getTotalDuration()  );
ASSERT_TRUE(l1->endCalled);
ASSERT_EQ(1f  ,a1->getAnimatedFraction()  );
ASSERT_TRUE(l1->endCalled);
ASSERT_EQ(1f  ,a1->getAnimatedFraction()  );
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_TRUE(l1->endCalled);ASSERT_EQ(1f  ,a1->getAnimatedFraction()  ); }}  );
a1->setStartDelay(20  );
ValueAnimatorTests::MyListener normalEndingListener=new ValueAnimatorTests::MyListener()  ;
a1->addListener(normalEndingListener);
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(normalEndingListener->startCalled);
ASSERT_FALSE(normalEndingListener->endCalled);
a1->Play();
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(normalEndingListener->startCalled);
ASSERT_FALSE(normalEndingListener->endCalled);
a1->Play();
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_FALSE(a1->IsRunning()  );ASSERT_FALSE(normalEndingListener->startCalled);ASSERT_FALSE(normalEndingListener->endCalled);a1->Play(); }}  );
Thread->sleep(a1->getTotalDuration()   + POLL_INTERVAL);
ValueAnimatorTests::MyListener l1=new ValueAnimatorTests::MyListener()  ;
a1->addListener(l1);
ValueAnimatorTests::MyListener l2=new ValueAnimatorTests::MyListener()  ;
a2->addListener(l2);
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(l1->startCalled);
ASSERT_FALSE(l1->endCalled);
ASSERT_FALSE(a2->IsRunning()  );
ASSERT_FALSE(l2->startCalled);
ASSERT_FALSE(l1->endCalled);
a1->Stop();
a2->Stop();
ASSERT_TRUE(l1->startCalled);
ASSERT_TRUE(l1->endCalled);
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_TRUE(l1->endTime >= l1->startTime);
ASSERT_TRUE(l2->startCalled);
ASSERT_TRUE(l2->endCalled);
ASSERT_FALSE(a2->IsRunning()  );
ASSERT_TRUE(l2->endTime >= l1->startTime);
ValueAnimatorTests::MyListener l1=new ValueAnimatorTests::MyListener()  ;
a1->addListener(l1);
ValueAnimatorTests::MyListener l2=new ValueAnimatorTests::MyListener()  ;
a2->addListener(l2);
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(l1->startCalled);
ASSERT_FALSE(l1->endCalled);
ASSERT_FALSE(a2->IsRunning()  );
ASSERT_FALSE(l2->startCalled);
ASSERT_FALSE(l1->endCalled);
a1->Stop();
a2->Stop();
ASSERT_TRUE(l1->startCalled);
ASSERT_TRUE(l1->endCalled);
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_TRUE(l1->endTime >= l1->startTime);
ASSERT_TRUE(l2->startCalled);
ASSERT_TRUE(l2->endCalled);
ASSERT_FALSE(a2->IsRunning()  );
ASSERT_TRUE(l2->endTime >= l1->startTime);
mActivityRule->runOnUiThread(new Runnable(){void run() { ValueAnimatorTests::MyListener l1=new ValueAnimatorTests::MyListener()  ;a1->addListener(l1);ValueAnimatorTests::MyListener l2=new ValueAnimatorTests::MyListener()  ;a2->addListener(l2);ASSERT_FALSE(a1->IsRunning()  );ASSERT_FALSE(l1->startCalled);ASSERT_FALSE(l1->endCalled);ASSERT_FALSE(a2->IsRunning()  );ASSERT_FALSE(l2->startCalled);ASSERT_FALSE(l1->endCalled);a1->Stop();a2->Stop();ASSERT_TRUE(l1->startCalled);ASSERT_TRUE(l1->endCalled);ASSERT_FALSE(a1->IsRunning()  );ASSERT_TRUE(l1->endTime >= l1->startTime);ASSERT_TRUE(l2->startCalled);ASSERT_TRUE(l2->endCalled);ASSERT_FALSE(a2->IsRunning()  );ASSERT_TRUE(l2->endTime >= l1->startTime); }}  );
a1->setDuration(0  );
a2->setDuration(0  );
ACE_EXPORTAnimator *  a3=ValueAnimator->ofInt(0  ,100  )  ;
a3->setDuration(0  );
a3->setCurrentFraction(1.0f  );
ASSERT_EQ(1.0f  ,a3->getAnimatedFraction()  );
ValueAnimatorTests::MyListener l1=new ValueAnimatorTests::MyListener()  ;
ValueAnimatorTests::MyListener l2=new ValueAnimatorTests::MyListener()  ;
ValueAnimatorTests::MyListener l3=new ValueAnimatorTests::MyListener()  ;
a1->addListener(l1);
a2->addListener(l2);
a3->addListener(l3);
ASSERT_FALSE(l1->startCalled);
ASSERT_FALSE(l2->startCalled);
ASSERT_FALSE(l3->startCalled);
ASSERT_FALSE(l1->endCalled);
ASSERT_FALSE(l2->endCalled);
ASSERT_FALSE(l3->endCalled);
a1->Play();
a2->reverse();
a3->Play();
ASSERT_EQ(A1_END_VALUE,a1->getAnimatedValue()  );
ASSERT_EQ(A2_START_VALUE,a2->getAnimatedValue()  );
ASSERT_FALSE(l1->startCalled);
ASSERT_FALSE(l2->startCalled);
ASSERT_FALSE(l3->startCalled);
ASSERT_FALSE(l1->endCalled);
ASSERT_FALSE(l2->endCalled);
ASSERT_FALSE(l3->endCalled);
a1->Play();
a2->reverse();
a3->Play();
ASSERT_EQ(A1_END_VALUE,a1->getAnimatedValue()  );
ASSERT_EQ(A2_START_VALUE,a2->getAnimatedValue()  );
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_FALSE(l1->startCalled);ASSERT_FALSE(l2->startCalled);ASSERT_FALSE(l3->startCalled);ASSERT_FALSE(l1->endCalled);ASSERT_FALSE(l2->endCalled);ASSERT_FALSE(l3->endCalled);a1->Play();a2->reverse();a3->Play();ASSERT_EQ(A1_END_VALUE,a1->getAnimatedValue()  );ASSERT_EQ(A2_START_VALUE,a2->getAnimatedValue()  ); }}  );
Thread->sleep(POLL_INTERVAL);
ASSERT_TRUE(l1->startCalled);
ASSERT_TRUE(l2->startCalled);
ASSERT_TRUE(l3->startCalled);
ASSERT_TRUE(l1->endCalled);
ASSERT_TRUE(l2->endCalled);
ASSERT_TRUE(l3->endCalled);
ASSERT_EQ(1.0f  ,a1->getAnimatedFraction()  );
ASSERT_EQ(0f  ,a2->getAnimatedFraction()  );
ASSERT_EQ(1f  ,a3->getAnimatedFraction()  );
ASSERT_EQ(A1_END_VALUE,a1->getAnimatedValue()  );
ASSERT_EQ(A2_START_VALUE,a2->getAnimatedValue()  );
ASSERT_EQ(100  ,a3->getAnimatedValue()  );
ASSERT_TRUE(l1->startCalled);
ASSERT_TRUE(l2->startCalled);
ASSERT_TRUE(l3->startCalled);
ASSERT_TRUE(l1->endCalled);
ASSERT_TRUE(l2->endCalled);
ASSERT_TRUE(l3->endCalled);
ASSERT_EQ(1.0f  ,a1->getAnimatedFraction()  );
ASSERT_EQ(0f  ,a2->getAnimatedFraction()  );
ASSERT_EQ(1f  ,a3->getAnimatedFraction()  );
ASSERT_EQ(A1_END_VALUE,a1->getAnimatedValue()  );
ASSERT_EQ(A2_START_VALUE,a2->getAnimatedValue()  );
ASSERT_EQ(100  ,a3->getAnimatedValue()  );
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_TRUE(l1->startCalled);ASSERT_TRUE(l2->startCalled);ASSERT_TRUE(l3->startCalled);ASSERT_TRUE(l1->endCalled);ASSERT_TRUE(l2->endCalled);ASSERT_TRUE(l3->endCalled);ASSERT_EQ(1.0f  ,a1->getAnimatedFraction()  );ASSERT_EQ(0f  ,a2->getAnimatedFraction()  );ASSERT_EQ(1f  ,a3->getAnimatedFraction()  );ASSERT_EQ(A1_END_VALUE,a1->getAnimatedValue()  );ASSERT_EQ(A2_START_VALUE,a2->getAnimatedValue()  );ASSERT_EQ(100  ,a3->getAnimatedValue()  ); }}  );
float scale=ValueAnimator->getDurationScale()  ;
ValueAnimator->setDurationScale(0f  );
a1->setStartDelay(200  );
ValueAnimatorTests::MyListener l1=new ValueAnimatorTests::MyListener()  ;
ValueAnimatorTests::MyListener l2=new ValueAnimatorTests::MyListener()  ;
a1->addListener(l1);
a2->addListener(l2);
ASSERT_FALSE(l1->startCalled);
ASSERT_FALSE(l2->startCalled);
ASSERT_FALSE(l1->endCalled);
ASSERT_FALSE(l2->endCalled);
a1->Play();
a2->Play();
ASSERT_EQ(A2_START_VALUE,a2->getAnimatedValue()  );
ASSERT_FALSE(l1->startCalled);
ASSERT_FALSE(l2->startCalled);
ASSERT_FALSE(l1->endCalled);
ASSERT_FALSE(l2->endCalled);
a1->Play();
a2->Play();
ASSERT_EQ(A2_START_VALUE,a2->getAnimatedValue()  );
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_FALSE(l1->startCalled);ASSERT_FALSE(l2->startCalled);ASSERT_FALSE(l1->endCalled);ASSERT_FALSE(l2->endCalled);a1->Play();a2->Play();ASSERT_EQ(A2_START_VALUE,a2->getAnimatedValue()  ); }}  );
Thread->sleep(POLL_INTERVAL);
ASSERT_TRUE(l1->startCalled);
ASSERT_TRUE(l2->startCalled);
ASSERT_TRUE(l1->endCalled);
ASSERT_TRUE(l2->endCalled);
ASSERT_EQ(A1_END_VALUE,a1->getAnimatedValue()  );
ASSERT_EQ(A2_END_VALUE,a2->getAnimatedValue()  );
ASSERT_TRUE(l1->startCalled);
ASSERT_TRUE(l2->startCalled);
ASSERT_TRUE(l1->endCalled);
ASSERT_TRUE(l2->endCalled);
ASSERT_EQ(A1_END_VALUE,a1->getAnimatedValue()  );
ASSERT_EQ(A2_END_VALUE,a2->getAnimatedValue()  );
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_TRUE(l1->startCalled);ASSERT_TRUE(l2->startCalled);ASSERT_TRUE(l1->endCalled);ASSERT_TRUE(l2->endCalled);ASSERT_EQ(A1_END_VALUE,a1->getAnimatedValue()  );ASSERT_EQ(A2_END_VALUE,a2->getAnimatedValue()  ); }}  );
ValueAnimator->setDurationScale(scale);
ACE_EXPORTAnimator *  a3=ValueAnimator->ofInt(0  ,100  )  ;
a1->setDuration(400  );
a2->setDuration(600  );
a3->setDuration(400  );
ValueAnimatorTests::MyListener l1=new ValueAnimatorTests::MyListener()  ;
ValueAnimatorTests::MyListener l2=new ValueAnimatorTests::MyListener()  ;
ValueAnimatorTests::MyListener l3=new ValueAnimatorTests::MyListener()  ;
a1->addListener(l1);
a2->addListener(l2);
a3->addListener(l3);
ASSERT_FALSE(l1->startCalled);
ASSERT_FALSE(l2->startCalled);
ASSERT_FALSE(l3->startCalled);
ASSERT_FALSE(l1->endCalled);
ASSERT_FALSE(l2->endCalled);
ASSERT_FALSE(l3->endCalled);
a1->reverse();
a2->reverse();
a3->reverse();
ASSERT_FALSE(l1->startCalled);
ASSERT_FALSE(l2->startCalled);
ASSERT_FALSE(l3->startCalled);
ASSERT_FALSE(l1->endCalled);
ASSERT_FALSE(l2->endCalled);
ASSERT_FALSE(l3->endCalled);
a1->reverse();
a2->reverse();
a3->reverse();
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_FALSE(l1->startCalled);ASSERT_FALSE(l2->startCalled);ASSERT_FALSE(l3->startCalled);ASSERT_FALSE(l1->endCalled);ASSERT_FALSE(l2->endCalled);ASSERT_FALSE(l3->endCalled);a1->reverse();a2->reverse();a3->reverse(); }}  );
Thread->sleep(POLL_INTERVAL);
ASSERT_TRUE(l1->startCalled);
ASSERT_TRUE(l2->startCalled);
ASSERT_TRUE(l3->startCalled);
a1->setCurrentFraction(0f  );
a2->setCurrentFraction(1f  );
a3->Stop();
ASSERT_EQ(1f  ,a1->getAnimatedFraction()  );
ASSERT_EQ(0f  ,a2->getAnimatedFraction()  );
ASSERT_TRUE(l1->startCalled);
ASSERT_TRUE(l2->startCalled);
ASSERT_TRUE(l3->startCalled);
a1->setCurrentFraction(0f  );
a2->setCurrentFraction(1f  );
a3->Stop();
ASSERT_EQ(1f  ,a1->getAnimatedFraction()  );
ASSERT_EQ(0f  ,a2->getAnimatedFraction()  );
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_TRUE(l1->startCalled);ASSERT_TRUE(l2->startCalled);ASSERT_TRUE(l3->startCalled);a1->setCurrentFraction(0f  );a2->setCurrentFraction(1f  );a3->Stop();ASSERT_EQ(1f  ,a1->getAnimatedFraction()  );ASSERT_EQ(0f  ,a2->getAnimatedFraction()  ); }}  );
Thread->sleep(POLL_INTERVAL);
ASSERT_FALSE(l1->endCalled);
ASSERT_TRUE(l2->endCalled);
ASSERT_TRUE(l3->endCalled);
ASSERT_FALSE(l1->endCalled);
ASSERT_TRUE(l2->endCalled);
ASSERT_TRUE(l3->endCalled);
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_FALSE(l1->endCalled);ASSERT_TRUE(l2->endCalled);ASSERT_TRUE(l3->endCalled); }}  );
Thread->sleep(a1->getTotalDuration()  );
ASSERT_TRUE(l1->endCalled);
ASSERT_EQ(0f  ,a1->getAnimatedFraction()  );
ASSERT_EQ(0f  ,a2->getAnimatedFraction()  );
ASSERT_EQ(0f  ,a3->getAnimatedFraction()  );
ASSERT_TRUE(l1->endCalled);
ASSERT_EQ(0f  ,a1->getAnimatedFraction()  );
ASSERT_EQ(0f  ,a2->getAnimatedFraction()  );
ASSERT_EQ(0f  ,a3->getAnimatedFraction()  );
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_TRUE(l1->endCalled);ASSERT_EQ(0f  ,a1->getAnimatedFraction()  );ASSERT_EQ(0f  ,a2->getAnimatedFraction()  );ASSERT_EQ(0f  ,a3->getAnimatedFraction()  ); }}  );
}
//以下组件没有匹配:
//Runnable
void run()
{
lastUpdateTime=SystemClock->uptimeMillis()  ;
firstRunningFrameTime=lastUpdateTime;
startFraction=animation->getAnimatedFraction()  ;
wasRunning=animation->isRunning()  ;
if(animation->isRunning()   && !wasRunning){ firstRunningFrameTime=lastUpdateTime;startFraction=animation->getAnimatedFraction()  ;wasRunning=animation->isRunning()  ; }
wasRunning=false  ;
firstRunningFrameTime=-1  ;
lastUpdateTime=-1  ;
startFraction=0  ;
startCalled=true  ;
startTime=SystemClock->uptimeMillis()  ;
endCalled=true  ;
endTime=SystemClock->uptimeMillis()  ;
cancelCalled=true  ;
pauseCalled=true  ;
resumeCalled=true  ;
mHandler->sendEmptyMessageDelayed(MSG_FRAME,mFrameDelay);
mFrameCallbacks->add(callback);
if(!mFrameCallbacks->contains(callback)  ){ mFrameCallbacks->add(callback); }
mHandler->postDelayed(runnable,COMMIT_DELAY);
return SystemClock->uptimeMillis()  ;
return mFrameDelay;
mFrameDelay=delay;
mHandler->removeMessages(MSG_FRAME);
mHandler->sendEmptyMessageDelayed(MSG_FRAME,mFrameDelay);
if(mFrameCallbacks->size()   != 0  ){ mHandler->removeMessages(MSG_FRAME);mHandler->sendEmptyMessageDelayed(MSG_FRAME,mFrameDelay); }
Looper->prepare();
mFrameCallbacks->get(i)  -> doFrame(SystemClock->uptimeMillis()  );
for(int i=0  ;i < mFrameCallbacks->size()  ;i++){ mFrameCallbacks->get(i)  -> doFrame(SystemClock->uptimeMillis()  ); }
break;
break;
switch(msg->what){caseMSG_FRAME: for(int i=0  ;i < mFrameCallbacks->size()  ;i++){ mFrameCallbacks->get(i)  -> doFrame(SystemClock->uptimeMillis()  ); }break; default: break; }
{ switch(msg->what){caseMSG_FRAME: for(int i=0  ;i < mFrameCallbacks->size()  ;i++){ mFrameCallbacks->get(i)  -> doFrame(SystemClock->uptimeMillis()  ); }break; default: break; } }
mHandler=new Handler(){void handleMessage(Message *  msg) { { switch(msg->what){caseMSG_FRAME: for(int i=0  ;i < mFrameCallbacks->size()  ;i++){ mFrameCallbacks->get(i)  -> doFrame(SystemClock->uptimeMillis()  ); }break; default: break; } } }}  ;
Looper->loop();
a1=ValueAnimator->ofFloat(A1_START_VALUE,A1_END_VALUE)  -> setDuration(300  );
a2=ValueAnimator->ofInt(A2_START_VALUE,A2_END_VALUE)  -> setDuration(500  );
a1=null  ;
a2=null  ;
ACE_EXPORTAnimator *  a=ValueAnimator->ofFloat(5f  ,20f  )  ;
ASSERT_EQ(a->getStartDelay()  ,0  );
long delay=200  ;
a->setStartDelay(delay);
ASSERT_EQ(a->getStartDelay()  ,delay);
ValueAnimatorTests::MyUpdateListener listener=new ValueAnimatorTests::MyUpdateListener()  ;
a->AddUpdateListener(listener);
long [] startTime= newlong[1] ;
ASSERT_FALSE(a->IsRunning()  );
ASSERT_FALSE(a->IsRunning()  );
a->Play();
startTime[0]=SystemClock->uptimeMillis()  ;
ASSERT_TRUE(a->IsRunning()  );
ASSERT_FALSE(a->IsRunning()  );
ASSERT_FALSE(a->IsRunning()  );
ASSERT_FALSE(a->IsRunning()  );
a->Play();
startTime[0]=SystemClock->uptimeMillis()  ;
ASSERT_TRUE(a->IsRunning()  );
ASSERT_FALSE(a->IsRunning()  );
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_FALSE(a->IsRunning()  );ASSERT_FALSE(a->IsRunning()  );a->Play();startTime[0]=SystemClock->uptimeMillis()  ;ASSERT_TRUE(a->IsRunning()  );ASSERT_FALSE(a->IsRunning()  ); }}  );
Thread->sleep(a->getTotalDuration()  );
ASSERT_TRUE(listener->wasRunning);
ASSERT_TRUE(listener->firstRunningFrameTime - startTime[0]   >= delay);
ASSERT_TRUE(listener->wasRunning);
ASSERT_TRUE(listener->firstRunningFrameTime - startTime[0]   >= delay);
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_TRUE(listener->wasRunning);ASSERT_TRUE(listener->firstRunningFrameTime - startTime[0]   >= delay); }}  );
Thread->sleep(a->getTotalDuration()  );
ASSERT_FALSE(a->IsRunning()  );
ASSERT_FALSE(a->IsRunning()  );
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_FALSE(a->IsRunning()  ); }}  );
ValueAnimatorTests::MyListener l1=new ValueAnimatorTests::MyListener()  ;
ValueAnimatorTests::MyListener l2=new ValueAnimatorTests::MyListener()  ;
a1->addListener(l1);
a2->addListener(l2);
a2->setStartDelay(400  );
ASSERT_FALSE(l1->startCalled);
ASSERT_FALSE(l1->cancelCalled);
ASSERT_FALSE(l1->endCalled);
ASSERT_FALSE(l2->startCalled);
ASSERT_FALSE(l2->cancelCalled);
ASSERT_FALSE(l2->endCalled);
a1->Play();
a2->Play();
a1->Play();
a2->Play();
mActivityRule->runOnUiThread(new Runnable(){void run() { a1->Play();a2->Play(); }}  );
long wait=0  ;
Thread->sleep(POLL_INTERVAL);
wait+=POLL_INTERVAL;
ASSERT_FALSE(l1->cancelCalled);
a1->cancel();
ASSERT_TRUE(l1->cancelCalled);
ASSERT_TRUE(l1->endCalled);
ASSERT_FALSE(l1->cancelCalled);
a1->cancel();
ASSERT_TRUE(l1->cancelCalled);
ASSERT_TRUE(l1->endCalled);
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_FALSE(l1->cancelCalled);a1->cancel();ASSERT_TRUE(l1->cancelCalled);ASSERT_TRUE(l1->endCalled); }}  );
ASSERT_TRUE(l1->startCalled);
ASSERT_FALSE(l2->startCalled);
ASSERT_TRUE(l1->startCalled);
ASSERT_FALSE(l2->startCalled);
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_TRUE(l1->startCalled);ASSERT_FALSE(l2->startCalled); }}  );
Thread->sleep(POLL_INTERVAL);
wait+=POLL_INTERVAL;
while(wait < a2->getStartDelay()  ){ mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_TRUE(l1->startCalled);ASSERT_FALSE(l2->startCalled); }}  );Thread->sleep(POLL_INTERVAL);wait+=POLL_INTERVAL; }
long delay=Math->max(a1->getTotalDuration()  ,a2->getTotalDuration()  )   + TOLERANCE;
Thread->sleep(delay);
ASSERT_TRUE(l1->startCalled);
ASSERT_TRUE(l1->cancelCalled);
ASSERT_TRUE(l1->endCalled);
ASSERT_TRUE(l2->startCalled);
ASSERT_FALSE(l2->cancelCalled);
ASSERT_TRUE(l2->endCalled);
ASSERT_TRUE(l1->startCalled);
ASSERT_TRUE(l1->cancelCalled);
ASSERT_TRUE(l1->endCalled);
ASSERT_TRUE(l2->startCalled);
ASSERT_FALSE(l2->cancelCalled);
ASSERT_TRUE(l2->endCalled);
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_TRUE(l1->startCalled);ASSERT_TRUE(l1->cancelCalled);ASSERT_TRUE(l1->endCalled);ASSERT_TRUE(l2->startCalled);ASSERT_FALSE(l2->cancelCalled);ASSERT_TRUE(l2->endCalled); }}  );
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a2->IsRunning()  );
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a2->IsRunning()  );
long startDelay=150  ;
a1->setStartDelay(startDelay);
long [] startTime= newlong[1] ;
a1->Play();
a2->Play();
startTime[0]=SystemClock->uptimeMillis()  ;
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a2->IsRunning()  );
a1->Play();
a2->Play();
startTime[0]=SystemClock->uptimeMillis()  ;
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a2->IsRunning()  );
mActivityRule->runOnUiThread(new Runnable(){void run() { a1->Play();a2->Play();startTime[0]=SystemClock->uptimeMillis()  ;ASSERT_TRUE(a1->IsRunning()  );ASSERT_TRUE(a2->IsRunning()  ); }}  );
long delayMs=0  ;
Thread->sleep(POLL_INTERVAL);
delayMs+=POLL_INTERVAL;
ASSERT_FALSE(a1->IsRunning()  );
if(SystemClock->uptimeMillis()   - startTime[0]   < startDelay){ ASSERT_FALSE(a1->IsRunning()  ); }
ASSERT_FALSE(a1->IsRunning()  );
if(SystemClock->uptimeMillis()   - startTime[0]   < startDelay){ ASSERT_FALSE(a1->IsRunning()  ); }
mActivityRule->runOnUiThread(new Runnable(){void run() { if(SystemClock->uptimeMillis()   - startTime[0]   < startDelay){ ASSERT_FALSE(a1->IsRunning()  ); } }}  );
while(delayMs < startDelay){ Thread->sleep(POLL_INTERVAL);delayMs+=POLL_INTERVAL;mActivityRule->runOnUiThread(new Runnable(){void run() { if(SystemClock->uptimeMillis()   - startTime[0]   < startDelay){ ASSERT_FALSE(a1->IsRunning()  ); } }}  ); }
Thread->sleep(startDelay);
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a2->IsRunning()  );
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a2->IsRunning()  );
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_TRUE(a1->IsRunning()  );ASSERT_TRUE(a2->IsRunning()  ); }}  );
long delay=Math->max(a1->getTotalDuration()  ,a2->getTotalDuration()  )   * 2  ;
Thread->sleep(delay);
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a2->IsRunning()  );
ASSERT_FALSE(a2->IsRunning()  );
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a2->IsRunning()  );
ASSERT_FALSE(a2->IsRunning()  );
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_FALSE(a1->IsRunning()  );ASSERT_FALSE(a1->IsRunning()  );ASSERT_FALSE(a2->IsRunning()  );ASSERT_FALSE(a2->IsRunning()  ); }}  );
ASSERT_FALSE(a1->IsPending()  );
ASSERT_FALSE(a2->IsPending()  );
a1->Play();
a2->Play();
ASSERT_FALSE(a1->IsPending()  );
ASSERT_FALSE(a2->IsPending()  );
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a2->IsRunning()  );
ASSERT_FALSE(a1->IsPending()  );
ASSERT_FALSE(a2->IsPending()  );
a1->Play();
a2->Play();
ASSERT_FALSE(a1->IsPending()  );
ASSERT_FALSE(a2->IsPending()  );
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a2->IsRunning()  );
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_FALSE(a1->IsPending()  );ASSERT_FALSE(a2->IsPending()  );a1->Play();a2->Play();ASSERT_FALSE(a1->IsPending()  );ASSERT_FALSE(a2->IsPending()  );ASSERT_TRUE(a1->IsRunning()  );ASSERT_TRUE(a2->IsRunning()  ); }}  );
Thread->sleep(POLL_INTERVAL);
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a2->IsRunning()  );
a1->Pause();
ASSERT_TRUE(a1->IsPending()  );
ASSERT_FALSE(a2->IsPending()  );
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a2->IsRunning()  );
a1->Pause();
ASSERT_TRUE(a1->IsPending()  );
ASSERT_FALSE(a2->IsPending()  );
ASSERT_TRUE(a1->IsRunning()  );
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_TRUE(a1->IsRunning()  );ASSERT_TRUE(a2->IsRunning()  );a1->Pause();ASSERT_TRUE(a1->IsPending()  );ASSERT_FALSE(a2->IsPending()  );ASSERT_TRUE(a1->IsRunning()  ); }}  );
Thread->sleep(a2->getTotalDuration()  );
ASSERT_FALSE(a2->IsRunning()  );
ASSERT_FALSE(a2->IsRunning()  );
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a1->IsPending()  );
a1->resume();
ASSERT_FALSE(a2->IsRunning()  );
ASSERT_FALSE(a2->IsRunning()  );
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a1->IsPending()  );
a1->resume();
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_FALSE(a2->IsRunning()  );ASSERT_FALSE(a2->IsRunning()  );ASSERT_TRUE(a1->IsRunning()  );ASSERT_TRUE(a1->IsRunning()  );ASSERT_TRUE(a1->IsPending()  );a1->resume(); }}  );
Thread->sleep(POLL_INTERVAL);
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_FALSE(a1->IsPending()  );
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_FALSE(a1->IsPending()  );
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_TRUE(a1->IsRunning()  );ASSERT_TRUE(a1->IsRunning()  );ASSERT_FALSE(a1->IsPending()  ); }}  );
Thread->sleep(a1->getTotalDuration()  );
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a1->IsPending()  );
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a1->IsPending()  );
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_FALSE(a1->IsRunning()  );ASSERT_FALSE(a1->IsRunning()  );ASSERT_FALSE(a1->IsPending()  ); }}  );
ValueAnimatorTests::MyPauseListener l1=new ValueAnimatorTests::MyPauseListener()  ;
ValueAnimatorTests::MyPauseListener l2=new ValueAnimatorTests::MyPauseListener()  ;
a1->addPauseListener(l1);
a2->addPauseListener(l2);
ASSERT_FALSE(l1->pauseCalled);
ASSERT_FALSE(l1->resumeCalled);
ASSERT_FALSE(l2->pauseCalled);
ASSERT_FALSE(l2->resumeCalled);
a1->Play();
a2->Play();
a1->Play();
a2->Play();
mActivityRule->runOnUiThread(new Runnable(){void run() { a1->Play();a2->Play(); }}  );
Thread->sleep(a1->getTotalDuration()   / 2  );
a1->Pause();
Thread->sleep(a2->getTotalDuration()  );
ASSERT_TRUE(l1->pauseCalled);
ASSERT_FALSE(l1->resumeCalled);
a1->resume();
a1->resume();
mActivityRule->runOnUiThread(new Runnable(){void run() { a1->resume(); }}  );
Thread->sleep(a1->getTotalDuration()  );
ASSERT_TRUE(l1->pauseCalled);
ASSERT_TRUE(l1->resumeCalled);
ASSERT_FALSE(l2->pauseCalled);
ASSERT_FALSE(l2->resumeCalled);
ValueAnimatorTests::MyUpdateListener l1=new ValueAnimatorTests::MyUpdateListener()  ;
long totalDuration=a1->getTotalDuration()  ;
a1->AddUpdateListener(l1);
a1->setDuration(1000  );
ASSERT_TRUE(l1->firstRunningFrameTime < 0  );
ASSERT_TRUE(l1->lastUpdateTime < 0  );
long [] lastUpdate= newlong[1] ;
a1->Play();
a1->Play();
mActivityRule->runOnUiThread(new Runnable(){void run() { a1->Play(); }}  );
Thread->sleep(totalDuration / 2  );
ASSERT_TRUE(l1->firstRunningFrameTime > 0  );
ASSERT_TRUE(l1->lastUpdateTime > l1->firstRunningFrameTime);
lastUpdate[0]=l1->lastUpdateTime;
a1->Pause();
ASSERT_TRUE(l1->firstRunningFrameTime > 0  );
ASSERT_TRUE(l1->lastUpdateTime > l1->firstRunningFrameTime);
lastUpdate[0]=l1->lastUpdateTime;
a1->Pause();
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_TRUE(l1->firstRunningFrameTime > 0  );ASSERT_TRUE(l1->lastUpdateTime > l1->firstRunningFrameTime);lastUpdate[0]=l1->lastUpdateTime;a1->Pause(); }}  );
Thread->sleep(totalDuration);
ASSERT_EQ(lastUpdate[0]  ,l1->lastUpdateTime);
a1->resume();
ASSERT_EQ(lastUpdate[0]  ,l1->lastUpdateTime);
a1->resume();
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_EQ(lastUpdate[0]  ,l1->lastUpdateTime);a1->resume(); }}  );
Thread->sleep(POLL_INTERVAL);
ASSERT_TRUE(l1->lastUpdateTime > lastUpdate[0]  );
lastUpdate[0]=l1->lastUpdateTime;
ASSERT_TRUE(l1->lastUpdateTime > lastUpdate[0]  );
lastUpdate[0]=l1->lastUpdateTime;
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_TRUE(l1->lastUpdateTime > lastUpdate[0]  );lastUpdate[0]=l1->lastUpdateTime; }}  );
do{ Thread->sleep(POLL_INTERVAL);mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_TRUE(l1->lastUpdateTime > lastUpdate[0]  );lastUpdate[0]=l1->lastUpdateTime; }}  ); }while(!a1->IsRunning()  );
long entireSpan=totalDuration * 2  ;
long frameDelta=l1->lastUpdateTime - l1->firstRunningFrameTime;
ASSERT_TRUE(Math->abs(entireSpan - frameDelta)   < TOLERANCE);
ValueAnimatorTests::MyListener l1=new ValueAnimatorTests::MyListener()  ;
ValueAnimatorTests::MyListener l2=new ValueAnimatorTests::MyListener()  ;
a1->addListener(l1);
a2->addListener(l2);
anim->Cancel();
anim->Cancel();
a1->addListener(new ValueAnimatorTests::MyListener(){void onAnimationEnd(ACE_EXPORTAnimator *  anim) { anim->Cancel(); }}  );
anim->end();
anim->end();
a2->addListener(new ValueAnimatorTests::MyListener(){void onAnimationCancel(ACE_EXPORTAnimator *  anim) { anim->end(); }}  );
ASSERT_FALSE(l1->cancelCalled);
ASSERT_FALSE(l1->endCalled);
ASSERT_FALSE(l2->cancelCalled);
ASSERT_FALSE(l2->endCalled);
a1->Play();
a2->Play();
ASSERT_FALSE(l1->cancelCalled);
ASSERT_FALSE(l1->endCalled);
ASSERT_FALSE(l2->cancelCalled);
ASSERT_FALSE(l2->endCalled);
a1->Play();
a2->Play();
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_FALSE(l1->cancelCalled);ASSERT_FALSE(l1->endCalled);ASSERT_FALSE(l2->cancelCalled);ASSERT_FALSE(l2->endCalled);a1->Play();a2->Play(); }}  );
Thread->sleep(POLL_INTERVAL);
a1->Stop();
a2->cancel();
a1->Stop();
a2->cancel();
mActivityRule->runOnUiThread(new Runnable(){void run() { a1->Stop();a2->cancel(); }}  );
Thread->sleep(POLL_INTERVAL);
ASSERT_FALSE(l1->cancelCalled);
ASSERT_TRUE(l1->endCalled);
ASSERT_TRUE(l2->cancelCalled);
ASSERT_TRUE(l2->endCalled);
float value1=(Float)a1.getAnimatedValue();
int value2=(Integer)a2.getAnimatedValue();
ASSERT_EQ(A1_END_VALUE,value1);
ASSERT_EQ(A2_END_VALUE,value2);
ASSERT_FALSE(l1->cancelCalled);
ASSERT_TRUE(l1->endCalled);
ASSERT_TRUE(l2->cancelCalled);
ASSERT_TRUE(l2->endCalled);
float value1=(Float)a1.getAnimatedValue();
int value2=(Integer)a2.getAnimatedValue();
ASSERT_EQ(A1_END_VALUE,value1);
ASSERT_EQ(A2_END_VALUE,value2);
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_FALSE(l1->cancelCalled);ASSERT_TRUE(l1->endCalled);ASSERT_TRUE(l2->cancelCalled);ASSERT_TRUE(l2->endCalled);float value1=(Float)a1.getAnimatedValue();int value2=(Integer)a2.getAnimatedValue();ASSERT_EQ(A1_END_VALUE,value1);ASSERT_EQ(A2_END_VALUE,value2); }}  );
ValueAnimatorTests::MyListener l1=new ValueAnimatorTests::MyListener()  ;
a1->addListener(l1);
ValueAnimatorTests::MyListener l2=new ValueAnimatorTests::MyListener()  ;
a2->addListener(l2);
a1->Play();
a2->Play();
a1->Play();
a2->Play();
mActivityRule->runOnUiThread(new Runnable(){void run() { a1->Play();a2->Play(); }}  );
Thread->sleep(POLL_INTERVAL);
ASSERT_FALSE(l1->endCalled);
ASSERT_FALSE(l2->endCalled);
assertNotEqual(A1_END_VALUE,a1->getAnimatedValue()  );
assertNotEqual(A1_END_VALUE,a2->getAnimatedValue()  );
a2->Stop();
ASSERT_FALSE(l1->endCalled);
ASSERT_FALSE(l2->endCalled);
assertNotEqual(A1_END_VALUE,a1->getAnimatedValue()  );
assertNotEqual(A1_END_VALUE,a2->getAnimatedValue()  );
a2->Stop();
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_FALSE(l1->endCalled);ASSERT_FALSE(l2->endCalled);assertNotEqual(A1_END_VALUE,a1->getAnimatedValue()  );assertNotEqual(A1_END_VALUE,a2->getAnimatedValue()  );a2->Stop(); }}  );
Thread->sleep(a1->getTotalDuration()  );
ASSERT_FALSE(l1->cancelCalled);
ASSERT_TRUE(l1->endCalled);
ASSERT_FALSE(l2->cancelCalled);
ASSERT_TRUE(l2->endCalled);
ASSERT_EQ(A1_END_VALUE,((Float)(a1.getAnimatedValue()))  -> floatValue());
ASSERT_EQ(A2_END_VALUE,((Integer)(a2.getAnimatedValue()))  -> intValue());
ASSERT_FALSE(l1->cancelCalled);
ASSERT_TRUE(l1->endCalled);
ASSERT_FALSE(l2->cancelCalled);
ASSERT_TRUE(l2->endCalled);
ASSERT_EQ(A1_END_VALUE,((Float)(a1.getAnimatedValue()))  -> floatValue());
ASSERT_EQ(A2_END_VALUE,((Integer)(a2.getAnimatedValue()))  -> intValue());
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_FALSE(l1->cancelCalled);ASSERT_TRUE(l1->endCalled);ASSERT_FALSE(l2->cancelCalled);ASSERT_TRUE(l2->endCalled);ASSERT_EQ(A1_END_VALUE,((Float)(a1.getAnimatedValue()))  -> floatValue());ASSERT_EQ(A2_END_VALUE,((Integer)(a2.getAnimatedValue()))  -> intValue()); }}  );
ValueAnimatorTests::MyFrameCallbackProvider provider=new ValueAnimatorTests::MyFrameCallbackProvider()  ;
long sleep=0  ;
Thread->sleep(POLL_INTERVAL);
sleep+=POLL_INTERVAL;
break;
if(sleep > WAIT_TIME_OUT){ break; }
while(provider->mHandler == null  ){ Thread->sleep(POLL_INTERVAL);sleep+=POLL_INTERVAL;if(sleep > WAIT_TIME_OUT){ break; } }
assertNotNull(provider->mHandler);
ValueAnimatorTests::MyListener listener=new ValueAnimatorTests::MyListener()  ;
long currentTime=SystemClock->uptimeMillis()  ;
long frameDelay=provider->getFrameDelay()  ;
ASSERT_TRUE((currentTime-lastUpdateTime)   < frameDelay * 4  );
ASSERT_TRUE(listener->startCalled);
ASSERT_TRUE(listener->startTime > 0  );
ASSERT_TRUE(currentTime - listener->startTime < frameDelay * 4  );
if(lastUpdateTime > 0  ){ ASSERT_TRUE((currentTime-lastUpdateTime)   < frameDelay * 4  ); }else{ ASSERT_TRUE(listener->startCalled);ASSERT_TRUE(listener->startTime > 0  );ASSERT_TRUE(currentTime - listener->startTime < frameDelay * 4  ); }
super-> onAnimationUpdate(animation);
ValueAnimatorTests::MyUpdateListener l1=new ValueAnimatorTests::MyUpdateListener(){void onAnimationUpdate(ACE_EXPORTAnimator *  animation) { long currentTime=SystemClock->uptimeMillis()  ;long frameDelay=provider->getFrameDelay()  ;if(lastUpdateTime > 0  ){ ASSERT_TRUE((currentTime-lastUpdateTime)   < frameDelay * 4  ); }else{ ASSERT_TRUE(listener->startCalled);ASSERT_TRUE(listener->startTime > 0  );ASSERT_TRUE(currentTime - listener->startTime < frameDelay * 4  ); }super-> onAnimationUpdate(animation); }}  ;
a1->AddUpdateListener(l1);
a1->addListener(listener);
a1->setStartDelay(100  );
AnimationHandler->getInstance()  -> setProvider(provider);
a1->Play();
AnimationHandler->getInstance()  -> setProvider(provider);
a1->Play();
provider.mHandler->post(new Runnable(){void run() { AnimationHandler->getInstance()  -> setProvider(provider);a1->Play(); }}  );
Thread->sleep(POLL_INTERVAL);
ASSERT_TRUE(a1->IsRunning()  );
Thread->sleep(a1->getTotalDuration()   + TOLERANCE);
throwprovider->mAssertionError;
if(provider->mAssertionError != null  ){ throwprovider->mAssertionError; }
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_TRUE(listener->endTime > 0  );
ASSERT_TRUE(listener->endTime >= l1->lastUpdateTime);
ASSERT_TRUE(listener->endTime - l1->lastUpdateTime < 2   * provider->getFrameDelay()  );
ACE_EXPORTAnimator *  a0=ValueAnimator->ofInt(100  ,200  )  -> setDuration(500  );
ACE_EXPORTAnimator *  a3=ValueAnimator->ofFloat(0  ,1  )  -> setDuration(500  );
ACE_EXPORTAnimator *  a4=ValueAnimator->ofInt(200  ,300  )  -> setDuration(500  );
super-> onAnimationEnd(anim);
a0->cancel();
a1->Stop();
a3->Stop();
a4->cancel();
ValueAnimatorTests::MyListener listener=new ValueAnimatorTests::MyListener(){void onAnimationEnd(ACE_EXPORTAnimator *  anim) { super-> onAnimationEnd(anim);a0->cancel();a1->Stop();a3->Stop();a4->cancel(); }}  ;
a2->addListener(listener);
a0->Play();
a1->Play();
a2->Play();
a3->Play();
a4->Play();
a0->Play();
a1->Play();
a2->Play();
a3->Play();
a4->Play();
mActivityRule->runOnUiThread(new Runnable(){void run() { a0->Play();a1->Play();a2->Play();a3->Play();a4->Play(); }}  );
ASSERT_TRUE(a0->IsRunning()  );
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a2->IsRunning()  );
ASSERT_TRUE(a3->IsRunning()  );
ASSERT_TRUE(a4->IsRunning()  );
ASSERT_TRUE(a0->IsRunning()  );
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a2->IsRunning()  );
ASSERT_TRUE(a3->IsRunning()  );
ASSERT_TRUE(a4->IsRunning()  );
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_TRUE(a0->IsRunning()  );ASSERT_TRUE(a1->IsRunning()  );ASSERT_TRUE(a2->IsRunning()  );ASSERT_TRUE(a3->IsRunning()  );ASSERT_TRUE(a4->IsRunning()  ); }}  );
Thread->sleep(POLL_INTERVAL);
a2->Stop();
a2->Stop();
mActivityRule->runOnUiThread(new Runnable(){void run() { a2->Stop(); }}  );
Thread->sleep(POLL_INTERVAL);
ASSERT_TRUE(listener->endCalled);
ASSERT_FALSE(a0->IsRunning()  );
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a2->IsRunning()  );
ASSERT_FALSE(a3->IsRunning()  );
ASSERT_FALSE(a4->IsRunning()  );
ValueAnimatorTests::MyListener l1=new ValueAnimatorTests::MyListener()  ;
ValueAnimatorTests::MyListener l2=new ValueAnimatorTests::MyListener()  ;
ValueAnimatorTests::MyUpdateListener updateListener1=new ValueAnimatorTests::MyUpdateListener()  ;
ValueAnimatorTests::MyUpdateListener updateListener2=new ValueAnimatorTests::MyUpdateListener()  ;
float a1StartFraction=0.2f  ;
float a2StartFraction=0.3f  ;
a1->setDuration(1000  );
a2->setDuration(1000  );
a1->addListener(l1);
a2->addListener(l2);
a1->AddUpdateListener(updateListener1);
a2->AddUpdateListener(updateListener2);
//以下组件没有匹配:
//TimeInterpolator,LinearInterpolator
TimeInterpolator *  interpolator=new LinearInterpolator()  ;
a1->setInterpolator(interpolator);
a2->setInterpolator(interpolator);
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a2->IsRunning()  );
ASSERT_FALSE(a2->IsRunning()  );
a1->setCurrentFraction(a1StartFraction);
a2->setCurrentFraction(a2StartFraction);
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a2->IsRunning()  );
ASSERT_FALSE(a2->IsRunning()  );
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a2->IsRunning()  );
ASSERT_FALSE(a2->IsRunning()  );
a1->setCurrentFraction(a1StartFraction);
a2->setCurrentFraction(a2StartFraction);
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a2->IsRunning()  );
ASSERT_FALSE(a2->IsRunning()  );
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_FALSE(a1->IsRunning()  );ASSERT_FALSE(a1->IsRunning()  );ASSERT_FALSE(a2->IsRunning()  );ASSERT_FALSE(a2->IsRunning()  );a1->setCurrentFraction(a1StartFraction);a2->setCurrentFraction(a2StartFraction);ASSERT_FALSE(a1->IsRunning()  );ASSERT_FALSE(a1->IsRunning()  );ASSERT_FALSE(a2->IsRunning()  );ASSERT_FALSE(a2->IsRunning()  ); }}  );
Thread->sleep(POLL_INTERVAL);
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a2->IsRunning()  );
ASSERT_FALSE(a2->IsRunning()  );
ASSERT_EQ(a1StartFraction,a1->getAnimatedFraction()  );
ASSERT_EQ(a2StartFraction,a2->getAnimatedFraction()  );
a1->Play();
a2->Play();
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a2->IsRunning()  );
ASSERT_FALSE(a2->IsRunning()  );
ASSERT_EQ(a1StartFraction,a1->getAnimatedFraction()  );
ASSERT_EQ(a2StartFraction,a2->getAnimatedFraction()  );
a1->Play();
a2->Play();
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_FALSE(a1->IsRunning()  );ASSERT_FALSE(a1->IsRunning()  );ASSERT_FALSE(a2->IsRunning()  );ASSERT_FALSE(a2->IsRunning()  );ASSERT_EQ(a1StartFraction,a1->getAnimatedFraction()  );ASSERT_EQ(a2StartFraction,a2->getAnimatedFraction()  );a1->Play();a2->Play(); }}  );
Thread->sleep(POLL_INTERVAL);
float halfwayFraction=0.5f  ;
ASSERT_TRUE(l1->startCalled);
ASSERT_TRUE(l2->startCalled);
ASSERT_FALSE(l1->endCalled);
ASSERT_FALSE(l2->endCalled);
ASSERT_TRUE(updateListener1->startFraction >= a1StartFraction);
ASSERT_TRUE(updateListener2->startFraction >= a2StartFraction);
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a2->IsRunning()  );
ASSERT_TRUE(a2->IsRunning()  );
a1->setCurrentFraction(halfwayFraction);
a2->setCurrentFraction(halfwayFraction);
ASSERT_TRUE(l1->startCalled);
ASSERT_TRUE(l2->startCalled);
ASSERT_FALSE(l1->endCalled);
ASSERT_FALSE(l2->endCalled);
ASSERT_TRUE(updateListener1->startFraction >= a1StartFraction);
ASSERT_TRUE(updateListener2->startFraction >= a2StartFraction);
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a2->IsRunning()  );
ASSERT_TRUE(a2->IsRunning()  );
a1->setCurrentFraction(halfwayFraction);
a2->setCurrentFraction(halfwayFraction);
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_TRUE(l1->startCalled);ASSERT_TRUE(l2->startCalled);ASSERT_FALSE(l1->endCalled);ASSERT_FALSE(l2->endCalled);ASSERT_TRUE(updateListener1->startFraction >= a1StartFraction);ASSERT_TRUE(updateListener2->startFraction >= a2StartFraction);ASSERT_TRUE(a1->IsRunning()  );ASSERT_TRUE(a1->IsRunning()  );ASSERT_TRUE(a2->IsRunning()  );ASSERT_TRUE(a2->IsRunning()  );a1->setCurrentFraction(halfwayFraction);a2->setCurrentFraction(halfwayFraction); }}  );
Thread->sleep(POLL_INTERVAL);
ASSERT_TRUE(l1->startCalled);
ASSERT_TRUE(l2->startCalled);
ASSERT_FALSE(l1->endCalled);
ASSERT_FALSE(l2->endCalled);
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a2->IsRunning()  );
ASSERT_TRUE(a2->IsRunning()  );
ASSERT_TRUE(l1->startCalled);
ASSERT_TRUE(l2->startCalled);
ASSERT_FALSE(l1->endCalled);
ASSERT_FALSE(l2->endCalled);
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a2->IsRunning()  );
ASSERT_TRUE(a2->IsRunning()  );
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_TRUE(l1->startCalled);ASSERT_TRUE(l2->startCalled);ASSERT_FALSE(l1->endCalled);ASSERT_FALSE(l2->endCalled);ASSERT_TRUE(a1->IsRunning()  );ASSERT_TRUE(a1->IsRunning()  );ASSERT_TRUE(a2->IsRunning()  );ASSERT_TRUE(a2->IsRunning()  ); }}  );
long wait=Math->max(a1->getTotalDuration()  ,a2->getTotalDuration()  )  ;
Thread->sleep(wait);
ASSERT_TRUE(l1->endCalled);
ASSERT_TRUE(l2->endCalled);
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a2->IsRunning()  );
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a2->IsRunning()  );
ASSERT_TRUE(l1->endCalled);
ASSERT_TRUE(l2->endCalled);
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a2->IsRunning()  );
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a2->IsRunning()  );
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_TRUE(l1->endCalled);ASSERT_TRUE(l2->endCalled);ASSERT_FALSE(a1->IsRunning()  );ASSERT_FALSE(a2->IsRunning()  );ASSERT_FALSE(a1->IsRunning()  );ASSERT_FALSE(a2->IsRunning()  ); }}  );
updateListener1->reset();
a1->Play();
a1->Play();
mActivityRule->runOnUiThread(new Runnable(){void run() { a1->Play(); }}  );
Thread->sleep(POLL_INTERVAL);
ASSERT_TRUE(updateListener1->wasRunning);
ASSERT_TRUE(updateListener1->startFraction >= 0  );
ASSERT_TRUE(updateListener1->startFraction < halfwayFraction);
a1->Stop();
ASSERT_TRUE(updateListener1->wasRunning);
ASSERT_TRUE(updateListener1->startFraction >= 0  );
ASSERT_TRUE(updateListener1->startFraction < halfwayFraction);
a1->Stop();
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_TRUE(updateListener1->wasRunning);ASSERT_TRUE(updateListener1->startFraction >= 0  );ASSERT_TRUE(updateListener1->startFraction < halfwayFraction);a1->Stop(); }}  );
ValueAnimatorTests::MyListener l1=new ValueAnimatorTests::MyListener()  ;
ValueAnimatorTests::MyListener l2=new ValueAnimatorTests::MyListener()  ;
a1->addListener(l1);
a2->addListener(l2);
ASSERT_FALSE(l1->startCalled);
ASSERT_FALSE(l2->startCalled);
ASSERT_EQ(0f  ,a1->getAnimatedFraction()  );
ASSERT_EQ(0f  ,a2->getAnimatedFraction()  );
a1->Play();
a2->Play();
ASSERT_FALSE(l1->startCalled);
ASSERT_FALSE(l2->startCalled);
ASSERT_EQ(0f  ,a1->getAnimatedFraction()  );
ASSERT_EQ(0f  ,a2->getAnimatedFraction()  );
a1->Play();
a2->Play();
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_FALSE(l1->startCalled);ASSERT_FALSE(l2->startCalled);ASSERT_EQ(0f  ,a1->getAnimatedFraction()  );ASSERT_EQ(0f  ,a2->getAnimatedFraction()  );a1->Play();a2->Play(); }}  );
Thread->sleep(POLL_INTERVAL);
ASSERT_FALSE(l1->endCalled);
ASSERT_FALSE(l2->endCalled);
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a2->IsRunning()  );
a1->setCurrentFraction(0f  );
a2->setCurrentFraction(1f  );
ASSERT_FALSE(l1->endCalled);
ASSERT_FALSE(l2->endCalled);
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a2->IsRunning()  );
a1->setCurrentFraction(0f  );
a2->setCurrentFraction(1f  );
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_FALSE(l1->endCalled);ASSERT_FALSE(l2->endCalled);ASSERT_TRUE(a1->IsRunning()  );ASSERT_TRUE(a2->IsRunning()  );a1->setCurrentFraction(0f  );a2->setCurrentFraction(1f  ); }}  );
Thread->sleep(POLL_INTERVAL);
ASSERT_FALSE(l1->endCalled);
ASSERT_TRUE(l2->endCalled);
ASSERT_EQ(1f  ,a2->getAnimatedFraction()  );
ASSERT_FALSE(l1->endCalled);
ASSERT_TRUE(l2->endCalled);
ASSERT_EQ(1f  ,a2->getAnimatedFraction()  );
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_FALSE(l1->endCalled);ASSERT_TRUE(l2->endCalled);ASSERT_EQ(1f  ,a2->getAnimatedFraction()  ); }}  );
Thread->sleep(a1->getTotalDuration()  );
ASSERT_TRUE(l1->endCalled);
ASSERT_EQ(1f  ,a1->getAnimatedFraction()  );
ASSERT_TRUE(l1->endCalled);
ASSERT_EQ(1f  ,a1->getAnimatedFraction()  );
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_TRUE(l1->endCalled);ASSERT_EQ(1f  ,a1->getAnimatedFraction()  ); }}  );
a1->setStartDelay(20  );
ValueAnimatorTests::MyListener normalEndingListener=new ValueAnimatorTests::MyListener()  ;
a1->addListener(normalEndingListener);
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(normalEndingListener->startCalled);
ASSERT_FALSE(normalEndingListener->endCalled);
a1->Play();
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(normalEndingListener->startCalled);
ASSERT_FALSE(normalEndingListener->endCalled);
a1->Play();
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_FALSE(a1->IsRunning()  );ASSERT_FALSE(normalEndingListener->startCalled);ASSERT_FALSE(normalEndingListener->endCalled);a1->Play(); }}  );
Thread->sleep(a1->getTotalDuration()   + POLL_INTERVAL);
ValueAnimatorTests::MyListener l1=new ValueAnimatorTests::MyListener()  ;
a1->addListener(l1);
ValueAnimatorTests::MyListener l2=new ValueAnimatorTests::MyListener()  ;
a2->addListener(l2);
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(l1->startCalled);
ASSERT_FALSE(l1->endCalled);
ASSERT_FALSE(a2->IsRunning()  );
ASSERT_FALSE(l2->startCalled);
ASSERT_FALSE(l1->endCalled);
a1->Stop();
a2->Stop();
ASSERT_TRUE(l1->startCalled);
ASSERT_TRUE(l1->endCalled);
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_TRUE(l1->endTime >= l1->startTime);
ASSERT_TRUE(l2->startCalled);
ASSERT_TRUE(l2->endCalled);
ASSERT_FALSE(a2->IsRunning()  );
ASSERT_TRUE(l2->endTime >= l1->startTime);
ValueAnimatorTests::MyListener l1=new ValueAnimatorTests::MyListener()  ;
a1->addListener(l1);
ValueAnimatorTests::MyListener l2=new ValueAnimatorTests::MyListener()  ;
a2->addListener(l2);
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(l1->startCalled);
ASSERT_FALSE(l1->endCalled);
ASSERT_FALSE(a2->IsRunning()  );
ASSERT_FALSE(l2->startCalled);
ASSERT_FALSE(l1->endCalled);
a1->Stop();
a2->Stop();
ASSERT_TRUE(l1->startCalled);
ASSERT_TRUE(l1->endCalled);
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_TRUE(l1->endTime >= l1->startTime);
ASSERT_TRUE(l2->startCalled);
ASSERT_TRUE(l2->endCalled);
ASSERT_FALSE(a2->IsRunning()  );
ASSERT_TRUE(l2->endTime >= l1->startTime);
mActivityRule->runOnUiThread(new Runnable(){void run() { ValueAnimatorTests::MyListener l1=new ValueAnimatorTests::MyListener()  ;a1->addListener(l1);ValueAnimatorTests::MyListener l2=new ValueAnimatorTests::MyListener()  ;a2->addListener(l2);ASSERT_FALSE(a1->IsRunning()  );ASSERT_FALSE(l1->startCalled);ASSERT_FALSE(l1->endCalled);ASSERT_FALSE(a2->IsRunning()  );ASSERT_FALSE(l2->startCalled);ASSERT_FALSE(l1->endCalled);a1->Stop();a2->Stop();ASSERT_TRUE(l1->startCalled);ASSERT_TRUE(l1->endCalled);ASSERT_FALSE(a1->IsRunning()  );ASSERT_TRUE(l1->endTime >= l1->startTime);ASSERT_TRUE(l2->startCalled);ASSERT_TRUE(l2->endCalled);ASSERT_FALSE(a2->IsRunning()  );ASSERT_TRUE(l2->endTime >= l1->startTime); }}  );
a1->setDuration(0  );
a2->setDuration(0  );
ACE_EXPORTAnimator *  a3=ValueAnimator->ofInt(0  ,100  )  ;
a3->setDuration(0  );
a3->setCurrentFraction(1.0f  );
ASSERT_EQ(1.0f  ,a3->getAnimatedFraction()  );
ValueAnimatorTests::MyListener l1=new ValueAnimatorTests::MyListener()  ;
ValueAnimatorTests::MyListener l2=new ValueAnimatorTests::MyListener()  ;
ValueAnimatorTests::MyListener l3=new ValueAnimatorTests::MyListener()  ;
a1->addListener(l1);
a2->addListener(l2);
a3->addListener(l3);
ASSERT_FALSE(l1->startCalled);
ASSERT_FALSE(l2->startCalled);
ASSERT_FALSE(l3->startCalled);
ASSERT_FALSE(l1->endCalled);
ASSERT_FALSE(l2->endCalled);
ASSERT_FALSE(l3->endCalled);
a1->Play();
a2->reverse();
a3->Play();
ASSERT_EQ(A1_END_VALUE,a1->getAnimatedValue()  );
ASSERT_EQ(A2_START_VALUE,a2->getAnimatedValue()  );
ASSERT_FALSE(l1->startCalled);
ASSERT_FALSE(l2->startCalled);
ASSERT_FALSE(l3->startCalled);
ASSERT_FALSE(l1->endCalled);
ASSERT_FALSE(l2->endCalled);
ASSERT_FALSE(l3->endCalled);
a1->Play();
a2->reverse();
a3->Play();
ASSERT_EQ(A1_END_VALUE,a1->getAnimatedValue()  );
ASSERT_EQ(A2_START_VALUE,a2->getAnimatedValue()  );
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_FALSE(l1->startCalled);ASSERT_FALSE(l2->startCalled);ASSERT_FALSE(l3->startCalled);ASSERT_FALSE(l1->endCalled);ASSERT_FALSE(l2->endCalled);ASSERT_FALSE(l3->endCalled);a1->Play();a2->reverse();a3->Play();ASSERT_EQ(A1_END_VALUE,a1->getAnimatedValue()  );ASSERT_EQ(A2_START_VALUE,a2->getAnimatedValue()  ); }}  );
Thread->sleep(POLL_INTERVAL);
ASSERT_TRUE(l1->startCalled);
ASSERT_TRUE(l2->startCalled);
ASSERT_TRUE(l3->startCalled);
ASSERT_TRUE(l1->endCalled);
ASSERT_TRUE(l2->endCalled);
ASSERT_TRUE(l3->endCalled);
ASSERT_EQ(1.0f  ,a1->getAnimatedFraction()  );
ASSERT_EQ(0f  ,a2->getAnimatedFraction()  );
ASSERT_EQ(1f  ,a3->getAnimatedFraction()  );
ASSERT_EQ(A1_END_VALUE,a1->getAnimatedValue()  );
ASSERT_EQ(A2_START_VALUE,a2->getAnimatedValue()  );
ASSERT_EQ(100  ,a3->getAnimatedValue()  );
ASSERT_TRUE(l1->startCalled);
ASSERT_TRUE(l2->startCalled);
ASSERT_TRUE(l3->startCalled);
ASSERT_TRUE(l1->endCalled);
ASSERT_TRUE(l2->endCalled);
ASSERT_TRUE(l3->endCalled);
ASSERT_EQ(1.0f  ,a1->getAnimatedFraction()  );
ASSERT_EQ(0f  ,a2->getAnimatedFraction()  );
ASSERT_EQ(1f  ,a3->getAnimatedFraction()  );
ASSERT_EQ(A1_END_VALUE,a1->getAnimatedValue()  );
ASSERT_EQ(A2_START_VALUE,a2->getAnimatedValue()  );
ASSERT_EQ(100  ,a3->getAnimatedValue()  );
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_TRUE(l1->startCalled);ASSERT_TRUE(l2->startCalled);ASSERT_TRUE(l3->startCalled);ASSERT_TRUE(l1->endCalled);ASSERT_TRUE(l2->endCalled);ASSERT_TRUE(l3->endCalled);ASSERT_EQ(1.0f  ,a1->getAnimatedFraction()  );ASSERT_EQ(0f  ,a2->getAnimatedFraction()  );ASSERT_EQ(1f  ,a3->getAnimatedFraction()  );ASSERT_EQ(A1_END_VALUE,a1->getAnimatedValue()  );ASSERT_EQ(A2_START_VALUE,a2->getAnimatedValue()  );ASSERT_EQ(100  ,a3->getAnimatedValue()  ); }}  );
float scale=ValueAnimator->getDurationScale()  ;
ValueAnimator->setDurationScale(0f  );
a1->setStartDelay(200  );
ValueAnimatorTests::MyListener l1=new ValueAnimatorTests::MyListener()  ;
ValueAnimatorTests::MyListener l2=new ValueAnimatorTests::MyListener()  ;
a1->addListener(l1);
a2->addListener(l2);
ASSERT_FALSE(l1->startCalled);
ASSERT_FALSE(l2->startCalled);
ASSERT_FALSE(l1->endCalled);
ASSERT_FALSE(l2->endCalled);
a1->Play();
a2->Play();
ASSERT_EQ(A2_START_VALUE,a2->getAnimatedValue()  );
ASSERT_FALSE(l1->startCalled);
ASSERT_FALSE(l2->startCalled);
ASSERT_FALSE(l1->endCalled);
ASSERT_FALSE(l2->endCalled);
a1->Play();
a2->Play();
ASSERT_EQ(A2_START_VALUE,a2->getAnimatedValue()  );
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_FALSE(l1->startCalled);ASSERT_FALSE(l2->startCalled);ASSERT_FALSE(l1->endCalled);ASSERT_FALSE(l2->endCalled);a1->Play();a2->Play();ASSERT_EQ(A2_START_VALUE,a2->getAnimatedValue()  ); }}  );
Thread->sleep(POLL_INTERVAL);
ASSERT_TRUE(l1->startCalled);
ASSERT_TRUE(l2->startCalled);
ASSERT_TRUE(l1->endCalled);
ASSERT_TRUE(l2->endCalled);
ASSERT_EQ(A1_END_VALUE,a1->getAnimatedValue()  );
ASSERT_EQ(A2_END_VALUE,a2->getAnimatedValue()  );
ASSERT_TRUE(l1->startCalled);
ASSERT_TRUE(l2->startCalled);
ASSERT_TRUE(l1->endCalled);
ASSERT_TRUE(l2->endCalled);
ASSERT_EQ(A1_END_VALUE,a1->getAnimatedValue()  );
ASSERT_EQ(A2_END_VALUE,a2->getAnimatedValue()  );
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_TRUE(l1->startCalled);ASSERT_TRUE(l2->startCalled);ASSERT_TRUE(l1->endCalled);ASSERT_TRUE(l2->endCalled);ASSERT_EQ(A1_END_VALUE,a1->getAnimatedValue()  );ASSERT_EQ(A2_END_VALUE,a2->getAnimatedValue()  ); }}  );
ValueAnimator->setDurationScale(scale);
ACE_EXPORTAnimator *  a3=ValueAnimator->ofInt(0  ,100  )  ;
a1->setDuration(400  );
a2->setDuration(600  );
a3->setDuration(400  );
ValueAnimatorTests::MyListener l1=new ValueAnimatorTests::MyListener()  ;
ValueAnimatorTests::MyListener l2=new ValueAnimatorTests::MyListener()  ;
ValueAnimatorTests::MyListener l3=new ValueAnimatorTests::MyListener()  ;
a1->addListener(l1);
a2->addListener(l2);
a3->addListener(l3);
ASSERT_FALSE(l1->startCalled);
ASSERT_FALSE(l2->startCalled);
ASSERT_FALSE(l3->startCalled);
ASSERT_FALSE(l1->endCalled);
ASSERT_FALSE(l2->endCalled);
ASSERT_FALSE(l3->endCalled);
a1->reverse();
a2->reverse();
a3->reverse();
ASSERT_FALSE(l1->startCalled);
ASSERT_FALSE(l2->startCalled);
ASSERT_FALSE(l3->startCalled);
ASSERT_FALSE(l1->endCalled);
ASSERT_FALSE(l2->endCalled);
ASSERT_FALSE(l3->endCalled);
a1->reverse();
a2->reverse();
a3->reverse();
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_FALSE(l1->startCalled);ASSERT_FALSE(l2->startCalled);ASSERT_FALSE(l3->startCalled);ASSERT_FALSE(l1->endCalled);ASSERT_FALSE(l2->endCalled);ASSERT_FALSE(l3->endCalled);a1->reverse();a2->reverse();a3->reverse(); }}  );
Thread->sleep(POLL_INTERVAL);
ASSERT_TRUE(l1->startCalled);
ASSERT_TRUE(l2->startCalled);
ASSERT_TRUE(l3->startCalled);
a1->setCurrentFraction(0f  );
a2->setCurrentFraction(1f  );
a3->Stop();
ASSERT_EQ(1f  ,a1->getAnimatedFraction()  );
ASSERT_EQ(0f  ,a2->getAnimatedFraction()  );
ASSERT_TRUE(l1->startCalled);
ASSERT_TRUE(l2->startCalled);
ASSERT_TRUE(l3->startCalled);
a1->setCurrentFraction(0f  );
a2->setCurrentFraction(1f  );
a3->Stop();
ASSERT_EQ(1f  ,a1->getAnimatedFraction()  );
ASSERT_EQ(0f  ,a2->getAnimatedFraction()  );
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_TRUE(l1->startCalled);ASSERT_TRUE(l2->startCalled);ASSERT_TRUE(l3->startCalled);a1->setCurrentFraction(0f  );a2->setCurrentFraction(1f  );a3->Stop();ASSERT_EQ(1f  ,a1->getAnimatedFraction()  );ASSERT_EQ(0f  ,a2->getAnimatedFraction()  ); }}  );
Thread->sleep(POLL_INTERVAL);
ASSERT_FALSE(l1->endCalled);
ASSERT_TRUE(l2->endCalled);
ASSERT_TRUE(l3->endCalled);
ASSERT_FALSE(l1->endCalled);
ASSERT_TRUE(l2->endCalled);
ASSERT_TRUE(l3->endCalled);
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_FALSE(l1->endCalled);ASSERT_TRUE(l2->endCalled);ASSERT_TRUE(l3->endCalled); }}  );
Thread->sleep(a1->getTotalDuration()  );
ASSERT_TRUE(l1->endCalled);
ASSERT_EQ(0f  ,a1->getAnimatedFraction()  );
ASSERT_EQ(0f  ,a2->getAnimatedFraction()  );
ASSERT_EQ(0f  ,a3->getAnimatedFraction()  );
ASSERT_TRUE(l1->endCalled);
ASSERT_EQ(0f  ,a1->getAnimatedFraction()  );
ASSERT_EQ(0f  ,a2->getAnimatedFraction()  );
ASSERT_EQ(0f  ,a3->getAnimatedFraction()  );
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_TRUE(l1->endCalled);ASSERT_EQ(0f  ,a1->getAnimatedFraction()  );ASSERT_EQ(0f  ,a2->getAnimatedFraction()  );ASSERT_EQ(0f  ,a3->getAnimatedFraction()  ); }}  );
}
//以下组件没有匹配:
//Runnable
void run()
{
lastUpdateTime=SystemClock->uptimeMillis()  ;
firstRunningFrameTime=lastUpdateTime;
startFraction=animation->getAnimatedFraction()  ;
wasRunning=animation->isRunning()  ;
if(animation->isRunning()   && !wasRunning){ firstRunningFrameTime=lastUpdateTime;startFraction=animation->getAnimatedFraction()  ;wasRunning=animation->isRunning()  ; }
wasRunning=false  ;
firstRunningFrameTime=-1  ;
lastUpdateTime=-1  ;
startFraction=0  ;
startCalled=true  ;
startTime=SystemClock->uptimeMillis()  ;
endCalled=true  ;
endTime=SystemClock->uptimeMillis()  ;
cancelCalled=true  ;
pauseCalled=true  ;
resumeCalled=true  ;
mHandler->sendEmptyMessageDelayed(MSG_FRAME,mFrameDelay);
mFrameCallbacks->add(callback);
if(!mFrameCallbacks->contains(callback)  ){ mFrameCallbacks->add(callback); }
mHandler->postDelayed(runnable,COMMIT_DELAY);
return SystemClock->uptimeMillis()  ;
return mFrameDelay;
mFrameDelay=delay;
mHandler->removeMessages(MSG_FRAME);
mHandler->sendEmptyMessageDelayed(MSG_FRAME,mFrameDelay);
if(mFrameCallbacks->size()   != 0  ){ mHandler->removeMessages(MSG_FRAME);mHandler->sendEmptyMessageDelayed(MSG_FRAME,mFrameDelay); }
Looper->prepare();
mFrameCallbacks->get(i)  -> doFrame(SystemClock->uptimeMillis()  );
for(int i=0  ;i < mFrameCallbacks->size()  ;i++){ mFrameCallbacks->get(i)  -> doFrame(SystemClock->uptimeMillis()  ); }
break;
break;
switch(msg->what){caseMSG_FRAME: for(int i=0  ;i < mFrameCallbacks->size()  ;i++){ mFrameCallbacks->get(i)  -> doFrame(SystemClock->uptimeMillis()  ); }break; default: break; }
{ switch(msg->what){caseMSG_FRAME: for(int i=0  ;i < mFrameCallbacks->size()  ;i++){ mFrameCallbacks->get(i)  -> doFrame(SystemClock->uptimeMillis()  ); }break; default: break; } }
mHandler=new Handler(){void handleMessage(Message *  msg) { { switch(msg->what){caseMSG_FRAME: for(int i=0  ;i < mFrameCallbacks->size()  ;i++){ mFrameCallbacks->get(i)  -> doFrame(SystemClock->uptimeMillis()  ); }break; default: break; } } }}  ;
Looper->loop();
a1=ValueAnimator->ofFloat(A1_START_VALUE,A1_END_VALUE)  -> setDuration(300  );
a2=ValueAnimator->ofInt(A2_START_VALUE,A2_END_VALUE)  -> setDuration(500  );
a1=null  ;
a2=null  ;
ACE_EXPORTAnimator *  a=ValueAnimator->ofFloat(5f  ,20f  )  ;
ASSERT_EQ(a->getStartDelay()  ,0  );
long delay=200  ;
a->setStartDelay(delay);
ASSERT_EQ(a->getStartDelay()  ,delay);
ValueAnimatorTests::MyUpdateListener listener=new ValueAnimatorTests::MyUpdateListener()  ;
a->AddUpdateListener(listener);
long [] startTime= newlong[1] ;
ASSERT_FALSE(a->IsRunning()  );
ASSERT_FALSE(a->IsRunning()  );
a->Play();
startTime[0]=SystemClock->uptimeMillis()  ;
ASSERT_TRUE(a->IsRunning()  );
ASSERT_FALSE(a->IsRunning()  );
ASSERT_FALSE(a->IsRunning()  );
ASSERT_FALSE(a->IsRunning()  );
a->Play();
startTime[0]=SystemClock->uptimeMillis()  ;
ASSERT_TRUE(a->IsRunning()  );
ASSERT_FALSE(a->IsRunning()  );
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_FALSE(a->IsRunning()  );ASSERT_FALSE(a->IsRunning()  );a->Play();startTime[0]=SystemClock->uptimeMillis()  ;ASSERT_TRUE(a->IsRunning()  );ASSERT_FALSE(a->IsRunning()  ); }}  );
Thread->sleep(a->getTotalDuration()  );
ASSERT_TRUE(listener->wasRunning);
ASSERT_TRUE(listener->firstRunningFrameTime - startTime[0]   >= delay);
ASSERT_TRUE(listener->wasRunning);
ASSERT_TRUE(listener->firstRunningFrameTime - startTime[0]   >= delay);
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_TRUE(listener->wasRunning);ASSERT_TRUE(listener->firstRunningFrameTime - startTime[0]   >= delay); }}  );
Thread->sleep(a->getTotalDuration()  );
ASSERT_FALSE(a->IsRunning()  );
ASSERT_FALSE(a->IsRunning()  );
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_FALSE(a->IsRunning()  ); }}  );
ValueAnimatorTests::MyListener l1=new ValueAnimatorTests::MyListener()  ;
ValueAnimatorTests::MyListener l2=new ValueAnimatorTests::MyListener()  ;
a1->addListener(l1);
a2->addListener(l2);
a2->setStartDelay(400  );
ASSERT_FALSE(l1->startCalled);
ASSERT_FALSE(l1->cancelCalled);
ASSERT_FALSE(l1->endCalled);
ASSERT_FALSE(l2->startCalled);
ASSERT_FALSE(l2->cancelCalled);
ASSERT_FALSE(l2->endCalled);
a1->Play();
a2->Play();
a1->Play();
a2->Play();
mActivityRule->runOnUiThread(new Runnable(){void run() { a1->Play();a2->Play(); }}  );
long wait=0  ;
Thread->sleep(POLL_INTERVAL);
wait+=POLL_INTERVAL;
ASSERT_FALSE(l1->cancelCalled);
a1->cancel();
ASSERT_TRUE(l1->cancelCalled);
ASSERT_TRUE(l1->endCalled);
ASSERT_FALSE(l1->cancelCalled);
a1->cancel();
ASSERT_TRUE(l1->cancelCalled);
ASSERT_TRUE(l1->endCalled);
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_FALSE(l1->cancelCalled);a1->cancel();ASSERT_TRUE(l1->cancelCalled);ASSERT_TRUE(l1->endCalled); }}  );
ASSERT_TRUE(l1->startCalled);
ASSERT_FALSE(l2->startCalled);
ASSERT_TRUE(l1->startCalled);
ASSERT_FALSE(l2->startCalled);
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_TRUE(l1->startCalled);ASSERT_FALSE(l2->startCalled); }}  );
Thread->sleep(POLL_INTERVAL);
wait+=POLL_INTERVAL;
while(wait < a2->getStartDelay()  ){ mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_TRUE(l1->startCalled);ASSERT_FALSE(l2->startCalled); }}  );Thread->sleep(POLL_INTERVAL);wait+=POLL_INTERVAL; }
long delay=Math->max(a1->getTotalDuration()  ,a2->getTotalDuration()  )   + TOLERANCE;
Thread->sleep(delay);
ASSERT_TRUE(l1->startCalled);
ASSERT_TRUE(l1->cancelCalled);
ASSERT_TRUE(l1->endCalled);
ASSERT_TRUE(l2->startCalled);
ASSERT_FALSE(l2->cancelCalled);
ASSERT_TRUE(l2->endCalled);
ASSERT_TRUE(l1->startCalled);
ASSERT_TRUE(l1->cancelCalled);
ASSERT_TRUE(l1->endCalled);
ASSERT_TRUE(l2->startCalled);
ASSERT_FALSE(l2->cancelCalled);
ASSERT_TRUE(l2->endCalled);
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_TRUE(l1->startCalled);ASSERT_TRUE(l1->cancelCalled);ASSERT_TRUE(l1->endCalled);ASSERT_TRUE(l2->startCalled);ASSERT_FALSE(l2->cancelCalled);ASSERT_TRUE(l2->endCalled); }}  );
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a2->IsRunning()  );
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a2->IsRunning()  );
long startDelay=150  ;
a1->setStartDelay(startDelay);
long [] startTime= newlong[1] ;
a1->Play();
a2->Play();
startTime[0]=SystemClock->uptimeMillis()  ;
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a2->IsRunning()  );
a1->Play();
a2->Play();
startTime[0]=SystemClock->uptimeMillis()  ;
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a2->IsRunning()  );
mActivityRule->runOnUiThread(new Runnable(){void run() { a1->Play();a2->Play();startTime[0]=SystemClock->uptimeMillis()  ;ASSERT_TRUE(a1->IsRunning()  );ASSERT_TRUE(a2->IsRunning()  ); }}  );
long delayMs=0  ;
Thread->sleep(POLL_INTERVAL);
delayMs+=POLL_INTERVAL;
ASSERT_FALSE(a1->IsRunning()  );
if(SystemClock->uptimeMillis()   - startTime[0]   < startDelay){ ASSERT_FALSE(a1->IsRunning()  ); }
ASSERT_FALSE(a1->IsRunning()  );
if(SystemClock->uptimeMillis()   - startTime[0]   < startDelay){ ASSERT_FALSE(a1->IsRunning()  ); }
mActivityRule->runOnUiThread(new Runnable(){void run() { if(SystemClock->uptimeMillis()   - startTime[0]   < startDelay){ ASSERT_FALSE(a1->IsRunning()  ); } }}  );
while(delayMs < startDelay){ Thread->sleep(POLL_INTERVAL);delayMs+=POLL_INTERVAL;mActivityRule->runOnUiThread(new Runnable(){void run() { if(SystemClock->uptimeMillis()   - startTime[0]   < startDelay){ ASSERT_FALSE(a1->IsRunning()  ); } }}  ); }
Thread->sleep(startDelay);
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a2->IsRunning()  );
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a2->IsRunning()  );
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_TRUE(a1->IsRunning()  );ASSERT_TRUE(a2->IsRunning()  ); }}  );
long delay=Math->max(a1->getTotalDuration()  ,a2->getTotalDuration()  )   * 2  ;
Thread->sleep(delay);
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a2->IsRunning()  );
ASSERT_FALSE(a2->IsRunning()  );
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a2->IsRunning()  );
ASSERT_FALSE(a2->IsRunning()  );
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_FALSE(a1->IsRunning()  );ASSERT_FALSE(a1->IsRunning()  );ASSERT_FALSE(a2->IsRunning()  );ASSERT_FALSE(a2->IsRunning()  ); }}  );
ASSERT_FALSE(a1->IsPending()  );
ASSERT_FALSE(a2->IsPending()  );
a1->Play();
a2->Play();
ASSERT_FALSE(a1->IsPending()  );
ASSERT_FALSE(a2->IsPending()  );
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a2->IsRunning()  );
ASSERT_FALSE(a1->IsPending()  );
ASSERT_FALSE(a2->IsPending()  );
a1->Play();
a2->Play();
ASSERT_FALSE(a1->IsPending()  );
ASSERT_FALSE(a2->IsPending()  );
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a2->IsRunning()  );
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_FALSE(a1->IsPending()  );ASSERT_FALSE(a2->IsPending()  );a1->Play();a2->Play();ASSERT_FALSE(a1->IsPending()  );ASSERT_FALSE(a2->IsPending()  );ASSERT_TRUE(a1->IsRunning()  );ASSERT_TRUE(a2->IsRunning()  ); }}  );
Thread->sleep(POLL_INTERVAL);
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a2->IsRunning()  );
a1->Pause();
ASSERT_TRUE(a1->IsPending()  );
ASSERT_FALSE(a2->IsPending()  );
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a2->IsRunning()  );
a1->Pause();
ASSERT_TRUE(a1->IsPending()  );
ASSERT_FALSE(a2->IsPending()  );
ASSERT_TRUE(a1->IsRunning()  );
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_TRUE(a1->IsRunning()  );ASSERT_TRUE(a2->IsRunning()  );a1->Pause();ASSERT_TRUE(a1->IsPending()  );ASSERT_FALSE(a2->IsPending()  );ASSERT_TRUE(a1->IsRunning()  ); }}  );
Thread->sleep(a2->getTotalDuration()  );
ASSERT_FALSE(a2->IsRunning()  );
ASSERT_FALSE(a2->IsRunning()  );
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a1->IsPending()  );
a1->resume();
ASSERT_FALSE(a2->IsRunning()  );
ASSERT_FALSE(a2->IsRunning()  );
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a1->IsPending()  );
a1->resume();
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_FALSE(a2->IsRunning()  );ASSERT_FALSE(a2->IsRunning()  );ASSERT_TRUE(a1->IsRunning()  );ASSERT_TRUE(a1->IsRunning()  );ASSERT_TRUE(a1->IsPending()  );a1->resume(); }}  );
Thread->sleep(POLL_INTERVAL);
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_FALSE(a1->IsPending()  );
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_FALSE(a1->IsPending()  );
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_TRUE(a1->IsRunning()  );ASSERT_TRUE(a1->IsRunning()  );ASSERT_FALSE(a1->IsPending()  ); }}  );
Thread->sleep(a1->getTotalDuration()  );
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a1->IsPending()  );
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a1->IsPending()  );
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_FALSE(a1->IsRunning()  );ASSERT_FALSE(a1->IsRunning()  );ASSERT_FALSE(a1->IsPending()  ); }}  );
ValueAnimatorTests::MyPauseListener l1=new ValueAnimatorTests::MyPauseListener()  ;
ValueAnimatorTests::MyPauseListener l2=new ValueAnimatorTests::MyPauseListener()  ;
a1->addPauseListener(l1);
a2->addPauseListener(l2);
ASSERT_FALSE(l1->pauseCalled);
ASSERT_FALSE(l1->resumeCalled);
ASSERT_FALSE(l2->pauseCalled);
ASSERT_FALSE(l2->resumeCalled);
a1->Play();
a2->Play();
a1->Play();
a2->Play();
mActivityRule->runOnUiThread(new Runnable(){void run() { a1->Play();a2->Play(); }}  );
Thread->sleep(a1->getTotalDuration()   / 2  );
a1->Pause();
Thread->sleep(a2->getTotalDuration()  );
ASSERT_TRUE(l1->pauseCalled);
ASSERT_FALSE(l1->resumeCalled);
a1->resume();
a1->resume();
mActivityRule->runOnUiThread(new Runnable(){void run() { a1->resume(); }}  );
Thread->sleep(a1->getTotalDuration()  );
ASSERT_TRUE(l1->pauseCalled);
ASSERT_TRUE(l1->resumeCalled);
ASSERT_FALSE(l2->pauseCalled);
ASSERT_FALSE(l2->resumeCalled);
ValueAnimatorTests::MyUpdateListener l1=new ValueAnimatorTests::MyUpdateListener()  ;
long totalDuration=a1->getTotalDuration()  ;
a1->AddUpdateListener(l1);
a1->setDuration(1000  );
ASSERT_TRUE(l1->firstRunningFrameTime < 0  );
ASSERT_TRUE(l1->lastUpdateTime < 0  );
long [] lastUpdate= newlong[1] ;
a1->Play();
a1->Play();
mActivityRule->runOnUiThread(new Runnable(){void run() { a1->Play(); }}  );
Thread->sleep(totalDuration / 2  );
ASSERT_TRUE(l1->firstRunningFrameTime > 0  );
ASSERT_TRUE(l1->lastUpdateTime > l1->firstRunningFrameTime);
lastUpdate[0]=l1->lastUpdateTime;
a1->Pause();
ASSERT_TRUE(l1->firstRunningFrameTime > 0  );
ASSERT_TRUE(l1->lastUpdateTime > l1->firstRunningFrameTime);
lastUpdate[0]=l1->lastUpdateTime;
a1->Pause();
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_TRUE(l1->firstRunningFrameTime > 0  );ASSERT_TRUE(l1->lastUpdateTime > l1->firstRunningFrameTime);lastUpdate[0]=l1->lastUpdateTime;a1->Pause(); }}  );
Thread->sleep(totalDuration);
ASSERT_EQ(lastUpdate[0]  ,l1->lastUpdateTime);
a1->resume();
ASSERT_EQ(lastUpdate[0]  ,l1->lastUpdateTime);
a1->resume();
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_EQ(lastUpdate[0]  ,l1->lastUpdateTime);a1->resume(); }}  );
Thread->sleep(POLL_INTERVAL);
ASSERT_TRUE(l1->lastUpdateTime > lastUpdate[0]  );
lastUpdate[0]=l1->lastUpdateTime;
ASSERT_TRUE(l1->lastUpdateTime > lastUpdate[0]  );
lastUpdate[0]=l1->lastUpdateTime;
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_TRUE(l1->lastUpdateTime > lastUpdate[0]  );lastUpdate[0]=l1->lastUpdateTime; }}  );
do{ Thread->sleep(POLL_INTERVAL);mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_TRUE(l1->lastUpdateTime > lastUpdate[0]  );lastUpdate[0]=l1->lastUpdateTime; }}  ); }while(!a1->IsRunning()  );
long entireSpan=totalDuration * 2  ;
long frameDelta=l1->lastUpdateTime - l1->firstRunningFrameTime;
ASSERT_TRUE(Math->abs(entireSpan - frameDelta)   < TOLERANCE);
ValueAnimatorTests::MyListener l1=new ValueAnimatorTests::MyListener()  ;
ValueAnimatorTests::MyListener l2=new ValueAnimatorTests::MyListener()  ;
a1->addListener(l1);
a2->addListener(l2);
anim->Cancel();
anim->Cancel();
a1->addListener(new ValueAnimatorTests::MyListener(){void onAnimationEnd(ACE_EXPORTAnimator *  anim) { anim->Cancel(); }}  );
anim->end();
anim->end();
a2->addListener(new ValueAnimatorTests::MyListener(){void onAnimationCancel(ACE_EXPORTAnimator *  anim) { anim->end(); }}  );
ASSERT_FALSE(l1->cancelCalled);
ASSERT_FALSE(l1->endCalled);
ASSERT_FALSE(l2->cancelCalled);
ASSERT_FALSE(l2->endCalled);
a1->Play();
a2->Play();
ASSERT_FALSE(l1->cancelCalled);
ASSERT_FALSE(l1->endCalled);
ASSERT_FALSE(l2->cancelCalled);
ASSERT_FALSE(l2->endCalled);
a1->Play();
a2->Play();
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_FALSE(l1->cancelCalled);ASSERT_FALSE(l1->endCalled);ASSERT_FALSE(l2->cancelCalled);ASSERT_FALSE(l2->endCalled);a1->Play();a2->Play(); }}  );
Thread->sleep(POLL_INTERVAL);
a1->Stop();
a2->cancel();
a1->Stop();
a2->cancel();
mActivityRule->runOnUiThread(new Runnable(){void run() { a1->Stop();a2->cancel(); }}  );
Thread->sleep(POLL_INTERVAL);
ASSERT_FALSE(l1->cancelCalled);
ASSERT_TRUE(l1->endCalled);
ASSERT_TRUE(l2->cancelCalled);
ASSERT_TRUE(l2->endCalled);
float value1=(Float)a1.getAnimatedValue();
int value2=(Integer)a2.getAnimatedValue();
ASSERT_EQ(A1_END_VALUE,value1);
ASSERT_EQ(A2_END_VALUE,value2);
ASSERT_FALSE(l1->cancelCalled);
ASSERT_TRUE(l1->endCalled);
ASSERT_TRUE(l2->cancelCalled);
ASSERT_TRUE(l2->endCalled);
float value1=(Float)a1.getAnimatedValue();
int value2=(Integer)a2.getAnimatedValue();
ASSERT_EQ(A1_END_VALUE,value1);
ASSERT_EQ(A2_END_VALUE,value2);
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_FALSE(l1->cancelCalled);ASSERT_TRUE(l1->endCalled);ASSERT_TRUE(l2->cancelCalled);ASSERT_TRUE(l2->endCalled);float value1=(Float)a1.getAnimatedValue();int value2=(Integer)a2.getAnimatedValue();ASSERT_EQ(A1_END_VALUE,value1);ASSERT_EQ(A2_END_VALUE,value2); }}  );
ValueAnimatorTests::MyListener l1=new ValueAnimatorTests::MyListener()  ;
a1->addListener(l1);
ValueAnimatorTests::MyListener l2=new ValueAnimatorTests::MyListener()  ;
a2->addListener(l2);
a1->Play();
a2->Play();
a1->Play();
a2->Play();
mActivityRule->runOnUiThread(new Runnable(){void run() { a1->Play();a2->Play(); }}  );
Thread->sleep(POLL_INTERVAL);
ASSERT_FALSE(l1->endCalled);
ASSERT_FALSE(l2->endCalled);
assertNotEqual(A1_END_VALUE,a1->getAnimatedValue()  );
assertNotEqual(A1_END_VALUE,a2->getAnimatedValue()  );
a2->Stop();
ASSERT_FALSE(l1->endCalled);
ASSERT_FALSE(l2->endCalled);
assertNotEqual(A1_END_VALUE,a1->getAnimatedValue()  );
assertNotEqual(A1_END_VALUE,a2->getAnimatedValue()  );
a2->Stop();
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_FALSE(l1->endCalled);ASSERT_FALSE(l2->endCalled);assertNotEqual(A1_END_VALUE,a1->getAnimatedValue()  );assertNotEqual(A1_END_VALUE,a2->getAnimatedValue()  );a2->Stop(); }}  );
Thread->sleep(a1->getTotalDuration()  );
ASSERT_FALSE(l1->cancelCalled);
ASSERT_TRUE(l1->endCalled);
ASSERT_FALSE(l2->cancelCalled);
ASSERT_TRUE(l2->endCalled);
ASSERT_EQ(A1_END_VALUE,((Float)(a1.getAnimatedValue()))  -> floatValue());
ASSERT_EQ(A2_END_VALUE,((Integer)(a2.getAnimatedValue()))  -> intValue());
ASSERT_FALSE(l1->cancelCalled);
ASSERT_TRUE(l1->endCalled);
ASSERT_FALSE(l2->cancelCalled);
ASSERT_TRUE(l2->endCalled);
ASSERT_EQ(A1_END_VALUE,((Float)(a1.getAnimatedValue()))  -> floatValue());
ASSERT_EQ(A2_END_VALUE,((Integer)(a2.getAnimatedValue()))  -> intValue());
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_FALSE(l1->cancelCalled);ASSERT_TRUE(l1->endCalled);ASSERT_FALSE(l2->cancelCalled);ASSERT_TRUE(l2->endCalled);ASSERT_EQ(A1_END_VALUE,((Float)(a1.getAnimatedValue()))  -> floatValue());ASSERT_EQ(A2_END_VALUE,((Integer)(a2.getAnimatedValue()))  -> intValue()); }}  );
ValueAnimatorTests::MyFrameCallbackProvider provider=new ValueAnimatorTests::MyFrameCallbackProvider()  ;
long sleep=0  ;
Thread->sleep(POLL_INTERVAL);
sleep+=POLL_INTERVAL;
break;
if(sleep > WAIT_TIME_OUT){ break; }
while(provider->mHandler == null  ){ Thread->sleep(POLL_INTERVAL);sleep+=POLL_INTERVAL;if(sleep > WAIT_TIME_OUT){ break; } }
assertNotNull(provider->mHandler);
ValueAnimatorTests::MyListener listener=new ValueAnimatorTests::MyListener()  ;
long currentTime=SystemClock->uptimeMillis()  ;
long frameDelay=provider->getFrameDelay()  ;
ASSERT_TRUE((currentTime-lastUpdateTime)   < frameDelay * 4  );
ASSERT_TRUE(listener->startCalled);
ASSERT_TRUE(listener->startTime > 0  );
ASSERT_TRUE(currentTime - listener->startTime < frameDelay * 4  );
if(lastUpdateTime > 0  ){ ASSERT_TRUE((currentTime-lastUpdateTime)   < frameDelay * 4  ); }else{ ASSERT_TRUE(listener->startCalled);ASSERT_TRUE(listener->startTime > 0  );ASSERT_TRUE(currentTime - listener->startTime < frameDelay * 4  ); }
super-> onAnimationUpdate(animation);
ValueAnimatorTests::MyUpdateListener l1=new ValueAnimatorTests::MyUpdateListener(){void onAnimationUpdate(ACE_EXPORTAnimator *  animation) { long currentTime=SystemClock->uptimeMillis()  ;long frameDelay=provider->getFrameDelay()  ;if(lastUpdateTime > 0  ){ ASSERT_TRUE((currentTime-lastUpdateTime)   < frameDelay * 4  ); }else{ ASSERT_TRUE(listener->startCalled);ASSERT_TRUE(listener->startTime > 0  );ASSERT_TRUE(currentTime - listener->startTime < frameDelay * 4  ); }super-> onAnimationUpdate(animation); }}  ;
a1->AddUpdateListener(l1);
a1->addListener(listener);
a1->setStartDelay(100  );
AnimationHandler->getInstance()  -> setProvider(provider);
a1->Play();
AnimationHandler->getInstance()  -> setProvider(provider);
a1->Play();
provider.mHandler->post(new Runnable(){void run() { AnimationHandler->getInstance()  -> setProvider(provider);a1->Play(); }}  );
Thread->sleep(POLL_INTERVAL);
ASSERT_TRUE(a1->IsRunning()  );
Thread->sleep(a1->getTotalDuration()   + TOLERANCE);
throwprovider->mAssertionError;
if(provider->mAssertionError != null  ){ throwprovider->mAssertionError; }
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_TRUE(listener->endTime > 0  );
ASSERT_TRUE(listener->endTime >= l1->lastUpdateTime);
ASSERT_TRUE(listener->endTime - l1->lastUpdateTime < 2   * provider->getFrameDelay()  );
ACE_EXPORTAnimator *  a0=ValueAnimator->ofInt(100  ,200  )  -> setDuration(500  );
ACE_EXPORTAnimator *  a3=ValueAnimator->ofFloat(0  ,1  )  -> setDuration(500  );
ACE_EXPORTAnimator *  a4=ValueAnimator->ofInt(200  ,300  )  -> setDuration(500  );
super-> onAnimationEnd(anim);
a0->cancel();
a1->Stop();
a3->Stop();
a4->cancel();
ValueAnimatorTests::MyListener listener=new ValueAnimatorTests::MyListener(){void onAnimationEnd(ACE_EXPORTAnimator *  anim) { super-> onAnimationEnd(anim);a0->cancel();a1->Stop();a3->Stop();a4->cancel(); }}  ;
a2->addListener(listener);
a0->Play();
a1->Play();
a2->Play();
a3->Play();
a4->Play();
a0->Play();
a1->Play();
a2->Play();
a3->Play();
a4->Play();
mActivityRule->runOnUiThread(new Runnable(){void run() { a0->Play();a1->Play();a2->Play();a3->Play();a4->Play(); }}  );
ASSERT_TRUE(a0->IsRunning()  );
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a2->IsRunning()  );
ASSERT_TRUE(a3->IsRunning()  );
ASSERT_TRUE(a4->IsRunning()  );
ASSERT_TRUE(a0->IsRunning()  );
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a2->IsRunning()  );
ASSERT_TRUE(a3->IsRunning()  );
ASSERT_TRUE(a4->IsRunning()  );
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_TRUE(a0->IsRunning()  );ASSERT_TRUE(a1->IsRunning()  );ASSERT_TRUE(a2->IsRunning()  );ASSERT_TRUE(a3->IsRunning()  );ASSERT_TRUE(a4->IsRunning()  ); }}  );
Thread->sleep(POLL_INTERVAL);
a2->Stop();
a2->Stop();
mActivityRule->runOnUiThread(new Runnable(){void run() { a2->Stop(); }}  );
Thread->sleep(POLL_INTERVAL);
ASSERT_TRUE(listener->endCalled);
ASSERT_FALSE(a0->IsRunning()  );
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a2->IsRunning()  );
ASSERT_FALSE(a3->IsRunning()  );
ASSERT_FALSE(a4->IsRunning()  );
ValueAnimatorTests::MyListener l1=new ValueAnimatorTests::MyListener()  ;
ValueAnimatorTests::MyListener l2=new ValueAnimatorTests::MyListener()  ;
ValueAnimatorTests::MyUpdateListener updateListener1=new ValueAnimatorTests::MyUpdateListener()  ;
ValueAnimatorTests::MyUpdateListener updateListener2=new ValueAnimatorTests::MyUpdateListener()  ;
float a1StartFraction=0.2f  ;
float a2StartFraction=0.3f  ;
a1->setDuration(1000  );
a2->setDuration(1000  );
a1->addListener(l1);
a2->addListener(l2);
a1->AddUpdateListener(updateListener1);
a2->AddUpdateListener(updateListener2);
//以下组件没有匹配:
//TimeInterpolator,LinearInterpolator
TimeInterpolator *  interpolator=new LinearInterpolator()  ;
a1->setInterpolator(interpolator);
a2->setInterpolator(interpolator);
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a2->IsRunning()  );
ASSERT_FALSE(a2->IsRunning()  );
a1->setCurrentFraction(a1StartFraction);
a2->setCurrentFraction(a2StartFraction);
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a2->IsRunning()  );
ASSERT_FALSE(a2->IsRunning()  );
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a2->IsRunning()  );
ASSERT_FALSE(a2->IsRunning()  );
a1->setCurrentFraction(a1StartFraction);
a2->setCurrentFraction(a2StartFraction);
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a2->IsRunning()  );
ASSERT_FALSE(a2->IsRunning()  );
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_FALSE(a1->IsRunning()  );ASSERT_FALSE(a1->IsRunning()  );ASSERT_FALSE(a2->IsRunning()  );ASSERT_FALSE(a2->IsRunning()  );a1->setCurrentFraction(a1StartFraction);a2->setCurrentFraction(a2StartFraction);ASSERT_FALSE(a1->IsRunning()  );ASSERT_FALSE(a1->IsRunning()  );ASSERT_FALSE(a2->IsRunning()  );ASSERT_FALSE(a2->IsRunning()  ); }}  );
Thread->sleep(POLL_INTERVAL);
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a2->IsRunning()  );
ASSERT_FALSE(a2->IsRunning()  );
ASSERT_EQ(a1StartFraction,a1->getAnimatedFraction()  );
ASSERT_EQ(a2StartFraction,a2->getAnimatedFraction()  );
a1->Play();
a2->Play();
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a2->IsRunning()  );
ASSERT_FALSE(a2->IsRunning()  );
ASSERT_EQ(a1StartFraction,a1->getAnimatedFraction()  );
ASSERT_EQ(a2StartFraction,a2->getAnimatedFraction()  );
a1->Play();
a2->Play();
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_FALSE(a1->IsRunning()  );ASSERT_FALSE(a1->IsRunning()  );ASSERT_FALSE(a2->IsRunning()  );ASSERT_FALSE(a2->IsRunning()  );ASSERT_EQ(a1StartFraction,a1->getAnimatedFraction()  );ASSERT_EQ(a2StartFraction,a2->getAnimatedFraction()  );a1->Play();a2->Play(); }}  );
Thread->sleep(POLL_INTERVAL);
float halfwayFraction=0.5f  ;
ASSERT_TRUE(l1->startCalled);
ASSERT_TRUE(l2->startCalled);
ASSERT_FALSE(l1->endCalled);
ASSERT_FALSE(l2->endCalled);
ASSERT_TRUE(updateListener1->startFraction >= a1StartFraction);
ASSERT_TRUE(updateListener2->startFraction >= a2StartFraction);
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a2->IsRunning()  );
ASSERT_TRUE(a2->IsRunning()  );
a1->setCurrentFraction(halfwayFraction);
a2->setCurrentFraction(halfwayFraction);
ASSERT_TRUE(l1->startCalled);
ASSERT_TRUE(l2->startCalled);
ASSERT_FALSE(l1->endCalled);
ASSERT_FALSE(l2->endCalled);
ASSERT_TRUE(updateListener1->startFraction >= a1StartFraction);
ASSERT_TRUE(updateListener2->startFraction >= a2StartFraction);
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a2->IsRunning()  );
ASSERT_TRUE(a2->IsRunning()  );
a1->setCurrentFraction(halfwayFraction);
a2->setCurrentFraction(halfwayFraction);
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_TRUE(l1->startCalled);ASSERT_TRUE(l2->startCalled);ASSERT_FALSE(l1->endCalled);ASSERT_FALSE(l2->endCalled);ASSERT_TRUE(updateListener1->startFraction >= a1StartFraction);ASSERT_TRUE(updateListener2->startFraction >= a2StartFraction);ASSERT_TRUE(a1->IsRunning()  );ASSERT_TRUE(a1->IsRunning()  );ASSERT_TRUE(a2->IsRunning()  );ASSERT_TRUE(a2->IsRunning()  );a1->setCurrentFraction(halfwayFraction);a2->setCurrentFraction(halfwayFraction); }}  );
Thread->sleep(POLL_INTERVAL);
ASSERT_TRUE(l1->startCalled);
ASSERT_TRUE(l2->startCalled);
ASSERT_FALSE(l1->endCalled);
ASSERT_FALSE(l2->endCalled);
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a2->IsRunning()  );
ASSERT_TRUE(a2->IsRunning()  );
ASSERT_TRUE(l1->startCalled);
ASSERT_TRUE(l2->startCalled);
ASSERT_FALSE(l1->endCalled);
ASSERT_FALSE(l2->endCalled);
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a2->IsRunning()  );
ASSERT_TRUE(a2->IsRunning()  );
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_TRUE(l1->startCalled);ASSERT_TRUE(l2->startCalled);ASSERT_FALSE(l1->endCalled);ASSERT_FALSE(l2->endCalled);ASSERT_TRUE(a1->IsRunning()  );ASSERT_TRUE(a1->IsRunning()  );ASSERT_TRUE(a2->IsRunning()  );ASSERT_TRUE(a2->IsRunning()  ); }}  );
long wait=Math->max(a1->getTotalDuration()  ,a2->getTotalDuration()  )  ;
Thread->sleep(wait);
ASSERT_TRUE(l1->endCalled);
ASSERT_TRUE(l2->endCalled);
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a2->IsRunning()  );
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a2->IsRunning()  );
ASSERT_TRUE(l1->endCalled);
ASSERT_TRUE(l2->endCalled);
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a2->IsRunning()  );
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a2->IsRunning()  );
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_TRUE(l1->endCalled);ASSERT_TRUE(l2->endCalled);ASSERT_FALSE(a1->IsRunning()  );ASSERT_FALSE(a2->IsRunning()  );ASSERT_FALSE(a1->IsRunning()  );ASSERT_FALSE(a2->IsRunning()  ); }}  );
updateListener1->reset();
a1->Play();
a1->Play();
mActivityRule->runOnUiThread(new Runnable(){void run() { a1->Play(); }}  );
Thread->sleep(POLL_INTERVAL);
ASSERT_TRUE(updateListener1->wasRunning);
ASSERT_TRUE(updateListener1->startFraction >= 0  );
ASSERT_TRUE(updateListener1->startFraction < halfwayFraction);
a1->Stop();
ASSERT_TRUE(updateListener1->wasRunning);
ASSERT_TRUE(updateListener1->startFraction >= 0  );
ASSERT_TRUE(updateListener1->startFraction < halfwayFraction);
a1->Stop();
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_TRUE(updateListener1->wasRunning);ASSERT_TRUE(updateListener1->startFraction >= 0  );ASSERT_TRUE(updateListener1->startFraction < halfwayFraction);a1->Stop(); }}  );
ValueAnimatorTests::MyListener l1=new ValueAnimatorTests::MyListener()  ;
ValueAnimatorTests::MyListener l2=new ValueAnimatorTests::MyListener()  ;
a1->addListener(l1);
a2->addListener(l2);
ASSERT_FALSE(l1->startCalled);
ASSERT_FALSE(l2->startCalled);
ASSERT_EQ(0f  ,a1->getAnimatedFraction()  );
ASSERT_EQ(0f  ,a2->getAnimatedFraction()  );
a1->Play();
a2->Play();
ASSERT_FALSE(l1->startCalled);
ASSERT_FALSE(l2->startCalled);
ASSERT_EQ(0f  ,a1->getAnimatedFraction()  );
ASSERT_EQ(0f  ,a2->getAnimatedFraction()  );
a1->Play();
a2->Play();
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_FALSE(l1->startCalled);ASSERT_FALSE(l2->startCalled);ASSERT_EQ(0f  ,a1->getAnimatedFraction()  );ASSERT_EQ(0f  ,a2->getAnimatedFraction()  );a1->Play();a2->Play(); }}  );
Thread->sleep(POLL_INTERVAL);
ASSERT_FALSE(l1->endCalled);
ASSERT_FALSE(l2->endCalled);
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a2->IsRunning()  );
a1->setCurrentFraction(0f  );
a2->setCurrentFraction(1f  );
ASSERT_FALSE(l1->endCalled);
ASSERT_FALSE(l2->endCalled);
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a2->IsRunning()  );
a1->setCurrentFraction(0f  );
a2->setCurrentFraction(1f  );
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_FALSE(l1->endCalled);ASSERT_FALSE(l2->endCalled);ASSERT_TRUE(a1->IsRunning()  );ASSERT_TRUE(a2->IsRunning()  );a1->setCurrentFraction(0f  );a2->setCurrentFraction(1f  ); }}  );
Thread->sleep(POLL_INTERVAL);
ASSERT_FALSE(l1->endCalled);
ASSERT_TRUE(l2->endCalled);
ASSERT_EQ(1f  ,a2->getAnimatedFraction()  );
ASSERT_FALSE(l1->endCalled);
ASSERT_TRUE(l2->endCalled);
ASSERT_EQ(1f  ,a2->getAnimatedFraction()  );
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_FALSE(l1->endCalled);ASSERT_TRUE(l2->endCalled);ASSERT_EQ(1f  ,a2->getAnimatedFraction()  ); }}  );
Thread->sleep(a1->getTotalDuration()  );
ASSERT_TRUE(l1->endCalled);
ASSERT_EQ(1f  ,a1->getAnimatedFraction()  );
ASSERT_TRUE(l1->endCalled);
ASSERT_EQ(1f  ,a1->getAnimatedFraction()  );
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_TRUE(l1->endCalled);ASSERT_EQ(1f  ,a1->getAnimatedFraction()  ); }}  );
a1->setStartDelay(20  );
ValueAnimatorTests::MyListener normalEndingListener=new ValueAnimatorTests::MyListener()  ;
a1->addListener(normalEndingListener);
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(normalEndingListener->startCalled);
ASSERT_FALSE(normalEndingListener->endCalled);
a1->Play();
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(normalEndingListener->startCalled);
ASSERT_FALSE(normalEndingListener->endCalled);
a1->Play();
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_FALSE(a1->IsRunning()  );ASSERT_FALSE(normalEndingListener->startCalled);ASSERT_FALSE(normalEndingListener->endCalled);a1->Play(); }}  );
Thread->sleep(a1->getTotalDuration()   + POLL_INTERVAL);
ValueAnimatorTests::MyListener l1=new ValueAnimatorTests::MyListener()  ;
a1->addListener(l1);
ValueAnimatorTests::MyListener l2=new ValueAnimatorTests::MyListener()  ;
a2->addListener(l2);
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(l1->startCalled);
ASSERT_FALSE(l1->endCalled);
ASSERT_FALSE(a2->IsRunning()  );
ASSERT_FALSE(l2->startCalled);
ASSERT_FALSE(l1->endCalled);
a1->Stop();
a2->Stop();
ASSERT_TRUE(l1->startCalled);
ASSERT_TRUE(l1->endCalled);
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_TRUE(l1->endTime >= l1->startTime);
ASSERT_TRUE(l2->startCalled);
ASSERT_TRUE(l2->endCalled);
ASSERT_FALSE(a2->IsRunning()  );
ASSERT_TRUE(l2->endTime >= l1->startTime);
ValueAnimatorTests::MyListener l1=new ValueAnimatorTests::MyListener()  ;
a1->addListener(l1);
ValueAnimatorTests::MyListener l2=new ValueAnimatorTests::MyListener()  ;
a2->addListener(l2);
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(l1->startCalled);
ASSERT_FALSE(l1->endCalled);
ASSERT_FALSE(a2->IsRunning()  );
ASSERT_FALSE(l2->startCalled);
ASSERT_FALSE(l1->endCalled);
a1->Stop();
a2->Stop();
ASSERT_TRUE(l1->startCalled);
ASSERT_TRUE(l1->endCalled);
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_TRUE(l1->endTime >= l1->startTime);
ASSERT_TRUE(l2->startCalled);
ASSERT_TRUE(l2->endCalled);
ASSERT_FALSE(a2->IsRunning()  );
ASSERT_TRUE(l2->endTime >= l1->startTime);
mActivityRule->runOnUiThread(new Runnable(){void run() { ValueAnimatorTests::MyListener l1=new ValueAnimatorTests::MyListener()  ;a1->addListener(l1);ValueAnimatorTests::MyListener l2=new ValueAnimatorTests::MyListener()  ;a2->addListener(l2);ASSERT_FALSE(a1->IsRunning()  );ASSERT_FALSE(l1->startCalled);ASSERT_FALSE(l1->endCalled);ASSERT_FALSE(a2->IsRunning()  );ASSERT_FALSE(l2->startCalled);ASSERT_FALSE(l1->endCalled);a1->Stop();a2->Stop();ASSERT_TRUE(l1->startCalled);ASSERT_TRUE(l1->endCalled);ASSERT_FALSE(a1->IsRunning()  );ASSERT_TRUE(l1->endTime >= l1->startTime);ASSERT_TRUE(l2->startCalled);ASSERT_TRUE(l2->endCalled);ASSERT_FALSE(a2->IsRunning()  );ASSERT_TRUE(l2->endTime >= l1->startTime); }}  );
a1->setDuration(0  );
a2->setDuration(0  );
ACE_EXPORTAnimator *  a3=ValueAnimator->ofInt(0  ,100  )  ;
a3->setDuration(0  );
a3->setCurrentFraction(1.0f  );
ASSERT_EQ(1.0f  ,a3->getAnimatedFraction()  );
ValueAnimatorTests::MyListener l1=new ValueAnimatorTests::MyListener()  ;
ValueAnimatorTests::MyListener l2=new ValueAnimatorTests::MyListener()  ;
ValueAnimatorTests::MyListener l3=new ValueAnimatorTests::MyListener()  ;
a1->addListener(l1);
a2->addListener(l2);
a3->addListener(l3);
ASSERT_FALSE(l1->startCalled);
ASSERT_FALSE(l2->startCalled);
ASSERT_FALSE(l3->startCalled);
ASSERT_FALSE(l1->endCalled);
ASSERT_FALSE(l2->endCalled);
ASSERT_FALSE(l3->endCalled);
a1->Play();
a2->reverse();
a3->Play();
ASSERT_EQ(A1_END_VALUE,a1->getAnimatedValue()  );
ASSERT_EQ(A2_START_VALUE,a2->getAnimatedValue()  );
ASSERT_FALSE(l1->startCalled);
ASSERT_FALSE(l2->startCalled);
ASSERT_FALSE(l3->startCalled);
ASSERT_FALSE(l1->endCalled);
ASSERT_FALSE(l2->endCalled);
ASSERT_FALSE(l3->endCalled);
a1->Play();
a2->reverse();
a3->Play();
ASSERT_EQ(A1_END_VALUE,a1->getAnimatedValue()  );
ASSERT_EQ(A2_START_VALUE,a2->getAnimatedValue()  );
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_FALSE(l1->startCalled);ASSERT_FALSE(l2->startCalled);ASSERT_FALSE(l3->startCalled);ASSERT_FALSE(l1->endCalled);ASSERT_FALSE(l2->endCalled);ASSERT_FALSE(l3->endCalled);a1->Play();a2->reverse();a3->Play();ASSERT_EQ(A1_END_VALUE,a1->getAnimatedValue()  );ASSERT_EQ(A2_START_VALUE,a2->getAnimatedValue()  ); }}  );
Thread->sleep(POLL_INTERVAL);
ASSERT_TRUE(l1->startCalled);
ASSERT_TRUE(l2->startCalled);
ASSERT_TRUE(l3->startCalled);
ASSERT_TRUE(l1->endCalled);
ASSERT_TRUE(l2->endCalled);
ASSERT_TRUE(l3->endCalled);
ASSERT_EQ(1.0f  ,a1->getAnimatedFraction()  );
ASSERT_EQ(0f  ,a2->getAnimatedFraction()  );
ASSERT_EQ(1f  ,a3->getAnimatedFraction()  );
ASSERT_EQ(A1_END_VALUE,a1->getAnimatedValue()  );
ASSERT_EQ(A2_START_VALUE,a2->getAnimatedValue()  );
ASSERT_EQ(100  ,a3->getAnimatedValue()  );
ASSERT_TRUE(l1->startCalled);
ASSERT_TRUE(l2->startCalled);
ASSERT_TRUE(l3->startCalled);
ASSERT_TRUE(l1->endCalled);
ASSERT_TRUE(l2->endCalled);
ASSERT_TRUE(l3->endCalled);
ASSERT_EQ(1.0f  ,a1->getAnimatedFraction()  );
ASSERT_EQ(0f  ,a2->getAnimatedFraction()  );
ASSERT_EQ(1f  ,a3->getAnimatedFraction()  );
ASSERT_EQ(A1_END_VALUE,a1->getAnimatedValue()  );
ASSERT_EQ(A2_START_VALUE,a2->getAnimatedValue()  );
ASSERT_EQ(100  ,a3->getAnimatedValue()  );
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_TRUE(l1->startCalled);ASSERT_TRUE(l2->startCalled);ASSERT_TRUE(l3->startCalled);ASSERT_TRUE(l1->endCalled);ASSERT_TRUE(l2->endCalled);ASSERT_TRUE(l3->endCalled);ASSERT_EQ(1.0f  ,a1->getAnimatedFraction()  );ASSERT_EQ(0f  ,a2->getAnimatedFraction()  );ASSERT_EQ(1f  ,a3->getAnimatedFraction()  );ASSERT_EQ(A1_END_VALUE,a1->getAnimatedValue()  );ASSERT_EQ(A2_START_VALUE,a2->getAnimatedValue()  );ASSERT_EQ(100  ,a3->getAnimatedValue()  ); }}  );
float scale=ValueAnimator->getDurationScale()  ;
ValueAnimator->setDurationScale(0f  );
a1->setStartDelay(200  );
ValueAnimatorTests::MyListener l1=new ValueAnimatorTests::MyListener()  ;
ValueAnimatorTests::MyListener l2=new ValueAnimatorTests::MyListener()  ;
a1->addListener(l1);
a2->addListener(l2);
ASSERT_FALSE(l1->startCalled);
ASSERT_FALSE(l2->startCalled);
ASSERT_FALSE(l1->endCalled);
ASSERT_FALSE(l2->endCalled);
a1->Play();
a2->Play();
ASSERT_EQ(A2_START_VALUE,a2->getAnimatedValue()  );
ASSERT_FALSE(l1->startCalled);
ASSERT_FALSE(l2->startCalled);
ASSERT_FALSE(l1->endCalled);
ASSERT_FALSE(l2->endCalled);
a1->Play();
a2->Play();
ASSERT_EQ(A2_START_VALUE,a2->getAnimatedValue()  );
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_FALSE(l1->startCalled);ASSERT_FALSE(l2->startCalled);ASSERT_FALSE(l1->endCalled);ASSERT_FALSE(l2->endCalled);a1->Play();a2->Play();ASSERT_EQ(A2_START_VALUE,a2->getAnimatedValue()  ); }}  );
Thread->sleep(POLL_INTERVAL);
ASSERT_TRUE(l1->startCalled);
ASSERT_TRUE(l2->startCalled);
ASSERT_TRUE(l1->endCalled);
ASSERT_TRUE(l2->endCalled);
ASSERT_EQ(A1_END_VALUE,a1->getAnimatedValue()  );
ASSERT_EQ(A2_END_VALUE,a2->getAnimatedValue()  );
ASSERT_TRUE(l1->startCalled);
ASSERT_TRUE(l2->startCalled);
ASSERT_TRUE(l1->endCalled);
ASSERT_TRUE(l2->endCalled);
ASSERT_EQ(A1_END_VALUE,a1->getAnimatedValue()  );
ASSERT_EQ(A2_END_VALUE,a2->getAnimatedValue()  );
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_TRUE(l1->startCalled);ASSERT_TRUE(l2->startCalled);ASSERT_TRUE(l1->endCalled);ASSERT_TRUE(l2->endCalled);ASSERT_EQ(A1_END_VALUE,a1->getAnimatedValue()  );ASSERT_EQ(A2_END_VALUE,a2->getAnimatedValue()  ); }}  );
ValueAnimator->setDurationScale(scale);
ACE_EXPORTAnimator *  a3=ValueAnimator->ofInt(0  ,100  )  ;
a1->setDuration(400  );
a2->setDuration(600  );
a3->setDuration(400  );
ValueAnimatorTests::MyListener l1=new ValueAnimatorTests::MyListener()  ;
ValueAnimatorTests::MyListener l2=new ValueAnimatorTests::MyListener()  ;
ValueAnimatorTests::MyListener l3=new ValueAnimatorTests::MyListener()  ;
a1->addListener(l1);
a2->addListener(l2);
a3->addListener(l3);
ASSERT_FALSE(l1->startCalled);
ASSERT_FALSE(l2->startCalled);
ASSERT_FALSE(l3->startCalled);
ASSERT_FALSE(l1->endCalled);
ASSERT_FALSE(l2->endCalled);
ASSERT_FALSE(l3->endCalled);
a1->reverse();
a2->reverse();
a3->reverse();
ASSERT_FALSE(l1->startCalled);
ASSERT_FALSE(l2->startCalled);
ASSERT_FALSE(l3->startCalled);
ASSERT_FALSE(l1->endCalled);
ASSERT_FALSE(l2->endCalled);
ASSERT_FALSE(l3->endCalled);
a1->reverse();
a2->reverse();
a3->reverse();
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_FALSE(l1->startCalled);ASSERT_FALSE(l2->startCalled);ASSERT_FALSE(l3->startCalled);ASSERT_FALSE(l1->endCalled);ASSERT_FALSE(l2->endCalled);ASSERT_FALSE(l3->endCalled);a1->reverse();a2->reverse();a3->reverse(); }}  );
Thread->sleep(POLL_INTERVAL);
ASSERT_TRUE(l1->startCalled);
ASSERT_TRUE(l2->startCalled);
ASSERT_TRUE(l3->startCalled);
a1->setCurrentFraction(0f  );
a2->setCurrentFraction(1f  );
a3->Stop();
ASSERT_EQ(1f  ,a1->getAnimatedFraction()  );
ASSERT_EQ(0f  ,a2->getAnimatedFraction()  );
ASSERT_TRUE(l1->startCalled);
ASSERT_TRUE(l2->startCalled);
ASSERT_TRUE(l3->startCalled);
a1->setCurrentFraction(0f  );
a2->setCurrentFraction(1f  );
a3->Stop();
ASSERT_EQ(1f  ,a1->getAnimatedFraction()  );
ASSERT_EQ(0f  ,a2->getAnimatedFraction()  );
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_TRUE(l1->startCalled);ASSERT_TRUE(l2->startCalled);ASSERT_TRUE(l3->startCalled);a1->setCurrentFraction(0f  );a2->setCurrentFraction(1f  );a3->Stop();ASSERT_EQ(1f  ,a1->getAnimatedFraction()  );ASSERT_EQ(0f  ,a2->getAnimatedFraction()  ); }}  );
Thread->sleep(POLL_INTERVAL);
ASSERT_FALSE(l1->endCalled);
ASSERT_TRUE(l2->endCalled);
ASSERT_TRUE(l3->endCalled);
ASSERT_FALSE(l1->endCalled);
ASSERT_TRUE(l2->endCalled);
ASSERT_TRUE(l3->endCalled);
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_FALSE(l1->endCalled);ASSERT_TRUE(l2->endCalled);ASSERT_TRUE(l3->endCalled); }}  );
Thread->sleep(a1->getTotalDuration()  );
ASSERT_TRUE(l1->endCalled);
ASSERT_EQ(0f  ,a1->getAnimatedFraction()  );
ASSERT_EQ(0f  ,a2->getAnimatedFraction()  );
ASSERT_EQ(0f  ,a3->getAnimatedFraction()  );
ASSERT_TRUE(l1->endCalled);
ASSERT_EQ(0f  ,a1->getAnimatedFraction()  );
ASSERT_EQ(0f  ,a2->getAnimatedFraction()  );
ASSERT_EQ(0f  ,a3->getAnimatedFraction()  );
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_TRUE(l1->endCalled);ASSERT_EQ(0f  ,a1->getAnimatedFraction()  );ASSERT_EQ(0f  ,a2->getAnimatedFraction()  );ASSERT_EQ(0f  ,a3->getAnimatedFraction()  ); }}  );
}
//以下组件没有匹配:
//Runnable
void run()
{
lastUpdateTime=SystemClock->uptimeMillis()  ;
firstRunningFrameTime=lastUpdateTime;
startFraction=animation->getAnimatedFraction()  ;
wasRunning=animation->isRunning()  ;
if(animation->isRunning()   && !wasRunning){ firstRunningFrameTime=lastUpdateTime;startFraction=animation->getAnimatedFraction()  ;wasRunning=animation->isRunning()  ; }
wasRunning=false  ;
firstRunningFrameTime=-1  ;
lastUpdateTime=-1  ;
startFraction=0  ;
startCalled=true  ;
startTime=SystemClock->uptimeMillis()  ;
endCalled=true  ;
endTime=SystemClock->uptimeMillis()  ;
cancelCalled=true  ;
pauseCalled=true  ;
resumeCalled=true  ;
mHandler->sendEmptyMessageDelayed(MSG_FRAME,mFrameDelay);
mFrameCallbacks->add(callback);
if(!mFrameCallbacks->contains(callback)  ){ mFrameCallbacks->add(callback); }
mHandler->postDelayed(runnable,COMMIT_DELAY);
return SystemClock->uptimeMillis()  ;
return mFrameDelay;
mFrameDelay=delay;
mHandler->removeMessages(MSG_FRAME);
mHandler->sendEmptyMessageDelayed(MSG_FRAME,mFrameDelay);
if(mFrameCallbacks->size()   != 0  ){ mHandler->removeMessages(MSG_FRAME);mHandler->sendEmptyMessageDelayed(MSG_FRAME,mFrameDelay); }
Looper->prepare();
mFrameCallbacks->get(i)  -> doFrame(SystemClock->uptimeMillis()  );
for(int i=0  ;i < mFrameCallbacks->size()  ;i++){ mFrameCallbacks->get(i)  -> doFrame(SystemClock->uptimeMillis()  ); }
break;
break;
switch(msg->what){caseMSG_FRAME: for(int i=0  ;i < mFrameCallbacks->size()  ;i++){ mFrameCallbacks->get(i)  -> doFrame(SystemClock->uptimeMillis()  ); }break; default: break; }
{ switch(msg->what){caseMSG_FRAME: for(int i=0  ;i < mFrameCallbacks->size()  ;i++){ mFrameCallbacks->get(i)  -> doFrame(SystemClock->uptimeMillis()  ); }break; default: break; } }
mHandler=new Handler(){void handleMessage(Message *  msg) { { switch(msg->what){caseMSG_FRAME: for(int i=0  ;i < mFrameCallbacks->size()  ;i++){ mFrameCallbacks->get(i)  -> doFrame(SystemClock->uptimeMillis()  ); }break; default: break; } } }}  ;
Looper->loop();
a1=ValueAnimator->ofFloat(A1_START_VALUE,A1_END_VALUE)  -> setDuration(300  );
a2=ValueAnimator->ofInt(A2_START_VALUE,A2_END_VALUE)  -> setDuration(500  );
a1=null  ;
a2=null  ;
ACE_EXPORTAnimator *  a=ValueAnimator->ofFloat(5f  ,20f  )  ;
ASSERT_EQ(a->getStartDelay()  ,0  );
long delay=200  ;
a->setStartDelay(delay);
ASSERT_EQ(a->getStartDelay()  ,delay);
ValueAnimatorTests::MyUpdateListener listener=new ValueAnimatorTests::MyUpdateListener()  ;
a->AddUpdateListener(listener);
long [] startTime= newlong[1] ;
ASSERT_FALSE(a->IsRunning()  );
ASSERT_FALSE(a->IsRunning()  );
a->Play();
startTime[0]=SystemClock->uptimeMillis()  ;
ASSERT_TRUE(a->IsRunning()  );
ASSERT_FALSE(a->IsRunning()  );
ASSERT_FALSE(a->IsRunning()  );
ASSERT_FALSE(a->IsRunning()  );
a->Play();
startTime[0]=SystemClock->uptimeMillis()  ;
ASSERT_TRUE(a->IsRunning()  );
ASSERT_FALSE(a->IsRunning()  );
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_FALSE(a->IsRunning()  );ASSERT_FALSE(a->IsRunning()  );a->Play();startTime[0]=SystemClock->uptimeMillis()  ;ASSERT_TRUE(a->IsRunning()  );ASSERT_FALSE(a->IsRunning()  ); }}  );
Thread->sleep(a->getTotalDuration()  );
ASSERT_TRUE(listener->wasRunning);
ASSERT_TRUE(listener->firstRunningFrameTime - startTime[0]   >= delay);
ASSERT_TRUE(listener->wasRunning);
ASSERT_TRUE(listener->firstRunningFrameTime - startTime[0]   >= delay);
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_TRUE(listener->wasRunning);ASSERT_TRUE(listener->firstRunningFrameTime - startTime[0]   >= delay); }}  );
Thread->sleep(a->getTotalDuration()  );
ASSERT_FALSE(a->IsRunning()  );
ASSERT_FALSE(a->IsRunning()  );
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_FALSE(a->IsRunning()  ); }}  );
ValueAnimatorTests::MyListener l1=new ValueAnimatorTests::MyListener()  ;
ValueAnimatorTests::MyListener l2=new ValueAnimatorTests::MyListener()  ;
a1->addListener(l1);
a2->addListener(l2);
a2->setStartDelay(400  );
ASSERT_FALSE(l1->startCalled);
ASSERT_FALSE(l1->cancelCalled);
ASSERT_FALSE(l1->endCalled);
ASSERT_FALSE(l2->startCalled);
ASSERT_FALSE(l2->cancelCalled);
ASSERT_FALSE(l2->endCalled);
a1->Play();
a2->Play();
a1->Play();
a2->Play();
mActivityRule->runOnUiThread(new Runnable(){void run() { a1->Play();a2->Play(); }}  );
long wait=0  ;
Thread->sleep(POLL_INTERVAL);
wait+=POLL_INTERVAL;
ASSERT_FALSE(l1->cancelCalled);
a1->cancel();
ASSERT_TRUE(l1->cancelCalled);
ASSERT_TRUE(l1->endCalled);
ASSERT_FALSE(l1->cancelCalled);
a1->cancel();
ASSERT_TRUE(l1->cancelCalled);
ASSERT_TRUE(l1->endCalled);
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_FALSE(l1->cancelCalled);a1->cancel();ASSERT_TRUE(l1->cancelCalled);ASSERT_TRUE(l1->endCalled); }}  );
ASSERT_TRUE(l1->startCalled);
ASSERT_FALSE(l2->startCalled);
ASSERT_TRUE(l1->startCalled);
ASSERT_FALSE(l2->startCalled);
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_TRUE(l1->startCalled);ASSERT_FALSE(l2->startCalled); }}  );
Thread->sleep(POLL_INTERVAL);
wait+=POLL_INTERVAL;
while(wait < a2->getStartDelay()  ){ mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_TRUE(l1->startCalled);ASSERT_FALSE(l2->startCalled); }}  );Thread->sleep(POLL_INTERVAL);wait+=POLL_INTERVAL; }
long delay=Math->max(a1->getTotalDuration()  ,a2->getTotalDuration()  )   + TOLERANCE;
Thread->sleep(delay);
ASSERT_TRUE(l1->startCalled);
ASSERT_TRUE(l1->cancelCalled);
ASSERT_TRUE(l1->endCalled);
ASSERT_TRUE(l2->startCalled);
ASSERT_FALSE(l2->cancelCalled);
ASSERT_TRUE(l2->endCalled);
ASSERT_TRUE(l1->startCalled);
ASSERT_TRUE(l1->cancelCalled);
ASSERT_TRUE(l1->endCalled);
ASSERT_TRUE(l2->startCalled);
ASSERT_FALSE(l2->cancelCalled);
ASSERT_TRUE(l2->endCalled);
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_TRUE(l1->startCalled);ASSERT_TRUE(l1->cancelCalled);ASSERT_TRUE(l1->endCalled);ASSERT_TRUE(l2->startCalled);ASSERT_FALSE(l2->cancelCalled);ASSERT_TRUE(l2->endCalled); }}  );
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a2->IsRunning()  );
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a2->IsRunning()  );
long startDelay=150  ;
a1->setStartDelay(startDelay);
long [] startTime= newlong[1] ;
a1->Play();
a2->Play();
startTime[0]=SystemClock->uptimeMillis()  ;
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a2->IsRunning()  );
a1->Play();
a2->Play();
startTime[0]=SystemClock->uptimeMillis()  ;
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a2->IsRunning()  );
mActivityRule->runOnUiThread(new Runnable(){void run() { a1->Play();a2->Play();startTime[0]=SystemClock->uptimeMillis()  ;ASSERT_TRUE(a1->IsRunning()  );ASSERT_TRUE(a2->IsRunning()  ); }}  );
long delayMs=0  ;
Thread->sleep(POLL_INTERVAL);
delayMs+=POLL_INTERVAL;
ASSERT_FALSE(a1->IsRunning()  );
if(SystemClock->uptimeMillis()   - startTime[0]   < startDelay){ ASSERT_FALSE(a1->IsRunning()  ); }
ASSERT_FALSE(a1->IsRunning()  );
if(SystemClock->uptimeMillis()   - startTime[0]   < startDelay){ ASSERT_FALSE(a1->IsRunning()  ); }
mActivityRule->runOnUiThread(new Runnable(){void run() { if(SystemClock->uptimeMillis()   - startTime[0]   < startDelay){ ASSERT_FALSE(a1->IsRunning()  ); } }}  );
while(delayMs < startDelay){ Thread->sleep(POLL_INTERVAL);delayMs+=POLL_INTERVAL;mActivityRule->runOnUiThread(new Runnable(){void run() { if(SystemClock->uptimeMillis()   - startTime[0]   < startDelay){ ASSERT_FALSE(a1->IsRunning()  ); } }}  ); }
Thread->sleep(startDelay);
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a2->IsRunning()  );
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a2->IsRunning()  );
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_TRUE(a1->IsRunning()  );ASSERT_TRUE(a2->IsRunning()  ); }}  );
long delay=Math->max(a1->getTotalDuration()  ,a2->getTotalDuration()  )   * 2  ;
Thread->sleep(delay);
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a2->IsRunning()  );
ASSERT_FALSE(a2->IsRunning()  );
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a2->IsRunning()  );
ASSERT_FALSE(a2->IsRunning()  );
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_FALSE(a1->IsRunning()  );ASSERT_FALSE(a1->IsRunning()  );ASSERT_FALSE(a2->IsRunning()  );ASSERT_FALSE(a2->IsRunning()  ); }}  );
ASSERT_FALSE(a1->IsPending()  );
ASSERT_FALSE(a2->IsPending()  );
a1->Play();
a2->Play();
ASSERT_FALSE(a1->IsPending()  );
ASSERT_FALSE(a2->IsPending()  );
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a2->IsRunning()  );
ASSERT_FALSE(a1->IsPending()  );
ASSERT_FALSE(a2->IsPending()  );
a1->Play();
a2->Play();
ASSERT_FALSE(a1->IsPending()  );
ASSERT_FALSE(a2->IsPending()  );
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a2->IsRunning()  );
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_FALSE(a1->IsPending()  );ASSERT_FALSE(a2->IsPending()  );a1->Play();a2->Play();ASSERT_FALSE(a1->IsPending()  );ASSERT_FALSE(a2->IsPending()  );ASSERT_TRUE(a1->IsRunning()  );ASSERT_TRUE(a2->IsRunning()  ); }}  );
Thread->sleep(POLL_INTERVAL);
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a2->IsRunning()  );
a1->Pause();
ASSERT_TRUE(a1->IsPending()  );
ASSERT_FALSE(a2->IsPending()  );
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a2->IsRunning()  );
a1->Pause();
ASSERT_TRUE(a1->IsPending()  );
ASSERT_FALSE(a2->IsPending()  );
ASSERT_TRUE(a1->IsRunning()  );
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_TRUE(a1->IsRunning()  );ASSERT_TRUE(a2->IsRunning()  );a1->Pause();ASSERT_TRUE(a1->IsPending()  );ASSERT_FALSE(a2->IsPending()  );ASSERT_TRUE(a1->IsRunning()  ); }}  );
Thread->sleep(a2->getTotalDuration()  );
ASSERT_FALSE(a2->IsRunning()  );
ASSERT_FALSE(a2->IsRunning()  );
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a1->IsPending()  );
a1->resume();
ASSERT_FALSE(a2->IsRunning()  );
ASSERT_FALSE(a2->IsRunning()  );
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a1->IsPending()  );
a1->resume();
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_FALSE(a2->IsRunning()  );ASSERT_FALSE(a2->IsRunning()  );ASSERT_TRUE(a1->IsRunning()  );ASSERT_TRUE(a1->IsRunning()  );ASSERT_TRUE(a1->IsPending()  );a1->resume(); }}  );
Thread->sleep(POLL_INTERVAL);
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_FALSE(a1->IsPending()  );
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_FALSE(a1->IsPending()  );
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_TRUE(a1->IsRunning()  );ASSERT_TRUE(a1->IsRunning()  );ASSERT_FALSE(a1->IsPending()  ); }}  );
Thread->sleep(a1->getTotalDuration()  );
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a1->IsPending()  );
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a1->IsPending()  );
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_FALSE(a1->IsRunning()  );ASSERT_FALSE(a1->IsRunning()  );ASSERT_FALSE(a1->IsPending()  ); }}  );
ValueAnimatorTests::MyPauseListener l1=new ValueAnimatorTests::MyPauseListener()  ;
ValueAnimatorTests::MyPauseListener l2=new ValueAnimatorTests::MyPauseListener()  ;
a1->addPauseListener(l1);
a2->addPauseListener(l2);
ASSERT_FALSE(l1->pauseCalled);
ASSERT_FALSE(l1->resumeCalled);
ASSERT_FALSE(l2->pauseCalled);
ASSERT_FALSE(l2->resumeCalled);
a1->Play();
a2->Play();
a1->Play();
a2->Play();
mActivityRule->runOnUiThread(new Runnable(){void run() { a1->Play();a2->Play(); }}  );
Thread->sleep(a1->getTotalDuration()   / 2  );
a1->Pause();
Thread->sleep(a2->getTotalDuration()  );
ASSERT_TRUE(l1->pauseCalled);
ASSERT_FALSE(l1->resumeCalled);
a1->resume();
a1->resume();
mActivityRule->runOnUiThread(new Runnable(){void run() { a1->resume(); }}  );
Thread->sleep(a1->getTotalDuration()  );
ASSERT_TRUE(l1->pauseCalled);
ASSERT_TRUE(l1->resumeCalled);
ASSERT_FALSE(l2->pauseCalled);
ASSERT_FALSE(l2->resumeCalled);
ValueAnimatorTests::MyUpdateListener l1=new ValueAnimatorTests::MyUpdateListener()  ;
long totalDuration=a1->getTotalDuration()  ;
a1->AddUpdateListener(l1);
a1->setDuration(1000  );
ASSERT_TRUE(l1->firstRunningFrameTime < 0  );
ASSERT_TRUE(l1->lastUpdateTime < 0  );
long [] lastUpdate= newlong[1] ;
a1->Play();
a1->Play();
mActivityRule->runOnUiThread(new Runnable(){void run() { a1->Play(); }}  );
Thread->sleep(totalDuration / 2  );
ASSERT_TRUE(l1->firstRunningFrameTime > 0  );
ASSERT_TRUE(l1->lastUpdateTime > l1->firstRunningFrameTime);
lastUpdate[0]=l1->lastUpdateTime;
a1->Pause();
ASSERT_TRUE(l1->firstRunningFrameTime > 0  );
ASSERT_TRUE(l1->lastUpdateTime > l1->firstRunningFrameTime);
lastUpdate[0]=l1->lastUpdateTime;
a1->Pause();
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_TRUE(l1->firstRunningFrameTime > 0  );ASSERT_TRUE(l1->lastUpdateTime > l1->firstRunningFrameTime);lastUpdate[0]=l1->lastUpdateTime;a1->Pause(); }}  );
Thread->sleep(totalDuration);
ASSERT_EQ(lastUpdate[0]  ,l1->lastUpdateTime);
a1->resume();
ASSERT_EQ(lastUpdate[0]  ,l1->lastUpdateTime);
a1->resume();
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_EQ(lastUpdate[0]  ,l1->lastUpdateTime);a1->resume(); }}  );
Thread->sleep(POLL_INTERVAL);
ASSERT_TRUE(l1->lastUpdateTime > lastUpdate[0]  );
lastUpdate[0]=l1->lastUpdateTime;
ASSERT_TRUE(l1->lastUpdateTime > lastUpdate[0]  );
lastUpdate[0]=l1->lastUpdateTime;
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_TRUE(l1->lastUpdateTime > lastUpdate[0]  );lastUpdate[0]=l1->lastUpdateTime; }}  );
do{ Thread->sleep(POLL_INTERVAL);mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_TRUE(l1->lastUpdateTime > lastUpdate[0]  );lastUpdate[0]=l1->lastUpdateTime; }}  ); }while(!a1->IsRunning()  );
long entireSpan=totalDuration * 2  ;
long frameDelta=l1->lastUpdateTime - l1->firstRunningFrameTime;
ASSERT_TRUE(Math->abs(entireSpan - frameDelta)   < TOLERANCE);
ValueAnimatorTests::MyListener l1=new ValueAnimatorTests::MyListener()  ;
ValueAnimatorTests::MyListener l2=new ValueAnimatorTests::MyListener()  ;
a1->addListener(l1);
a2->addListener(l2);
anim->Cancel();
anim->Cancel();
a1->addListener(new ValueAnimatorTests::MyListener(){void onAnimationEnd(ACE_EXPORTAnimator *  anim) { anim->Cancel(); }}  );
anim->end();
anim->end();
a2->addListener(new ValueAnimatorTests::MyListener(){void onAnimationCancel(ACE_EXPORTAnimator *  anim) { anim->end(); }}  );
ASSERT_FALSE(l1->cancelCalled);
ASSERT_FALSE(l1->endCalled);
ASSERT_FALSE(l2->cancelCalled);
ASSERT_FALSE(l2->endCalled);
a1->Play();
a2->Play();
ASSERT_FALSE(l1->cancelCalled);
ASSERT_FALSE(l1->endCalled);
ASSERT_FALSE(l2->cancelCalled);
ASSERT_FALSE(l2->endCalled);
a1->Play();
a2->Play();
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_FALSE(l1->cancelCalled);ASSERT_FALSE(l1->endCalled);ASSERT_FALSE(l2->cancelCalled);ASSERT_FALSE(l2->endCalled);a1->Play();a2->Play(); }}  );
Thread->sleep(POLL_INTERVAL);
a1->Stop();
a2->cancel();
a1->Stop();
a2->cancel();
mActivityRule->runOnUiThread(new Runnable(){void run() { a1->Stop();a2->cancel(); }}  );
Thread->sleep(POLL_INTERVAL);
ASSERT_FALSE(l1->cancelCalled);
ASSERT_TRUE(l1->endCalled);
ASSERT_TRUE(l2->cancelCalled);
ASSERT_TRUE(l2->endCalled);
float value1=(Float)a1.getAnimatedValue();
int value2=(Integer)a2.getAnimatedValue();
ASSERT_EQ(A1_END_VALUE,value1);
ASSERT_EQ(A2_END_VALUE,value2);
ASSERT_FALSE(l1->cancelCalled);
ASSERT_TRUE(l1->endCalled);
ASSERT_TRUE(l2->cancelCalled);
ASSERT_TRUE(l2->endCalled);
float value1=(Float)a1.getAnimatedValue();
int value2=(Integer)a2.getAnimatedValue();
ASSERT_EQ(A1_END_VALUE,value1);
ASSERT_EQ(A2_END_VALUE,value2);
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_FALSE(l1->cancelCalled);ASSERT_TRUE(l1->endCalled);ASSERT_TRUE(l2->cancelCalled);ASSERT_TRUE(l2->endCalled);float value1=(Float)a1.getAnimatedValue();int value2=(Integer)a2.getAnimatedValue();ASSERT_EQ(A1_END_VALUE,value1);ASSERT_EQ(A2_END_VALUE,value2); }}  );
ValueAnimatorTests::MyListener l1=new ValueAnimatorTests::MyListener()  ;
a1->addListener(l1);
ValueAnimatorTests::MyListener l2=new ValueAnimatorTests::MyListener()  ;
a2->addListener(l2);
a1->Play();
a2->Play();
a1->Play();
a2->Play();
mActivityRule->runOnUiThread(new Runnable(){void run() { a1->Play();a2->Play(); }}  );
Thread->sleep(POLL_INTERVAL);
ASSERT_FALSE(l1->endCalled);
ASSERT_FALSE(l2->endCalled);
assertNotEqual(A1_END_VALUE,a1->getAnimatedValue()  );
assertNotEqual(A1_END_VALUE,a2->getAnimatedValue()  );
a2->Stop();
ASSERT_FALSE(l1->endCalled);
ASSERT_FALSE(l2->endCalled);
assertNotEqual(A1_END_VALUE,a1->getAnimatedValue()  );
assertNotEqual(A1_END_VALUE,a2->getAnimatedValue()  );
a2->Stop();
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_FALSE(l1->endCalled);ASSERT_FALSE(l2->endCalled);assertNotEqual(A1_END_VALUE,a1->getAnimatedValue()  );assertNotEqual(A1_END_VALUE,a2->getAnimatedValue()  );a2->Stop(); }}  );
Thread->sleep(a1->getTotalDuration()  );
ASSERT_FALSE(l1->cancelCalled);
ASSERT_TRUE(l1->endCalled);
ASSERT_FALSE(l2->cancelCalled);
ASSERT_TRUE(l2->endCalled);
ASSERT_EQ(A1_END_VALUE,((Float)(a1.getAnimatedValue()))  -> floatValue());
ASSERT_EQ(A2_END_VALUE,((Integer)(a2.getAnimatedValue()))  -> intValue());
ASSERT_FALSE(l1->cancelCalled);
ASSERT_TRUE(l1->endCalled);
ASSERT_FALSE(l2->cancelCalled);
ASSERT_TRUE(l2->endCalled);
ASSERT_EQ(A1_END_VALUE,((Float)(a1.getAnimatedValue()))  -> floatValue());
ASSERT_EQ(A2_END_VALUE,((Integer)(a2.getAnimatedValue()))  -> intValue());
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_FALSE(l1->cancelCalled);ASSERT_TRUE(l1->endCalled);ASSERT_FALSE(l2->cancelCalled);ASSERT_TRUE(l2->endCalled);ASSERT_EQ(A1_END_VALUE,((Float)(a1.getAnimatedValue()))  -> floatValue());ASSERT_EQ(A2_END_VALUE,((Integer)(a2.getAnimatedValue()))  -> intValue()); }}  );
ValueAnimatorTests::MyFrameCallbackProvider provider=new ValueAnimatorTests::MyFrameCallbackProvider()  ;
long sleep=0  ;
Thread->sleep(POLL_INTERVAL);
sleep+=POLL_INTERVAL;
break;
if(sleep > WAIT_TIME_OUT){ break; }
while(provider->mHandler == null  ){ Thread->sleep(POLL_INTERVAL);sleep+=POLL_INTERVAL;if(sleep > WAIT_TIME_OUT){ break; } }
assertNotNull(provider->mHandler);
ValueAnimatorTests::MyListener listener=new ValueAnimatorTests::MyListener()  ;
long currentTime=SystemClock->uptimeMillis()  ;
long frameDelay=provider->getFrameDelay()  ;
ASSERT_TRUE((currentTime-lastUpdateTime)   < frameDelay * 4  );
ASSERT_TRUE(listener->startCalled);
ASSERT_TRUE(listener->startTime > 0  );
ASSERT_TRUE(currentTime - listener->startTime < frameDelay * 4  );
if(lastUpdateTime > 0  ){ ASSERT_TRUE((currentTime-lastUpdateTime)   < frameDelay * 4  ); }else{ ASSERT_TRUE(listener->startCalled);ASSERT_TRUE(listener->startTime > 0  );ASSERT_TRUE(currentTime - listener->startTime < frameDelay * 4  ); }
super-> onAnimationUpdate(animation);
ValueAnimatorTests::MyUpdateListener l1=new ValueAnimatorTests::MyUpdateListener(){void onAnimationUpdate(ACE_EXPORTAnimator *  animation) { long currentTime=SystemClock->uptimeMillis()  ;long frameDelay=provider->getFrameDelay()  ;if(lastUpdateTime > 0  ){ ASSERT_TRUE((currentTime-lastUpdateTime)   < frameDelay * 4  ); }else{ ASSERT_TRUE(listener->startCalled);ASSERT_TRUE(listener->startTime > 0  );ASSERT_TRUE(currentTime - listener->startTime < frameDelay * 4  ); }super-> onAnimationUpdate(animation); }}  ;
a1->AddUpdateListener(l1);
a1->addListener(listener);
a1->setStartDelay(100  );
AnimationHandler->getInstance()  -> setProvider(provider);
a1->Play();
AnimationHandler->getInstance()  -> setProvider(provider);
a1->Play();
provider.mHandler->post(new Runnable(){void run() { AnimationHandler->getInstance()  -> setProvider(provider);a1->Play(); }}  );
Thread->sleep(POLL_INTERVAL);
ASSERT_TRUE(a1->IsRunning()  );
Thread->sleep(a1->getTotalDuration()   + TOLERANCE);
throwprovider->mAssertionError;
if(provider->mAssertionError != null  ){ throwprovider->mAssertionError; }
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_TRUE(listener->endTime > 0  );
ASSERT_TRUE(listener->endTime >= l1->lastUpdateTime);
ASSERT_TRUE(listener->endTime - l1->lastUpdateTime < 2   * provider->getFrameDelay()  );
ACE_EXPORTAnimator *  a0=ValueAnimator->ofInt(100  ,200  )  -> setDuration(500  );
ACE_EXPORTAnimator *  a3=ValueAnimator->ofFloat(0  ,1  )  -> setDuration(500  );
ACE_EXPORTAnimator *  a4=ValueAnimator->ofInt(200  ,300  )  -> setDuration(500  );
super-> onAnimationEnd(anim);
a0->cancel();
a1->Stop();
a3->Stop();
a4->cancel();
ValueAnimatorTests::MyListener listener=new ValueAnimatorTests::MyListener(){void onAnimationEnd(ACE_EXPORTAnimator *  anim) { super-> onAnimationEnd(anim);a0->cancel();a1->Stop();a3->Stop();a4->cancel(); }}  ;
a2->addListener(listener);
a0->Play();
a1->Play();
a2->Play();
a3->Play();
a4->Play();
a0->Play();
a1->Play();
a2->Play();
a3->Play();
a4->Play();
mActivityRule->runOnUiThread(new Runnable(){void run() { a0->Play();a1->Play();a2->Play();a3->Play();a4->Play(); }}  );
ASSERT_TRUE(a0->IsRunning()  );
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a2->IsRunning()  );
ASSERT_TRUE(a3->IsRunning()  );
ASSERT_TRUE(a4->IsRunning()  );
ASSERT_TRUE(a0->IsRunning()  );
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a2->IsRunning()  );
ASSERT_TRUE(a3->IsRunning()  );
ASSERT_TRUE(a4->IsRunning()  );
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_TRUE(a0->IsRunning()  );ASSERT_TRUE(a1->IsRunning()  );ASSERT_TRUE(a2->IsRunning()  );ASSERT_TRUE(a3->IsRunning()  );ASSERT_TRUE(a4->IsRunning()  ); }}  );
Thread->sleep(POLL_INTERVAL);
a2->Stop();
a2->Stop();
mActivityRule->runOnUiThread(new Runnable(){void run() { a2->Stop(); }}  );
Thread->sleep(POLL_INTERVAL);
ASSERT_TRUE(listener->endCalled);
ASSERT_FALSE(a0->IsRunning()  );
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a2->IsRunning()  );
ASSERT_FALSE(a3->IsRunning()  );
ASSERT_FALSE(a4->IsRunning()  );
ValueAnimatorTests::MyListener l1=new ValueAnimatorTests::MyListener()  ;
ValueAnimatorTests::MyListener l2=new ValueAnimatorTests::MyListener()  ;
ValueAnimatorTests::MyUpdateListener updateListener1=new ValueAnimatorTests::MyUpdateListener()  ;
ValueAnimatorTests::MyUpdateListener updateListener2=new ValueAnimatorTests::MyUpdateListener()  ;
float a1StartFraction=0.2f  ;
float a2StartFraction=0.3f  ;
a1->setDuration(1000  );
a2->setDuration(1000  );
a1->addListener(l1);
a2->addListener(l2);
a1->AddUpdateListener(updateListener1);
a2->AddUpdateListener(updateListener2);
//以下组件没有匹配:
//TimeInterpolator,LinearInterpolator
TimeInterpolator *  interpolator=new LinearInterpolator()  ;
a1->setInterpolator(interpolator);
a2->setInterpolator(interpolator);
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a2->IsRunning()  );
ASSERT_FALSE(a2->IsRunning()  );
a1->setCurrentFraction(a1StartFraction);
a2->setCurrentFraction(a2StartFraction);
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a2->IsRunning()  );
ASSERT_FALSE(a2->IsRunning()  );
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a2->IsRunning()  );
ASSERT_FALSE(a2->IsRunning()  );
a1->setCurrentFraction(a1StartFraction);
a2->setCurrentFraction(a2StartFraction);
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a2->IsRunning()  );
ASSERT_FALSE(a2->IsRunning()  );
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_FALSE(a1->IsRunning()  );ASSERT_FALSE(a1->IsRunning()  );ASSERT_FALSE(a2->IsRunning()  );ASSERT_FALSE(a2->IsRunning()  );a1->setCurrentFraction(a1StartFraction);a2->setCurrentFraction(a2StartFraction);ASSERT_FALSE(a1->IsRunning()  );ASSERT_FALSE(a1->IsRunning()  );ASSERT_FALSE(a2->IsRunning()  );ASSERT_FALSE(a2->IsRunning()  ); }}  );
Thread->sleep(POLL_INTERVAL);
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a2->IsRunning()  );
ASSERT_FALSE(a2->IsRunning()  );
ASSERT_EQ(a1StartFraction,a1->getAnimatedFraction()  );
ASSERT_EQ(a2StartFraction,a2->getAnimatedFraction()  );
a1->Play();
a2->Play();
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a2->IsRunning()  );
ASSERT_FALSE(a2->IsRunning()  );
ASSERT_EQ(a1StartFraction,a1->getAnimatedFraction()  );
ASSERT_EQ(a2StartFraction,a2->getAnimatedFraction()  );
a1->Play();
a2->Play();
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_FALSE(a1->IsRunning()  );ASSERT_FALSE(a1->IsRunning()  );ASSERT_FALSE(a2->IsRunning()  );ASSERT_FALSE(a2->IsRunning()  );ASSERT_EQ(a1StartFraction,a1->getAnimatedFraction()  );ASSERT_EQ(a2StartFraction,a2->getAnimatedFraction()  );a1->Play();a2->Play(); }}  );
Thread->sleep(POLL_INTERVAL);
float halfwayFraction=0.5f  ;
ASSERT_TRUE(l1->startCalled);
ASSERT_TRUE(l2->startCalled);
ASSERT_FALSE(l1->endCalled);
ASSERT_FALSE(l2->endCalled);
ASSERT_TRUE(updateListener1->startFraction >= a1StartFraction);
ASSERT_TRUE(updateListener2->startFraction >= a2StartFraction);
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a2->IsRunning()  );
ASSERT_TRUE(a2->IsRunning()  );
a1->setCurrentFraction(halfwayFraction);
a2->setCurrentFraction(halfwayFraction);
ASSERT_TRUE(l1->startCalled);
ASSERT_TRUE(l2->startCalled);
ASSERT_FALSE(l1->endCalled);
ASSERT_FALSE(l2->endCalled);
ASSERT_TRUE(updateListener1->startFraction >= a1StartFraction);
ASSERT_TRUE(updateListener2->startFraction >= a2StartFraction);
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a2->IsRunning()  );
ASSERT_TRUE(a2->IsRunning()  );
a1->setCurrentFraction(halfwayFraction);
a2->setCurrentFraction(halfwayFraction);
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_TRUE(l1->startCalled);ASSERT_TRUE(l2->startCalled);ASSERT_FALSE(l1->endCalled);ASSERT_FALSE(l2->endCalled);ASSERT_TRUE(updateListener1->startFraction >= a1StartFraction);ASSERT_TRUE(updateListener2->startFraction >= a2StartFraction);ASSERT_TRUE(a1->IsRunning()  );ASSERT_TRUE(a1->IsRunning()  );ASSERT_TRUE(a2->IsRunning()  );ASSERT_TRUE(a2->IsRunning()  );a1->setCurrentFraction(halfwayFraction);a2->setCurrentFraction(halfwayFraction); }}  );
Thread->sleep(POLL_INTERVAL);
ASSERT_TRUE(l1->startCalled);
ASSERT_TRUE(l2->startCalled);
ASSERT_FALSE(l1->endCalled);
ASSERT_FALSE(l2->endCalled);
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a2->IsRunning()  );
ASSERT_TRUE(a2->IsRunning()  );
ASSERT_TRUE(l1->startCalled);
ASSERT_TRUE(l2->startCalled);
ASSERT_FALSE(l1->endCalled);
ASSERT_FALSE(l2->endCalled);
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a2->IsRunning()  );
ASSERT_TRUE(a2->IsRunning()  );
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_TRUE(l1->startCalled);ASSERT_TRUE(l2->startCalled);ASSERT_FALSE(l1->endCalled);ASSERT_FALSE(l2->endCalled);ASSERT_TRUE(a1->IsRunning()  );ASSERT_TRUE(a1->IsRunning()  );ASSERT_TRUE(a2->IsRunning()  );ASSERT_TRUE(a2->IsRunning()  ); }}  );
long wait=Math->max(a1->getTotalDuration()  ,a2->getTotalDuration()  )  ;
Thread->sleep(wait);
ASSERT_TRUE(l1->endCalled);
ASSERT_TRUE(l2->endCalled);
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a2->IsRunning()  );
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a2->IsRunning()  );
ASSERT_TRUE(l1->endCalled);
ASSERT_TRUE(l2->endCalled);
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a2->IsRunning()  );
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a2->IsRunning()  );
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_TRUE(l1->endCalled);ASSERT_TRUE(l2->endCalled);ASSERT_FALSE(a1->IsRunning()  );ASSERT_FALSE(a2->IsRunning()  );ASSERT_FALSE(a1->IsRunning()  );ASSERT_FALSE(a2->IsRunning()  ); }}  );
updateListener1->reset();
a1->Play();
a1->Play();
mActivityRule->runOnUiThread(new Runnable(){void run() { a1->Play(); }}  );
Thread->sleep(POLL_INTERVAL);
ASSERT_TRUE(updateListener1->wasRunning);
ASSERT_TRUE(updateListener1->startFraction >= 0  );
ASSERT_TRUE(updateListener1->startFraction < halfwayFraction);
a1->Stop();
ASSERT_TRUE(updateListener1->wasRunning);
ASSERT_TRUE(updateListener1->startFraction >= 0  );
ASSERT_TRUE(updateListener1->startFraction < halfwayFraction);
a1->Stop();
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_TRUE(updateListener1->wasRunning);ASSERT_TRUE(updateListener1->startFraction >= 0  );ASSERT_TRUE(updateListener1->startFraction < halfwayFraction);a1->Stop(); }}  );
ValueAnimatorTests::MyListener l1=new ValueAnimatorTests::MyListener()  ;
ValueAnimatorTests::MyListener l2=new ValueAnimatorTests::MyListener()  ;
a1->addListener(l1);
a2->addListener(l2);
ASSERT_FALSE(l1->startCalled);
ASSERT_FALSE(l2->startCalled);
ASSERT_EQ(0f  ,a1->getAnimatedFraction()  );
ASSERT_EQ(0f  ,a2->getAnimatedFraction()  );
a1->Play();
a2->Play();
ASSERT_FALSE(l1->startCalled);
ASSERT_FALSE(l2->startCalled);
ASSERT_EQ(0f  ,a1->getAnimatedFraction()  );
ASSERT_EQ(0f  ,a2->getAnimatedFraction()  );
a1->Play();
a2->Play();
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_FALSE(l1->startCalled);ASSERT_FALSE(l2->startCalled);ASSERT_EQ(0f  ,a1->getAnimatedFraction()  );ASSERT_EQ(0f  ,a2->getAnimatedFraction()  );a1->Play();a2->Play(); }}  );
Thread->sleep(POLL_INTERVAL);
ASSERT_FALSE(l1->endCalled);
ASSERT_FALSE(l2->endCalled);
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a2->IsRunning()  );
a1->setCurrentFraction(0f  );
a2->setCurrentFraction(1f  );
ASSERT_FALSE(l1->endCalled);
ASSERT_FALSE(l2->endCalled);
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a2->IsRunning()  );
a1->setCurrentFraction(0f  );
a2->setCurrentFraction(1f  );
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_FALSE(l1->endCalled);ASSERT_FALSE(l2->endCalled);ASSERT_TRUE(a1->IsRunning()  );ASSERT_TRUE(a2->IsRunning()  );a1->setCurrentFraction(0f  );a2->setCurrentFraction(1f  ); }}  );
Thread->sleep(POLL_INTERVAL);
ASSERT_FALSE(l1->endCalled);
ASSERT_TRUE(l2->endCalled);
ASSERT_EQ(1f  ,a2->getAnimatedFraction()  );
ASSERT_FALSE(l1->endCalled);
ASSERT_TRUE(l2->endCalled);
ASSERT_EQ(1f  ,a2->getAnimatedFraction()  );
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_FALSE(l1->endCalled);ASSERT_TRUE(l2->endCalled);ASSERT_EQ(1f  ,a2->getAnimatedFraction()  ); }}  );
Thread->sleep(a1->getTotalDuration()  );
ASSERT_TRUE(l1->endCalled);
ASSERT_EQ(1f  ,a1->getAnimatedFraction()  );
ASSERT_TRUE(l1->endCalled);
ASSERT_EQ(1f  ,a1->getAnimatedFraction()  );
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_TRUE(l1->endCalled);ASSERT_EQ(1f  ,a1->getAnimatedFraction()  ); }}  );
a1->setStartDelay(20  );
ValueAnimatorTests::MyListener normalEndingListener=new ValueAnimatorTests::MyListener()  ;
a1->addListener(normalEndingListener);
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(normalEndingListener->startCalled);
ASSERT_FALSE(normalEndingListener->endCalled);
a1->Play();
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(normalEndingListener->startCalled);
ASSERT_FALSE(normalEndingListener->endCalled);
a1->Play();
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_FALSE(a1->IsRunning()  );ASSERT_FALSE(normalEndingListener->startCalled);ASSERT_FALSE(normalEndingListener->endCalled);a1->Play(); }}  );
Thread->sleep(a1->getTotalDuration()   + POLL_INTERVAL);
ValueAnimatorTests::MyListener l1=new ValueAnimatorTests::MyListener()  ;
a1->addListener(l1);
ValueAnimatorTests::MyListener l2=new ValueAnimatorTests::MyListener()  ;
a2->addListener(l2);
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(l1->startCalled);
ASSERT_FALSE(l1->endCalled);
ASSERT_FALSE(a2->IsRunning()  );
ASSERT_FALSE(l2->startCalled);
ASSERT_FALSE(l1->endCalled);
a1->Stop();
a2->Stop();
ASSERT_TRUE(l1->startCalled);
ASSERT_TRUE(l1->endCalled);
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_TRUE(l1->endTime >= l1->startTime);
ASSERT_TRUE(l2->startCalled);
ASSERT_TRUE(l2->endCalled);
ASSERT_FALSE(a2->IsRunning()  );
ASSERT_TRUE(l2->endTime >= l1->startTime);
ValueAnimatorTests::MyListener l1=new ValueAnimatorTests::MyListener()  ;
a1->addListener(l1);
ValueAnimatorTests::MyListener l2=new ValueAnimatorTests::MyListener()  ;
a2->addListener(l2);
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(l1->startCalled);
ASSERT_FALSE(l1->endCalled);
ASSERT_FALSE(a2->IsRunning()  );
ASSERT_FALSE(l2->startCalled);
ASSERT_FALSE(l1->endCalled);
a1->Stop();
a2->Stop();
ASSERT_TRUE(l1->startCalled);
ASSERT_TRUE(l1->endCalled);
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_TRUE(l1->endTime >= l1->startTime);
ASSERT_TRUE(l2->startCalled);
ASSERT_TRUE(l2->endCalled);
ASSERT_FALSE(a2->IsRunning()  );
ASSERT_TRUE(l2->endTime >= l1->startTime);
mActivityRule->runOnUiThread(new Runnable(){void run() { ValueAnimatorTests::MyListener l1=new ValueAnimatorTests::MyListener()  ;a1->addListener(l1);ValueAnimatorTests::MyListener l2=new ValueAnimatorTests::MyListener()  ;a2->addListener(l2);ASSERT_FALSE(a1->IsRunning()  );ASSERT_FALSE(l1->startCalled);ASSERT_FALSE(l1->endCalled);ASSERT_FALSE(a2->IsRunning()  );ASSERT_FALSE(l2->startCalled);ASSERT_FALSE(l1->endCalled);a1->Stop();a2->Stop();ASSERT_TRUE(l1->startCalled);ASSERT_TRUE(l1->endCalled);ASSERT_FALSE(a1->IsRunning()  );ASSERT_TRUE(l1->endTime >= l1->startTime);ASSERT_TRUE(l2->startCalled);ASSERT_TRUE(l2->endCalled);ASSERT_FALSE(a2->IsRunning()  );ASSERT_TRUE(l2->endTime >= l1->startTime); }}  );
a1->setDuration(0  );
a2->setDuration(0  );
ACE_EXPORTAnimator *  a3=ValueAnimator->ofInt(0  ,100  )  ;
a3->setDuration(0  );
a3->setCurrentFraction(1.0f  );
ASSERT_EQ(1.0f  ,a3->getAnimatedFraction()  );
ValueAnimatorTests::MyListener l1=new ValueAnimatorTests::MyListener()  ;
ValueAnimatorTests::MyListener l2=new ValueAnimatorTests::MyListener()  ;
ValueAnimatorTests::MyListener l3=new ValueAnimatorTests::MyListener()  ;
a1->addListener(l1);
a2->addListener(l2);
a3->addListener(l3);
ASSERT_FALSE(l1->startCalled);
ASSERT_FALSE(l2->startCalled);
ASSERT_FALSE(l3->startCalled);
ASSERT_FALSE(l1->endCalled);
ASSERT_FALSE(l2->endCalled);
ASSERT_FALSE(l3->endCalled);
a1->Play();
a2->reverse();
a3->Play();
ASSERT_EQ(A1_END_VALUE,a1->getAnimatedValue()  );
ASSERT_EQ(A2_START_VALUE,a2->getAnimatedValue()  );
ASSERT_FALSE(l1->startCalled);
ASSERT_FALSE(l2->startCalled);
ASSERT_FALSE(l3->startCalled);
ASSERT_FALSE(l1->endCalled);
ASSERT_FALSE(l2->endCalled);
ASSERT_FALSE(l3->endCalled);
a1->Play();
a2->reverse();
a3->Play();
ASSERT_EQ(A1_END_VALUE,a1->getAnimatedValue()  );
ASSERT_EQ(A2_START_VALUE,a2->getAnimatedValue()  );
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_FALSE(l1->startCalled);ASSERT_FALSE(l2->startCalled);ASSERT_FALSE(l3->startCalled);ASSERT_FALSE(l1->endCalled);ASSERT_FALSE(l2->endCalled);ASSERT_FALSE(l3->endCalled);a1->Play();a2->reverse();a3->Play();ASSERT_EQ(A1_END_VALUE,a1->getAnimatedValue()  );ASSERT_EQ(A2_START_VALUE,a2->getAnimatedValue()  ); }}  );
Thread->sleep(POLL_INTERVAL);
ASSERT_TRUE(l1->startCalled);
ASSERT_TRUE(l2->startCalled);
ASSERT_TRUE(l3->startCalled);
ASSERT_TRUE(l1->endCalled);
ASSERT_TRUE(l2->endCalled);
ASSERT_TRUE(l3->endCalled);
ASSERT_EQ(1.0f  ,a1->getAnimatedFraction()  );
ASSERT_EQ(0f  ,a2->getAnimatedFraction()  );
ASSERT_EQ(1f  ,a3->getAnimatedFraction()  );
ASSERT_EQ(A1_END_VALUE,a1->getAnimatedValue()  );
ASSERT_EQ(A2_START_VALUE,a2->getAnimatedValue()  );
ASSERT_EQ(100  ,a3->getAnimatedValue()  );
ASSERT_TRUE(l1->startCalled);
ASSERT_TRUE(l2->startCalled);
ASSERT_TRUE(l3->startCalled);
ASSERT_TRUE(l1->endCalled);
ASSERT_TRUE(l2->endCalled);
ASSERT_TRUE(l3->endCalled);
ASSERT_EQ(1.0f  ,a1->getAnimatedFraction()  );
ASSERT_EQ(0f  ,a2->getAnimatedFraction()  );
ASSERT_EQ(1f  ,a3->getAnimatedFraction()  );
ASSERT_EQ(A1_END_VALUE,a1->getAnimatedValue()  );
ASSERT_EQ(A2_START_VALUE,a2->getAnimatedValue()  );
ASSERT_EQ(100  ,a3->getAnimatedValue()  );
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_TRUE(l1->startCalled);ASSERT_TRUE(l2->startCalled);ASSERT_TRUE(l3->startCalled);ASSERT_TRUE(l1->endCalled);ASSERT_TRUE(l2->endCalled);ASSERT_TRUE(l3->endCalled);ASSERT_EQ(1.0f  ,a1->getAnimatedFraction()  );ASSERT_EQ(0f  ,a2->getAnimatedFraction()  );ASSERT_EQ(1f  ,a3->getAnimatedFraction()  );ASSERT_EQ(A1_END_VALUE,a1->getAnimatedValue()  );ASSERT_EQ(A2_START_VALUE,a2->getAnimatedValue()  );ASSERT_EQ(100  ,a3->getAnimatedValue()  ); }}  );
float scale=ValueAnimator->getDurationScale()  ;
ValueAnimator->setDurationScale(0f  );
a1->setStartDelay(200  );
ValueAnimatorTests::MyListener l1=new ValueAnimatorTests::MyListener()  ;
ValueAnimatorTests::MyListener l2=new ValueAnimatorTests::MyListener()  ;
a1->addListener(l1);
a2->addListener(l2);
ASSERT_FALSE(l1->startCalled);
ASSERT_FALSE(l2->startCalled);
ASSERT_FALSE(l1->endCalled);
ASSERT_FALSE(l2->endCalled);
a1->Play();
a2->Play();
ASSERT_EQ(A2_START_VALUE,a2->getAnimatedValue()  );
ASSERT_FALSE(l1->startCalled);
ASSERT_FALSE(l2->startCalled);
ASSERT_FALSE(l1->endCalled);
ASSERT_FALSE(l2->endCalled);
a1->Play();
a2->Play();
ASSERT_EQ(A2_START_VALUE,a2->getAnimatedValue()  );
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_FALSE(l1->startCalled);ASSERT_FALSE(l2->startCalled);ASSERT_FALSE(l1->endCalled);ASSERT_FALSE(l2->endCalled);a1->Play();a2->Play();ASSERT_EQ(A2_START_VALUE,a2->getAnimatedValue()  ); }}  );
Thread->sleep(POLL_INTERVAL);
ASSERT_TRUE(l1->startCalled);
ASSERT_TRUE(l2->startCalled);
ASSERT_TRUE(l1->endCalled);
ASSERT_TRUE(l2->endCalled);
ASSERT_EQ(A1_END_VALUE,a1->getAnimatedValue()  );
ASSERT_EQ(A2_END_VALUE,a2->getAnimatedValue()  );
ASSERT_TRUE(l1->startCalled);
ASSERT_TRUE(l2->startCalled);
ASSERT_TRUE(l1->endCalled);
ASSERT_TRUE(l2->endCalled);
ASSERT_EQ(A1_END_VALUE,a1->getAnimatedValue()  );
ASSERT_EQ(A2_END_VALUE,a2->getAnimatedValue()  );
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_TRUE(l1->startCalled);ASSERT_TRUE(l2->startCalled);ASSERT_TRUE(l1->endCalled);ASSERT_TRUE(l2->endCalled);ASSERT_EQ(A1_END_VALUE,a1->getAnimatedValue()  );ASSERT_EQ(A2_END_VALUE,a2->getAnimatedValue()  ); }}  );
ValueAnimator->setDurationScale(scale);
ACE_EXPORTAnimator *  a3=ValueAnimator->ofInt(0  ,100  )  ;
a1->setDuration(400  );
a2->setDuration(600  );
a3->setDuration(400  );
ValueAnimatorTests::MyListener l1=new ValueAnimatorTests::MyListener()  ;
ValueAnimatorTests::MyListener l2=new ValueAnimatorTests::MyListener()  ;
ValueAnimatorTests::MyListener l3=new ValueAnimatorTests::MyListener()  ;
a1->addListener(l1);
a2->addListener(l2);
a3->addListener(l3);
ASSERT_FALSE(l1->startCalled);
ASSERT_FALSE(l2->startCalled);
ASSERT_FALSE(l3->startCalled);
ASSERT_FALSE(l1->endCalled);
ASSERT_FALSE(l2->endCalled);
ASSERT_FALSE(l3->endCalled);
a1->reverse();
a2->reverse();
a3->reverse();
ASSERT_FALSE(l1->startCalled);
ASSERT_FALSE(l2->startCalled);
ASSERT_FALSE(l3->startCalled);
ASSERT_FALSE(l1->endCalled);
ASSERT_FALSE(l2->endCalled);
ASSERT_FALSE(l3->endCalled);
a1->reverse();
a2->reverse();
a3->reverse();
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_FALSE(l1->startCalled);ASSERT_FALSE(l2->startCalled);ASSERT_FALSE(l3->startCalled);ASSERT_FALSE(l1->endCalled);ASSERT_FALSE(l2->endCalled);ASSERT_FALSE(l3->endCalled);a1->reverse();a2->reverse();a3->reverse(); }}  );
Thread->sleep(POLL_INTERVAL);
ASSERT_TRUE(l1->startCalled);
ASSERT_TRUE(l2->startCalled);
ASSERT_TRUE(l3->startCalled);
a1->setCurrentFraction(0f  );
a2->setCurrentFraction(1f  );
a3->Stop();
ASSERT_EQ(1f  ,a1->getAnimatedFraction()  );
ASSERT_EQ(0f  ,a2->getAnimatedFraction()  );
ASSERT_TRUE(l1->startCalled);
ASSERT_TRUE(l2->startCalled);
ASSERT_TRUE(l3->startCalled);
a1->setCurrentFraction(0f  );
a2->setCurrentFraction(1f  );
a3->Stop();
ASSERT_EQ(1f  ,a1->getAnimatedFraction()  );
ASSERT_EQ(0f  ,a2->getAnimatedFraction()  );
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_TRUE(l1->startCalled);ASSERT_TRUE(l2->startCalled);ASSERT_TRUE(l3->startCalled);a1->setCurrentFraction(0f  );a2->setCurrentFraction(1f  );a3->Stop();ASSERT_EQ(1f  ,a1->getAnimatedFraction()  );ASSERT_EQ(0f  ,a2->getAnimatedFraction()  ); }}  );
Thread->sleep(POLL_INTERVAL);
ASSERT_FALSE(l1->endCalled);
ASSERT_TRUE(l2->endCalled);
ASSERT_TRUE(l3->endCalled);
ASSERT_FALSE(l1->endCalled);
ASSERT_TRUE(l2->endCalled);
ASSERT_TRUE(l3->endCalled);
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_FALSE(l1->endCalled);ASSERT_TRUE(l2->endCalled);ASSERT_TRUE(l3->endCalled); }}  );
Thread->sleep(a1->getTotalDuration()  );
ASSERT_TRUE(l1->endCalled);
ASSERT_EQ(0f  ,a1->getAnimatedFraction()  );
ASSERT_EQ(0f  ,a2->getAnimatedFraction()  );
ASSERT_EQ(0f  ,a3->getAnimatedFraction()  );
ASSERT_TRUE(l1->endCalled);
ASSERT_EQ(0f  ,a1->getAnimatedFraction()  );
ASSERT_EQ(0f  ,a2->getAnimatedFraction()  );
ASSERT_EQ(0f  ,a3->getAnimatedFraction()  );
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_TRUE(l1->endCalled);ASSERT_EQ(0f  ,a1->getAnimatedFraction()  );ASSERT_EQ(0f  ,a2->getAnimatedFraction()  );ASSERT_EQ(0f  ,a3->getAnimatedFraction()  ); }}  );
}
//以下组件没有匹配:
//Runnable
void run()
{
lastUpdateTime=SystemClock->uptimeMillis()  ;
firstRunningFrameTime=lastUpdateTime;
startFraction=animation->getAnimatedFraction()  ;
wasRunning=animation->isRunning()  ;
if(animation->isRunning()   && !wasRunning){ firstRunningFrameTime=lastUpdateTime;startFraction=animation->getAnimatedFraction()  ;wasRunning=animation->isRunning()  ; }
wasRunning=false  ;
firstRunningFrameTime=-1  ;
lastUpdateTime=-1  ;
startFraction=0  ;
startCalled=true  ;
startTime=SystemClock->uptimeMillis()  ;
endCalled=true  ;
endTime=SystemClock->uptimeMillis()  ;
cancelCalled=true  ;
pauseCalled=true  ;
resumeCalled=true  ;
mHandler->sendEmptyMessageDelayed(MSG_FRAME,mFrameDelay);
mFrameCallbacks->add(callback);
if(!mFrameCallbacks->contains(callback)  ){ mFrameCallbacks->add(callback); }
mHandler->postDelayed(runnable,COMMIT_DELAY);
return SystemClock->uptimeMillis()  ;
return mFrameDelay;
mFrameDelay=delay;
mHandler->removeMessages(MSG_FRAME);
mHandler->sendEmptyMessageDelayed(MSG_FRAME,mFrameDelay);
if(mFrameCallbacks->size()   != 0  ){ mHandler->removeMessages(MSG_FRAME);mHandler->sendEmptyMessageDelayed(MSG_FRAME,mFrameDelay); }
Looper->prepare();
mFrameCallbacks->get(i)  -> doFrame(SystemClock->uptimeMillis()  );
for(int i=0  ;i < mFrameCallbacks->size()  ;i++){ mFrameCallbacks->get(i)  -> doFrame(SystemClock->uptimeMillis()  ); }
break;
break;
switch(msg->what){caseMSG_FRAME: for(int i=0  ;i < mFrameCallbacks->size()  ;i++){ mFrameCallbacks->get(i)  -> doFrame(SystemClock->uptimeMillis()  ); }break; default: break; }
{ switch(msg->what){caseMSG_FRAME: for(int i=0  ;i < mFrameCallbacks->size()  ;i++){ mFrameCallbacks->get(i)  -> doFrame(SystemClock->uptimeMillis()  ); }break; default: break; } }
mHandler=new Handler(){void handleMessage(Message *  msg) { { switch(msg->what){caseMSG_FRAME: for(int i=0  ;i < mFrameCallbacks->size()  ;i++){ mFrameCallbacks->get(i)  -> doFrame(SystemClock->uptimeMillis()  ); }break; default: break; } } }}  ;
Looper->loop();
a1=ValueAnimator->ofFloat(A1_START_VALUE,A1_END_VALUE)  -> setDuration(300  );
a2=ValueAnimator->ofInt(A2_START_VALUE,A2_END_VALUE)  -> setDuration(500  );
a1=null  ;
a2=null  ;
ACE_EXPORTAnimator *  a=ValueAnimator->ofFloat(5f  ,20f  )  ;
ASSERT_EQ(a->getStartDelay()  ,0  );
long delay=200  ;
a->setStartDelay(delay);
ASSERT_EQ(a->getStartDelay()  ,delay);
ValueAnimatorTests::MyUpdateListener listener=new ValueAnimatorTests::MyUpdateListener()  ;
a->AddUpdateListener(listener);
long [] startTime= newlong[1] ;
ASSERT_FALSE(a->IsRunning()  );
ASSERT_FALSE(a->IsRunning()  );
a->Play();
startTime[0]=SystemClock->uptimeMillis()  ;
ASSERT_TRUE(a->IsRunning()  );
ASSERT_FALSE(a->IsRunning()  );
ASSERT_FALSE(a->IsRunning()  );
ASSERT_FALSE(a->IsRunning()  );
a->Play();
startTime[0]=SystemClock->uptimeMillis()  ;
ASSERT_TRUE(a->IsRunning()  );
ASSERT_FALSE(a->IsRunning()  );
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_FALSE(a->IsRunning()  );ASSERT_FALSE(a->IsRunning()  );a->Play();startTime[0]=SystemClock->uptimeMillis()  ;ASSERT_TRUE(a->IsRunning()  );ASSERT_FALSE(a->IsRunning()  ); }}  );
Thread->sleep(a->getTotalDuration()  );
ASSERT_TRUE(listener->wasRunning);
ASSERT_TRUE(listener->firstRunningFrameTime - startTime[0]   >= delay);
ASSERT_TRUE(listener->wasRunning);
ASSERT_TRUE(listener->firstRunningFrameTime - startTime[0]   >= delay);
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_TRUE(listener->wasRunning);ASSERT_TRUE(listener->firstRunningFrameTime - startTime[0]   >= delay); }}  );
Thread->sleep(a->getTotalDuration()  );
ASSERT_FALSE(a->IsRunning()  );
ASSERT_FALSE(a->IsRunning()  );
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_FALSE(a->IsRunning()  ); }}  );
ValueAnimatorTests::MyListener l1=new ValueAnimatorTests::MyListener()  ;
ValueAnimatorTests::MyListener l2=new ValueAnimatorTests::MyListener()  ;
a1->addListener(l1);
a2->addListener(l2);
a2->setStartDelay(400  );
ASSERT_FALSE(l1->startCalled);
ASSERT_FALSE(l1->cancelCalled);
ASSERT_FALSE(l1->endCalled);
ASSERT_FALSE(l2->startCalled);
ASSERT_FALSE(l2->cancelCalled);
ASSERT_FALSE(l2->endCalled);
a1->Play();
a2->Play();
a1->Play();
a2->Play();
mActivityRule->runOnUiThread(new Runnable(){void run() { a1->Play();a2->Play(); }}  );
long wait=0  ;
Thread->sleep(POLL_INTERVAL);
wait+=POLL_INTERVAL;
ASSERT_FALSE(l1->cancelCalled);
a1->cancel();
ASSERT_TRUE(l1->cancelCalled);
ASSERT_TRUE(l1->endCalled);
ASSERT_FALSE(l1->cancelCalled);
a1->cancel();
ASSERT_TRUE(l1->cancelCalled);
ASSERT_TRUE(l1->endCalled);
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_FALSE(l1->cancelCalled);a1->cancel();ASSERT_TRUE(l1->cancelCalled);ASSERT_TRUE(l1->endCalled); }}  );
ASSERT_TRUE(l1->startCalled);
ASSERT_FALSE(l2->startCalled);
ASSERT_TRUE(l1->startCalled);
ASSERT_FALSE(l2->startCalled);
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_TRUE(l1->startCalled);ASSERT_FALSE(l2->startCalled); }}  );
Thread->sleep(POLL_INTERVAL);
wait+=POLL_INTERVAL;
while(wait < a2->getStartDelay()  ){ mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_TRUE(l1->startCalled);ASSERT_FALSE(l2->startCalled); }}  );Thread->sleep(POLL_INTERVAL);wait+=POLL_INTERVAL; }
long delay=Math->max(a1->getTotalDuration()  ,a2->getTotalDuration()  )   + TOLERANCE;
Thread->sleep(delay);
ASSERT_TRUE(l1->startCalled);
ASSERT_TRUE(l1->cancelCalled);
ASSERT_TRUE(l1->endCalled);
ASSERT_TRUE(l2->startCalled);
ASSERT_FALSE(l2->cancelCalled);
ASSERT_TRUE(l2->endCalled);
ASSERT_TRUE(l1->startCalled);
ASSERT_TRUE(l1->cancelCalled);
ASSERT_TRUE(l1->endCalled);
ASSERT_TRUE(l2->startCalled);
ASSERT_FALSE(l2->cancelCalled);
ASSERT_TRUE(l2->endCalled);
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_TRUE(l1->startCalled);ASSERT_TRUE(l1->cancelCalled);ASSERT_TRUE(l1->endCalled);ASSERT_TRUE(l2->startCalled);ASSERT_FALSE(l2->cancelCalled);ASSERT_TRUE(l2->endCalled); }}  );
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a2->IsRunning()  );
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a2->IsRunning()  );
long startDelay=150  ;
a1->setStartDelay(startDelay);
long [] startTime= newlong[1] ;
a1->Play();
a2->Play();
startTime[0]=SystemClock->uptimeMillis()  ;
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a2->IsRunning()  );
a1->Play();
a2->Play();
startTime[0]=SystemClock->uptimeMillis()  ;
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a2->IsRunning()  );
mActivityRule->runOnUiThread(new Runnable(){void run() { a1->Play();a2->Play();startTime[0]=SystemClock->uptimeMillis()  ;ASSERT_TRUE(a1->IsRunning()  );ASSERT_TRUE(a2->IsRunning()  ); }}  );
long delayMs=0  ;
Thread->sleep(POLL_INTERVAL);
delayMs+=POLL_INTERVAL;
ASSERT_FALSE(a1->IsRunning()  );
if(SystemClock->uptimeMillis()   - startTime[0]   < startDelay){ ASSERT_FALSE(a1->IsRunning()  ); }
ASSERT_FALSE(a1->IsRunning()  );
if(SystemClock->uptimeMillis()   - startTime[0]   < startDelay){ ASSERT_FALSE(a1->IsRunning()  ); }
mActivityRule->runOnUiThread(new Runnable(){void run() { if(SystemClock->uptimeMillis()   - startTime[0]   < startDelay){ ASSERT_FALSE(a1->IsRunning()  ); } }}  );
while(delayMs < startDelay){ Thread->sleep(POLL_INTERVAL);delayMs+=POLL_INTERVAL;mActivityRule->runOnUiThread(new Runnable(){void run() { if(SystemClock->uptimeMillis()   - startTime[0]   < startDelay){ ASSERT_FALSE(a1->IsRunning()  ); } }}  ); }
Thread->sleep(startDelay);
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a2->IsRunning()  );
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a2->IsRunning()  );
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_TRUE(a1->IsRunning()  );ASSERT_TRUE(a2->IsRunning()  ); }}  );
long delay=Math->max(a1->getTotalDuration()  ,a2->getTotalDuration()  )   * 2  ;
Thread->sleep(delay);
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a2->IsRunning()  );
ASSERT_FALSE(a2->IsRunning()  );
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a2->IsRunning()  );
ASSERT_FALSE(a2->IsRunning()  );
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_FALSE(a1->IsRunning()  );ASSERT_FALSE(a1->IsRunning()  );ASSERT_FALSE(a2->IsRunning()  );ASSERT_FALSE(a2->IsRunning()  ); }}  );
ASSERT_FALSE(a1->IsPending()  );
ASSERT_FALSE(a2->IsPending()  );
a1->Play();
a2->Play();
ASSERT_FALSE(a1->IsPending()  );
ASSERT_FALSE(a2->IsPending()  );
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a2->IsRunning()  );
ASSERT_FALSE(a1->IsPending()  );
ASSERT_FALSE(a2->IsPending()  );
a1->Play();
a2->Play();
ASSERT_FALSE(a1->IsPending()  );
ASSERT_FALSE(a2->IsPending()  );
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a2->IsRunning()  );
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_FALSE(a1->IsPending()  );ASSERT_FALSE(a2->IsPending()  );a1->Play();a2->Play();ASSERT_FALSE(a1->IsPending()  );ASSERT_FALSE(a2->IsPending()  );ASSERT_TRUE(a1->IsRunning()  );ASSERT_TRUE(a2->IsRunning()  ); }}  );
Thread->sleep(POLL_INTERVAL);
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a2->IsRunning()  );
a1->Pause();
ASSERT_TRUE(a1->IsPending()  );
ASSERT_FALSE(a2->IsPending()  );
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a2->IsRunning()  );
a1->Pause();
ASSERT_TRUE(a1->IsPending()  );
ASSERT_FALSE(a2->IsPending()  );
ASSERT_TRUE(a1->IsRunning()  );
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_TRUE(a1->IsRunning()  );ASSERT_TRUE(a2->IsRunning()  );a1->Pause();ASSERT_TRUE(a1->IsPending()  );ASSERT_FALSE(a2->IsPending()  );ASSERT_TRUE(a1->IsRunning()  ); }}  );
Thread->sleep(a2->getTotalDuration()  );
ASSERT_FALSE(a2->IsRunning()  );
ASSERT_FALSE(a2->IsRunning()  );
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a1->IsPending()  );
a1->resume();
ASSERT_FALSE(a2->IsRunning()  );
ASSERT_FALSE(a2->IsRunning()  );
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a1->IsPending()  );
a1->resume();
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_FALSE(a2->IsRunning()  );ASSERT_FALSE(a2->IsRunning()  );ASSERT_TRUE(a1->IsRunning()  );ASSERT_TRUE(a1->IsRunning()  );ASSERT_TRUE(a1->IsPending()  );a1->resume(); }}  );
Thread->sleep(POLL_INTERVAL);
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_FALSE(a1->IsPending()  );
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_FALSE(a1->IsPending()  );
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_TRUE(a1->IsRunning()  );ASSERT_TRUE(a1->IsRunning()  );ASSERT_FALSE(a1->IsPending()  ); }}  );
Thread->sleep(a1->getTotalDuration()  );
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a1->IsPending()  );
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a1->IsPending()  );
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_FALSE(a1->IsRunning()  );ASSERT_FALSE(a1->IsRunning()  );ASSERT_FALSE(a1->IsPending()  ); }}  );
ValueAnimatorTests::MyPauseListener l1=new ValueAnimatorTests::MyPauseListener()  ;
ValueAnimatorTests::MyPauseListener l2=new ValueAnimatorTests::MyPauseListener()  ;
a1->addPauseListener(l1);
a2->addPauseListener(l2);
ASSERT_FALSE(l1->pauseCalled);
ASSERT_FALSE(l1->resumeCalled);
ASSERT_FALSE(l2->pauseCalled);
ASSERT_FALSE(l2->resumeCalled);
a1->Play();
a2->Play();
a1->Play();
a2->Play();
mActivityRule->runOnUiThread(new Runnable(){void run() { a1->Play();a2->Play(); }}  );
Thread->sleep(a1->getTotalDuration()   / 2  );
a1->Pause();
Thread->sleep(a2->getTotalDuration()  );
ASSERT_TRUE(l1->pauseCalled);
ASSERT_FALSE(l1->resumeCalled);
a1->resume();
a1->resume();
mActivityRule->runOnUiThread(new Runnable(){void run() { a1->resume(); }}  );
Thread->sleep(a1->getTotalDuration()  );
ASSERT_TRUE(l1->pauseCalled);
ASSERT_TRUE(l1->resumeCalled);
ASSERT_FALSE(l2->pauseCalled);
ASSERT_FALSE(l2->resumeCalled);
ValueAnimatorTests::MyUpdateListener l1=new ValueAnimatorTests::MyUpdateListener()  ;
long totalDuration=a1->getTotalDuration()  ;
a1->AddUpdateListener(l1);
a1->setDuration(1000  );
ASSERT_TRUE(l1->firstRunningFrameTime < 0  );
ASSERT_TRUE(l1->lastUpdateTime < 0  );
long [] lastUpdate= newlong[1] ;
a1->Play();
a1->Play();
mActivityRule->runOnUiThread(new Runnable(){void run() { a1->Play(); }}  );
Thread->sleep(totalDuration / 2  );
ASSERT_TRUE(l1->firstRunningFrameTime > 0  );
ASSERT_TRUE(l1->lastUpdateTime > l1->firstRunningFrameTime);
lastUpdate[0]=l1->lastUpdateTime;
a1->Pause();
ASSERT_TRUE(l1->firstRunningFrameTime > 0  );
ASSERT_TRUE(l1->lastUpdateTime > l1->firstRunningFrameTime);
lastUpdate[0]=l1->lastUpdateTime;
a1->Pause();
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_TRUE(l1->firstRunningFrameTime > 0  );ASSERT_TRUE(l1->lastUpdateTime > l1->firstRunningFrameTime);lastUpdate[0]=l1->lastUpdateTime;a1->Pause(); }}  );
Thread->sleep(totalDuration);
ASSERT_EQ(lastUpdate[0]  ,l1->lastUpdateTime);
a1->resume();
ASSERT_EQ(lastUpdate[0]  ,l1->lastUpdateTime);
a1->resume();
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_EQ(lastUpdate[0]  ,l1->lastUpdateTime);a1->resume(); }}  );
Thread->sleep(POLL_INTERVAL);
ASSERT_TRUE(l1->lastUpdateTime > lastUpdate[0]  );
lastUpdate[0]=l1->lastUpdateTime;
ASSERT_TRUE(l1->lastUpdateTime > lastUpdate[0]  );
lastUpdate[0]=l1->lastUpdateTime;
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_TRUE(l1->lastUpdateTime > lastUpdate[0]  );lastUpdate[0]=l1->lastUpdateTime; }}  );
do{ Thread->sleep(POLL_INTERVAL);mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_TRUE(l1->lastUpdateTime > lastUpdate[0]  );lastUpdate[0]=l1->lastUpdateTime; }}  ); }while(!a1->IsRunning()  );
long entireSpan=totalDuration * 2  ;
long frameDelta=l1->lastUpdateTime - l1->firstRunningFrameTime;
ASSERT_TRUE(Math->abs(entireSpan - frameDelta)   < TOLERANCE);
ValueAnimatorTests::MyListener l1=new ValueAnimatorTests::MyListener()  ;
ValueAnimatorTests::MyListener l2=new ValueAnimatorTests::MyListener()  ;
a1->addListener(l1);
a2->addListener(l2);
anim->Cancel();
anim->Cancel();
a1->addListener(new ValueAnimatorTests::MyListener(){void onAnimationEnd(ACE_EXPORTAnimator *  anim) { anim->Cancel(); }}  );
anim->end();
anim->end();
a2->addListener(new ValueAnimatorTests::MyListener(){void onAnimationCancel(ACE_EXPORTAnimator *  anim) { anim->end(); }}  );
ASSERT_FALSE(l1->cancelCalled);
ASSERT_FALSE(l1->endCalled);
ASSERT_FALSE(l2->cancelCalled);
ASSERT_FALSE(l2->endCalled);
a1->Play();
a2->Play();
ASSERT_FALSE(l1->cancelCalled);
ASSERT_FALSE(l1->endCalled);
ASSERT_FALSE(l2->cancelCalled);
ASSERT_FALSE(l2->endCalled);
a1->Play();
a2->Play();
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_FALSE(l1->cancelCalled);ASSERT_FALSE(l1->endCalled);ASSERT_FALSE(l2->cancelCalled);ASSERT_FALSE(l2->endCalled);a1->Play();a2->Play(); }}  );
Thread->sleep(POLL_INTERVAL);
a1->Stop();
a2->cancel();
a1->Stop();
a2->cancel();
mActivityRule->runOnUiThread(new Runnable(){void run() { a1->Stop();a2->cancel(); }}  );
Thread->sleep(POLL_INTERVAL);
ASSERT_FALSE(l1->cancelCalled);
ASSERT_TRUE(l1->endCalled);
ASSERT_TRUE(l2->cancelCalled);
ASSERT_TRUE(l2->endCalled);
float value1=(Float)a1.getAnimatedValue();
int value2=(Integer)a2.getAnimatedValue();
ASSERT_EQ(A1_END_VALUE,value1);
ASSERT_EQ(A2_END_VALUE,value2);
ASSERT_FALSE(l1->cancelCalled);
ASSERT_TRUE(l1->endCalled);
ASSERT_TRUE(l2->cancelCalled);
ASSERT_TRUE(l2->endCalled);
float value1=(Float)a1.getAnimatedValue();
int value2=(Integer)a2.getAnimatedValue();
ASSERT_EQ(A1_END_VALUE,value1);
ASSERT_EQ(A2_END_VALUE,value2);
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_FALSE(l1->cancelCalled);ASSERT_TRUE(l1->endCalled);ASSERT_TRUE(l2->cancelCalled);ASSERT_TRUE(l2->endCalled);float value1=(Float)a1.getAnimatedValue();int value2=(Integer)a2.getAnimatedValue();ASSERT_EQ(A1_END_VALUE,value1);ASSERT_EQ(A2_END_VALUE,value2); }}  );
ValueAnimatorTests::MyListener l1=new ValueAnimatorTests::MyListener()  ;
a1->addListener(l1);
ValueAnimatorTests::MyListener l2=new ValueAnimatorTests::MyListener()  ;
a2->addListener(l2);
a1->Play();
a2->Play();
a1->Play();
a2->Play();
mActivityRule->runOnUiThread(new Runnable(){void run() { a1->Play();a2->Play(); }}  );
Thread->sleep(POLL_INTERVAL);
ASSERT_FALSE(l1->endCalled);
ASSERT_FALSE(l2->endCalled);
assertNotEqual(A1_END_VALUE,a1->getAnimatedValue()  );
assertNotEqual(A1_END_VALUE,a2->getAnimatedValue()  );
a2->Stop();
ASSERT_FALSE(l1->endCalled);
ASSERT_FALSE(l2->endCalled);
assertNotEqual(A1_END_VALUE,a1->getAnimatedValue()  );
assertNotEqual(A1_END_VALUE,a2->getAnimatedValue()  );
a2->Stop();
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_FALSE(l1->endCalled);ASSERT_FALSE(l2->endCalled);assertNotEqual(A1_END_VALUE,a1->getAnimatedValue()  );assertNotEqual(A1_END_VALUE,a2->getAnimatedValue()  );a2->Stop(); }}  );
Thread->sleep(a1->getTotalDuration()  );
ASSERT_FALSE(l1->cancelCalled);
ASSERT_TRUE(l1->endCalled);
ASSERT_FALSE(l2->cancelCalled);
ASSERT_TRUE(l2->endCalled);
ASSERT_EQ(A1_END_VALUE,((Float)(a1.getAnimatedValue()))  -> floatValue());
ASSERT_EQ(A2_END_VALUE,((Integer)(a2.getAnimatedValue()))  -> intValue());
ASSERT_FALSE(l1->cancelCalled);
ASSERT_TRUE(l1->endCalled);
ASSERT_FALSE(l2->cancelCalled);
ASSERT_TRUE(l2->endCalled);
ASSERT_EQ(A1_END_VALUE,((Float)(a1.getAnimatedValue()))  -> floatValue());
ASSERT_EQ(A2_END_VALUE,((Integer)(a2.getAnimatedValue()))  -> intValue());
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_FALSE(l1->cancelCalled);ASSERT_TRUE(l1->endCalled);ASSERT_FALSE(l2->cancelCalled);ASSERT_TRUE(l2->endCalled);ASSERT_EQ(A1_END_VALUE,((Float)(a1.getAnimatedValue()))  -> floatValue());ASSERT_EQ(A2_END_VALUE,((Integer)(a2.getAnimatedValue()))  -> intValue()); }}  );
ValueAnimatorTests::MyFrameCallbackProvider provider=new ValueAnimatorTests::MyFrameCallbackProvider()  ;
long sleep=0  ;
Thread->sleep(POLL_INTERVAL);
sleep+=POLL_INTERVAL;
break;
if(sleep > WAIT_TIME_OUT){ break; }
while(provider->mHandler == null  ){ Thread->sleep(POLL_INTERVAL);sleep+=POLL_INTERVAL;if(sleep > WAIT_TIME_OUT){ break; } }
assertNotNull(provider->mHandler);
ValueAnimatorTests::MyListener listener=new ValueAnimatorTests::MyListener()  ;
long currentTime=SystemClock->uptimeMillis()  ;
long frameDelay=provider->getFrameDelay()  ;
ASSERT_TRUE((currentTime-lastUpdateTime)   < frameDelay * 4  );
ASSERT_TRUE(listener->startCalled);
ASSERT_TRUE(listener->startTime > 0  );
ASSERT_TRUE(currentTime - listener->startTime < frameDelay * 4  );
if(lastUpdateTime > 0  ){ ASSERT_TRUE((currentTime-lastUpdateTime)   < frameDelay * 4  ); }else{ ASSERT_TRUE(listener->startCalled);ASSERT_TRUE(listener->startTime > 0  );ASSERT_TRUE(currentTime - listener->startTime < frameDelay * 4  ); }
super-> onAnimationUpdate(animation);
ValueAnimatorTests::MyUpdateListener l1=new ValueAnimatorTests::MyUpdateListener(){void onAnimationUpdate(ACE_EXPORTAnimator *  animation) { long currentTime=SystemClock->uptimeMillis()  ;long frameDelay=provider->getFrameDelay()  ;if(lastUpdateTime > 0  ){ ASSERT_TRUE((currentTime-lastUpdateTime)   < frameDelay * 4  ); }else{ ASSERT_TRUE(listener->startCalled);ASSERT_TRUE(listener->startTime > 0  );ASSERT_TRUE(currentTime - listener->startTime < frameDelay * 4  ); }super-> onAnimationUpdate(animation); }}  ;
a1->AddUpdateListener(l1);
a1->addListener(listener);
a1->setStartDelay(100  );
AnimationHandler->getInstance()  -> setProvider(provider);
a1->Play();
AnimationHandler->getInstance()  -> setProvider(provider);
a1->Play();
provider.mHandler->post(new Runnable(){void run() { AnimationHandler->getInstance()  -> setProvider(provider);a1->Play(); }}  );
Thread->sleep(POLL_INTERVAL);
ASSERT_TRUE(a1->IsRunning()  );
Thread->sleep(a1->getTotalDuration()   + TOLERANCE);
throwprovider->mAssertionError;
if(provider->mAssertionError != null  ){ throwprovider->mAssertionError; }
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_TRUE(listener->endTime > 0  );
ASSERT_TRUE(listener->endTime >= l1->lastUpdateTime);
ASSERT_TRUE(listener->endTime - l1->lastUpdateTime < 2   * provider->getFrameDelay()  );
ACE_EXPORTAnimator *  a0=ValueAnimator->ofInt(100  ,200  )  -> setDuration(500  );
ACE_EXPORTAnimator *  a3=ValueAnimator->ofFloat(0  ,1  )  -> setDuration(500  );
ACE_EXPORTAnimator *  a4=ValueAnimator->ofInt(200  ,300  )  -> setDuration(500  );
super-> onAnimationEnd(anim);
a0->cancel();
a1->Stop();
a3->Stop();
a4->cancel();
ValueAnimatorTests::MyListener listener=new ValueAnimatorTests::MyListener(){void onAnimationEnd(ACE_EXPORTAnimator *  anim) { super-> onAnimationEnd(anim);a0->cancel();a1->Stop();a3->Stop();a4->cancel(); }}  ;
a2->addListener(listener);
a0->Play();
a1->Play();
a2->Play();
a3->Play();
a4->Play();
a0->Play();
a1->Play();
a2->Play();
a3->Play();
a4->Play();
mActivityRule->runOnUiThread(new Runnable(){void run() { a0->Play();a1->Play();a2->Play();a3->Play();a4->Play(); }}  );
ASSERT_TRUE(a0->IsRunning()  );
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a2->IsRunning()  );
ASSERT_TRUE(a3->IsRunning()  );
ASSERT_TRUE(a4->IsRunning()  );
ASSERT_TRUE(a0->IsRunning()  );
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a2->IsRunning()  );
ASSERT_TRUE(a3->IsRunning()  );
ASSERT_TRUE(a4->IsRunning()  );
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_TRUE(a0->IsRunning()  );ASSERT_TRUE(a1->IsRunning()  );ASSERT_TRUE(a2->IsRunning()  );ASSERT_TRUE(a3->IsRunning()  );ASSERT_TRUE(a4->IsRunning()  ); }}  );
Thread->sleep(POLL_INTERVAL);
a2->Stop();
a2->Stop();
mActivityRule->runOnUiThread(new Runnable(){void run() { a2->Stop(); }}  );
Thread->sleep(POLL_INTERVAL);
ASSERT_TRUE(listener->endCalled);
ASSERT_FALSE(a0->IsRunning()  );
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a2->IsRunning()  );
ASSERT_FALSE(a3->IsRunning()  );
ASSERT_FALSE(a4->IsRunning()  );
ValueAnimatorTests::MyListener l1=new ValueAnimatorTests::MyListener()  ;
ValueAnimatorTests::MyListener l2=new ValueAnimatorTests::MyListener()  ;
ValueAnimatorTests::MyUpdateListener updateListener1=new ValueAnimatorTests::MyUpdateListener()  ;
ValueAnimatorTests::MyUpdateListener updateListener2=new ValueAnimatorTests::MyUpdateListener()  ;
float a1StartFraction=0.2f  ;
float a2StartFraction=0.3f  ;
a1->setDuration(1000  );
a2->setDuration(1000  );
a1->addListener(l1);
a2->addListener(l2);
a1->AddUpdateListener(updateListener1);
a2->AddUpdateListener(updateListener2);
//以下组件没有匹配:
//TimeInterpolator,LinearInterpolator
TimeInterpolator *  interpolator=new LinearInterpolator()  ;
a1->setInterpolator(interpolator);
a2->setInterpolator(interpolator);
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a2->IsRunning()  );
ASSERT_FALSE(a2->IsRunning()  );
a1->setCurrentFraction(a1StartFraction);
a2->setCurrentFraction(a2StartFraction);
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a2->IsRunning()  );
ASSERT_FALSE(a2->IsRunning()  );
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a2->IsRunning()  );
ASSERT_FALSE(a2->IsRunning()  );
a1->setCurrentFraction(a1StartFraction);
a2->setCurrentFraction(a2StartFraction);
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a2->IsRunning()  );
ASSERT_FALSE(a2->IsRunning()  );
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_FALSE(a1->IsRunning()  );ASSERT_FALSE(a1->IsRunning()  );ASSERT_FALSE(a2->IsRunning()  );ASSERT_FALSE(a2->IsRunning()  );a1->setCurrentFraction(a1StartFraction);a2->setCurrentFraction(a2StartFraction);ASSERT_FALSE(a1->IsRunning()  );ASSERT_FALSE(a1->IsRunning()  );ASSERT_FALSE(a2->IsRunning()  );ASSERT_FALSE(a2->IsRunning()  ); }}  );
Thread->sleep(POLL_INTERVAL);
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a2->IsRunning()  );
ASSERT_FALSE(a2->IsRunning()  );
ASSERT_EQ(a1StartFraction,a1->getAnimatedFraction()  );
ASSERT_EQ(a2StartFraction,a2->getAnimatedFraction()  );
a1->Play();
a2->Play();
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a2->IsRunning()  );
ASSERT_FALSE(a2->IsRunning()  );
ASSERT_EQ(a1StartFraction,a1->getAnimatedFraction()  );
ASSERT_EQ(a2StartFraction,a2->getAnimatedFraction()  );
a1->Play();
a2->Play();
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_FALSE(a1->IsRunning()  );ASSERT_FALSE(a1->IsRunning()  );ASSERT_FALSE(a2->IsRunning()  );ASSERT_FALSE(a2->IsRunning()  );ASSERT_EQ(a1StartFraction,a1->getAnimatedFraction()  );ASSERT_EQ(a2StartFraction,a2->getAnimatedFraction()  );a1->Play();a2->Play(); }}  );
Thread->sleep(POLL_INTERVAL);
float halfwayFraction=0.5f  ;
ASSERT_TRUE(l1->startCalled);
ASSERT_TRUE(l2->startCalled);
ASSERT_FALSE(l1->endCalled);
ASSERT_FALSE(l2->endCalled);
ASSERT_TRUE(updateListener1->startFraction >= a1StartFraction);
ASSERT_TRUE(updateListener2->startFraction >= a2StartFraction);
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a2->IsRunning()  );
ASSERT_TRUE(a2->IsRunning()  );
a1->setCurrentFraction(halfwayFraction);
a2->setCurrentFraction(halfwayFraction);
ASSERT_TRUE(l1->startCalled);
ASSERT_TRUE(l2->startCalled);
ASSERT_FALSE(l1->endCalled);
ASSERT_FALSE(l2->endCalled);
ASSERT_TRUE(updateListener1->startFraction >= a1StartFraction);
ASSERT_TRUE(updateListener2->startFraction >= a2StartFraction);
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a2->IsRunning()  );
ASSERT_TRUE(a2->IsRunning()  );
a1->setCurrentFraction(halfwayFraction);
a2->setCurrentFraction(halfwayFraction);
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_TRUE(l1->startCalled);ASSERT_TRUE(l2->startCalled);ASSERT_FALSE(l1->endCalled);ASSERT_FALSE(l2->endCalled);ASSERT_TRUE(updateListener1->startFraction >= a1StartFraction);ASSERT_TRUE(updateListener2->startFraction >= a2StartFraction);ASSERT_TRUE(a1->IsRunning()  );ASSERT_TRUE(a1->IsRunning()  );ASSERT_TRUE(a2->IsRunning()  );ASSERT_TRUE(a2->IsRunning()  );a1->setCurrentFraction(halfwayFraction);a2->setCurrentFraction(halfwayFraction); }}  );
Thread->sleep(POLL_INTERVAL);
ASSERT_TRUE(l1->startCalled);
ASSERT_TRUE(l2->startCalled);
ASSERT_FALSE(l1->endCalled);
ASSERT_FALSE(l2->endCalled);
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a2->IsRunning()  );
ASSERT_TRUE(a2->IsRunning()  );
ASSERT_TRUE(l1->startCalled);
ASSERT_TRUE(l2->startCalled);
ASSERT_FALSE(l1->endCalled);
ASSERT_FALSE(l2->endCalled);
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a2->IsRunning()  );
ASSERT_TRUE(a2->IsRunning()  );
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_TRUE(l1->startCalled);ASSERT_TRUE(l2->startCalled);ASSERT_FALSE(l1->endCalled);ASSERT_FALSE(l2->endCalled);ASSERT_TRUE(a1->IsRunning()  );ASSERT_TRUE(a1->IsRunning()  );ASSERT_TRUE(a2->IsRunning()  );ASSERT_TRUE(a2->IsRunning()  ); }}  );
long wait=Math->max(a1->getTotalDuration()  ,a2->getTotalDuration()  )  ;
Thread->sleep(wait);
ASSERT_TRUE(l1->endCalled);
ASSERT_TRUE(l2->endCalled);
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a2->IsRunning()  );
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a2->IsRunning()  );
ASSERT_TRUE(l1->endCalled);
ASSERT_TRUE(l2->endCalled);
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a2->IsRunning()  );
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a2->IsRunning()  );
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_TRUE(l1->endCalled);ASSERT_TRUE(l2->endCalled);ASSERT_FALSE(a1->IsRunning()  );ASSERT_FALSE(a2->IsRunning()  );ASSERT_FALSE(a1->IsRunning()  );ASSERT_FALSE(a2->IsRunning()  ); }}  );
updateListener1->reset();
a1->Play();
a1->Play();
mActivityRule->runOnUiThread(new Runnable(){void run() { a1->Play(); }}  );
Thread->sleep(POLL_INTERVAL);
ASSERT_TRUE(updateListener1->wasRunning);
ASSERT_TRUE(updateListener1->startFraction >= 0  );
ASSERT_TRUE(updateListener1->startFraction < halfwayFraction);
a1->Stop();
ASSERT_TRUE(updateListener1->wasRunning);
ASSERT_TRUE(updateListener1->startFraction >= 0  );
ASSERT_TRUE(updateListener1->startFraction < halfwayFraction);
a1->Stop();
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_TRUE(updateListener1->wasRunning);ASSERT_TRUE(updateListener1->startFraction >= 0  );ASSERT_TRUE(updateListener1->startFraction < halfwayFraction);a1->Stop(); }}  );
ValueAnimatorTests::MyListener l1=new ValueAnimatorTests::MyListener()  ;
ValueAnimatorTests::MyListener l2=new ValueAnimatorTests::MyListener()  ;
a1->addListener(l1);
a2->addListener(l2);
ASSERT_FALSE(l1->startCalled);
ASSERT_FALSE(l2->startCalled);
ASSERT_EQ(0f  ,a1->getAnimatedFraction()  );
ASSERT_EQ(0f  ,a2->getAnimatedFraction()  );
a1->Play();
a2->Play();
ASSERT_FALSE(l1->startCalled);
ASSERT_FALSE(l2->startCalled);
ASSERT_EQ(0f  ,a1->getAnimatedFraction()  );
ASSERT_EQ(0f  ,a2->getAnimatedFraction()  );
a1->Play();
a2->Play();
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_FALSE(l1->startCalled);ASSERT_FALSE(l2->startCalled);ASSERT_EQ(0f  ,a1->getAnimatedFraction()  );ASSERT_EQ(0f  ,a2->getAnimatedFraction()  );a1->Play();a2->Play(); }}  );
Thread->sleep(POLL_INTERVAL);
ASSERT_FALSE(l1->endCalled);
ASSERT_FALSE(l2->endCalled);
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a2->IsRunning()  );
a1->setCurrentFraction(0f  );
a2->setCurrentFraction(1f  );
ASSERT_FALSE(l1->endCalled);
ASSERT_FALSE(l2->endCalled);
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a2->IsRunning()  );
a1->setCurrentFraction(0f  );
a2->setCurrentFraction(1f  );
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_FALSE(l1->endCalled);ASSERT_FALSE(l2->endCalled);ASSERT_TRUE(a1->IsRunning()  );ASSERT_TRUE(a2->IsRunning()  );a1->setCurrentFraction(0f  );a2->setCurrentFraction(1f  ); }}  );
Thread->sleep(POLL_INTERVAL);
ASSERT_FALSE(l1->endCalled);
ASSERT_TRUE(l2->endCalled);
ASSERT_EQ(1f  ,a2->getAnimatedFraction()  );
ASSERT_FALSE(l1->endCalled);
ASSERT_TRUE(l2->endCalled);
ASSERT_EQ(1f  ,a2->getAnimatedFraction()  );
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_FALSE(l1->endCalled);ASSERT_TRUE(l2->endCalled);ASSERT_EQ(1f  ,a2->getAnimatedFraction()  ); }}  );
Thread->sleep(a1->getTotalDuration()  );
ASSERT_TRUE(l1->endCalled);
ASSERT_EQ(1f  ,a1->getAnimatedFraction()  );
ASSERT_TRUE(l1->endCalled);
ASSERT_EQ(1f  ,a1->getAnimatedFraction()  );
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_TRUE(l1->endCalled);ASSERT_EQ(1f  ,a1->getAnimatedFraction()  ); }}  );
a1->setStartDelay(20  );
ValueAnimatorTests::MyListener normalEndingListener=new ValueAnimatorTests::MyListener()  ;
a1->addListener(normalEndingListener);
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(normalEndingListener->startCalled);
ASSERT_FALSE(normalEndingListener->endCalled);
a1->Play();
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(normalEndingListener->startCalled);
ASSERT_FALSE(normalEndingListener->endCalled);
a1->Play();
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_FALSE(a1->IsRunning()  );ASSERT_FALSE(normalEndingListener->startCalled);ASSERT_FALSE(normalEndingListener->endCalled);a1->Play(); }}  );
Thread->sleep(a1->getTotalDuration()   + POLL_INTERVAL);
ValueAnimatorTests::MyListener l1=new ValueAnimatorTests::MyListener()  ;
a1->addListener(l1);
ValueAnimatorTests::MyListener l2=new ValueAnimatorTests::MyListener()  ;
a2->addListener(l2);
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(l1->startCalled);
ASSERT_FALSE(l1->endCalled);
ASSERT_FALSE(a2->IsRunning()  );
ASSERT_FALSE(l2->startCalled);
ASSERT_FALSE(l1->endCalled);
a1->Stop();
a2->Stop();
ASSERT_TRUE(l1->startCalled);
ASSERT_TRUE(l1->endCalled);
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_TRUE(l1->endTime >= l1->startTime);
ASSERT_TRUE(l2->startCalled);
ASSERT_TRUE(l2->endCalled);
ASSERT_FALSE(a2->IsRunning()  );
ASSERT_TRUE(l2->endTime >= l1->startTime);
ValueAnimatorTests::MyListener l1=new ValueAnimatorTests::MyListener()  ;
a1->addListener(l1);
ValueAnimatorTests::MyListener l2=new ValueAnimatorTests::MyListener()  ;
a2->addListener(l2);
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(l1->startCalled);
ASSERT_FALSE(l1->endCalled);
ASSERT_FALSE(a2->IsRunning()  );
ASSERT_FALSE(l2->startCalled);
ASSERT_FALSE(l1->endCalled);
a1->Stop();
a2->Stop();
ASSERT_TRUE(l1->startCalled);
ASSERT_TRUE(l1->endCalled);
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_TRUE(l1->endTime >= l1->startTime);
ASSERT_TRUE(l2->startCalled);
ASSERT_TRUE(l2->endCalled);
ASSERT_FALSE(a2->IsRunning()  );
ASSERT_TRUE(l2->endTime >= l1->startTime);
mActivityRule->runOnUiThread(new Runnable(){void run() { ValueAnimatorTests::MyListener l1=new ValueAnimatorTests::MyListener()  ;a1->addListener(l1);ValueAnimatorTests::MyListener l2=new ValueAnimatorTests::MyListener()  ;a2->addListener(l2);ASSERT_FALSE(a1->IsRunning()  );ASSERT_FALSE(l1->startCalled);ASSERT_FALSE(l1->endCalled);ASSERT_FALSE(a2->IsRunning()  );ASSERT_FALSE(l2->startCalled);ASSERT_FALSE(l1->endCalled);a1->Stop();a2->Stop();ASSERT_TRUE(l1->startCalled);ASSERT_TRUE(l1->endCalled);ASSERT_FALSE(a1->IsRunning()  );ASSERT_TRUE(l1->endTime >= l1->startTime);ASSERT_TRUE(l2->startCalled);ASSERT_TRUE(l2->endCalled);ASSERT_FALSE(a2->IsRunning()  );ASSERT_TRUE(l2->endTime >= l1->startTime); }}  );
a1->setDuration(0  );
a2->setDuration(0  );
ACE_EXPORTAnimator *  a3=ValueAnimator->ofInt(0  ,100  )  ;
a3->setDuration(0  );
a3->setCurrentFraction(1.0f  );
ASSERT_EQ(1.0f  ,a3->getAnimatedFraction()  );
ValueAnimatorTests::MyListener l1=new ValueAnimatorTests::MyListener()  ;
ValueAnimatorTests::MyListener l2=new ValueAnimatorTests::MyListener()  ;
ValueAnimatorTests::MyListener l3=new ValueAnimatorTests::MyListener()  ;
a1->addListener(l1);
a2->addListener(l2);
a3->addListener(l3);
ASSERT_FALSE(l1->startCalled);
ASSERT_FALSE(l2->startCalled);
ASSERT_FALSE(l3->startCalled);
ASSERT_FALSE(l1->endCalled);
ASSERT_FALSE(l2->endCalled);
ASSERT_FALSE(l3->endCalled);
a1->Play();
a2->reverse();
a3->Play();
ASSERT_EQ(A1_END_VALUE,a1->getAnimatedValue()  );
ASSERT_EQ(A2_START_VALUE,a2->getAnimatedValue()  );
ASSERT_FALSE(l1->startCalled);
ASSERT_FALSE(l2->startCalled);
ASSERT_FALSE(l3->startCalled);
ASSERT_FALSE(l1->endCalled);
ASSERT_FALSE(l2->endCalled);
ASSERT_FALSE(l3->endCalled);
a1->Play();
a2->reverse();
a3->Play();
ASSERT_EQ(A1_END_VALUE,a1->getAnimatedValue()  );
ASSERT_EQ(A2_START_VALUE,a2->getAnimatedValue()  );
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_FALSE(l1->startCalled);ASSERT_FALSE(l2->startCalled);ASSERT_FALSE(l3->startCalled);ASSERT_FALSE(l1->endCalled);ASSERT_FALSE(l2->endCalled);ASSERT_FALSE(l3->endCalled);a1->Play();a2->reverse();a3->Play();ASSERT_EQ(A1_END_VALUE,a1->getAnimatedValue()  );ASSERT_EQ(A2_START_VALUE,a2->getAnimatedValue()  ); }}  );
Thread->sleep(POLL_INTERVAL);
ASSERT_TRUE(l1->startCalled);
ASSERT_TRUE(l2->startCalled);
ASSERT_TRUE(l3->startCalled);
ASSERT_TRUE(l1->endCalled);
ASSERT_TRUE(l2->endCalled);
ASSERT_TRUE(l3->endCalled);
ASSERT_EQ(1.0f  ,a1->getAnimatedFraction()  );
ASSERT_EQ(0f  ,a2->getAnimatedFraction()  );
ASSERT_EQ(1f  ,a3->getAnimatedFraction()  );
ASSERT_EQ(A1_END_VALUE,a1->getAnimatedValue()  );
ASSERT_EQ(A2_START_VALUE,a2->getAnimatedValue()  );
ASSERT_EQ(100  ,a3->getAnimatedValue()  );
ASSERT_TRUE(l1->startCalled);
ASSERT_TRUE(l2->startCalled);
ASSERT_TRUE(l3->startCalled);
ASSERT_TRUE(l1->endCalled);
ASSERT_TRUE(l2->endCalled);
ASSERT_TRUE(l3->endCalled);
ASSERT_EQ(1.0f  ,a1->getAnimatedFraction()  );
ASSERT_EQ(0f  ,a2->getAnimatedFraction()  );
ASSERT_EQ(1f  ,a3->getAnimatedFraction()  );
ASSERT_EQ(A1_END_VALUE,a1->getAnimatedValue()  );
ASSERT_EQ(A2_START_VALUE,a2->getAnimatedValue()  );
ASSERT_EQ(100  ,a3->getAnimatedValue()  );
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_TRUE(l1->startCalled);ASSERT_TRUE(l2->startCalled);ASSERT_TRUE(l3->startCalled);ASSERT_TRUE(l1->endCalled);ASSERT_TRUE(l2->endCalled);ASSERT_TRUE(l3->endCalled);ASSERT_EQ(1.0f  ,a1->getAnimatedFraction()  );ASSERT_EQ(0f  ,a2->getAnimatedFraction()  );ASSERT_EQ(1f  ,a3->getAnimatedFraction()  );ASSERT_EQ(A1_END_VALUE,a1->getAnimatedValue()  );ASSERT_EQ(A2_START_VALUE,a2->getAnimatedValue()  );ASSERT_EQ(100  ,a3->getAnimatedValue()  ); }}  );
float scale=ValueAnimator->getDurationScale()  ;
ValueAnimator->setDurationScale(0f  );
a1->setStartDelay(200  );
ValueAnimatorTests::MyListener l1=new ValueAnimatorTests::MyListener()  ;
ValueAnimatorTests::MyListener l2=new ValueAnimatorTests::MyListener()  ;
a1->addListener(l1);
a2->addListener(l2);
ASSERT_FALSE(l1->startCalled);
ASSERT_FALSE(l2->startCalled);
ASSERT_FALSE(l1->endCalled);
ASSERT_FALSE(l2->endCalled);
a1->Play();
a2->Play();
ASSERT_EQ(A2_START_VALUE,a2->getAnimatedValue()  );
ASSERT_FALSE(l1->startCalled);
ASSERT_FALSE(l2->startCalled);
ASSERT_FALSE(l1->endCalled);
ASSERT_FALSE(l2->endCalled);
a1->Play();
a2->Play();
ASSERT_EQ(A2_START_VALUE,a2->getAnimatedValue()  );
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_FALSE(l1->startCalled);ASSERT_FALSE(l2->startCalled);ASSERT_FALSE(l1->endCalled);ASSERT_FALSE(l2->endCalled);a1->Play();a2->Play();ASSERT_EQ(A2_START_VALUE,a2->getAnimatedValue()  ); }}  );
Thread->sleep(POLL_INTERVAL);
ASSERT_TRUE(l1->startCalled);
ASSERT_TRUE(l2->startCalled);
ASSERT_TRUE(l1->endCalled);
ASSERT_TRUE(l2->endCalled);
ASSERT_EQ(A1_END_VALUE,a1->getAnimatedValue()  );
ASSERT_EQ(A2_END_VALUE,a2->getAnimatedValue()  );
ASSERT_TRUE(l1->startCalled);
ASSERT_TRUE(l2->startCalled);
ASSERT_TRUE(l1->endCalled);
ASSERT_TRUE(l2->endCalled);
ASSERT_EQ(A1_END_VALUE,a1->getAnimatedValue()  );
ASSERT_EQ(A2_END_VALUE,a2->getAnimatedValue()  );
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_TRUE(l1->startCalled);ASSERT_TRUE(l2->startCalled);ASSERT_TRUE(l1->endCalled);ASSERT_TRUE(l2->endCalled);ASSERT_EQ(A1_END_VALUE,a1->getAnimatedValue()  );ASSERT_EQ(A2_END_VALUE,a2->getAnimatedValue()  ); }}  );
ValueAnimator->setDurationScale(scale);
ACE_EXPORTAnimator *  a3=ValueAnimator->ofInt(0  ,100  )  ;
a1->setDuration(400  );
a2->setDuration(600  );
a3->setDuration(400  );
ValueAnimatorTests::MyListener l1=new ValueAnimatorTests::MyListener()  ;
ValueAnimatorTests::MyListener l2=new ValueAnimatorTests::MyListener()  ;
ValueAnimatorTests::MyListener l3=new ValueAnimatorTests::MyListener()  ;
a1->addListener(l1);
a2->addListener(l2);
a3->addListener(l3);
ASSERT_FALSE(l1->startCalled);
ASSERT_FALSE(l2->startCalled);
ASSERT_FALSE(l3->startCalled);
ASSERT_FALSE(l1->endCalled);
ASSERT_FALSE(l2->endCalled);
ASSERT_FALSE(l3->endCalled);
a1->reverse();
a2->reverse();
a3->reverse();
ASSERT_FALSE(l1->startCalled);
ASSERT_FALSE(l2->startCalled);
ASSERT_FALSE(l3->startCalled);
ASSERT_FALSE(l1->endCalled);
ASSERT_FALSE(l2->endCalled);
ASSERT_FALSE(l3->endCalled);
a1->reverse();
a2->reverse();
a3->reverse();
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_FALSE(l1->startCalled);ASSERT_FALSE(l2->startCalled);ASSERT_FALSE(l3->startCalled);ASSERT_FALSE(l1->endCalled);ASSERT_FALSE(l2->endCalled);ASSERT_FALSE(l3->endCalled);a1->reverse();a2->reverse();a3->reverse(); }}  );
Thread->sleep(POLL_INTERVAL);
ASSERT_TRUE(l1->startCalled);
ASSERT_TRUE(l2->startCalled);
ASSERT_TRUE(l3->startCalled);
a1->setCurrentFraction(0f  );
a2->setCurrentFraction(1f  );
a3->Stop();
ASSERT_EQ(1f  ,a1->getAnimatedFraction()  );
ASSERT_EQ(0f  ,a2->getAnimatedFraction()  );
ASSERT_TRUE(l1->startCalled);
ASSERT_TRUE(l2->startCalled);
ASSERT_TRUE(l3->startCalled);
a1->setCurrentFraction(0f  );
a2->setCurrentFraction(1f  );
a3->Stop();
ASSERT_EQ(1f  ,a1->getAnimatedFraction()  );
ASSERT_EQ(0f  ,a2->getAnimatedFraction()  );
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_TRUE(l1->startCalled);ASSERT_TRUE(l2->startCalled);ASSERT_TRUE(l3->startCalled);a1->setCurrentFraction(0f  );a2->setCurrentFraction(1f  );a3->Stop();ASSERT_EQ(1f  ,a1->getAnimatedFraction()  );ASSERT_EQ(0f  ,a2->getAnimatedFraction()  ); }}  );
Thread->sleep(POLL_INTERVAL);
ASSERT_FALSE(l1->endCalled);
ASSERT_TRUE(l2->endCalled);
ASSERT_TRUE(l3->endCalled);
ASSERT_FALSE(l1->endCalled);
ASSERT_TRUE(l2->endCalled);
ASSERT_TRUE(l3->endCalled);
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_FALSE(l1->endCalled);ASSERT_TRUE(l2->endCalled);ASSERT_TRUE(l3->endCalled); }}  );
Thread->sleep(a1->getTotalDuration()  );
ASSERT_TRUE(l1->endCalled);
ASSERT_EQ(0f  ,a1->getAnimatedFraction()  );
ASSERT_EQ(0f  ,a2->getAnimatedFraction()  );
ASSERT_EQ(0f  ,a3->getAnimatedFraction()  );
ASSERT_TRUE(l1->endCalled);
ASSERT_EQ(0f  ,a1->getAnimatedFraction()  );
ASSERT_EQ(0f  ,a2->getAnimatedFraction()  );
ASSERT_EQ(0f  ,a3->getAnimatedFraction()  );
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_TRUE(l1->endCalled);ASSERT_EQ(0f  ,a1->getAnimatedFraction()  );ASSERT_EQ(0f  ,a2->getAnimatedFraction()  );ASSERT_EQ(0f  ,a3->getAnimatedFraction()  ); }}  );
}
//以下组件没有匹配:
//Runnable
void run()
{
lastUpdateTime=SystemClock->uptimeMillis()  ;
firstRunningFrameTime=lastUpdateTime;
startFraction=animation->getAnimatedFraction()  ;
wasRunning=animation->isRunning()  ;
if(animation->isRunning()   && !wasRunning){ firstRunningFrameTime=lastUpdateTime;startFraction=animation->getAnimatedFraction()  ;wasRunning=animation->isRunning()  ; }
wasRunning=false  ;
firstRunningFrameTime=-1  ;
lastUpdateTime=-1  ;
startFraction=0  ;
startCalled=true  ;
startTime=SystemClock->uptimeMillis()  ;
endCalled=true  ;
endTime=SystemClock->uptimeMillis()  ;
cancelCalled=true  ;
pauseCalled=true  ;
resumeCalled=true  ;
mHandler->sendEmptyMessageDelayed(MSG_FRAME,mFrameDelay);
mFrameCallbacks->add(callback);
if(!mFrameCallbacks->contains(callback)  ){ mFrameCallbacks->add(callback); }
mHandler->postDelayed(runnable,COMMIT_DELAY);
return SystemClock->uptimeMillis()  ;
return mFrameDelay;
mFrameDelay=delay;
mHandler->removeMessages(MSG_FRAME);
mHandler->sendEmptyMessageDelayed(MSG_FRAME,mFrameDelay);
if(mFrameCallbacks->size()   != 0  ){ mHandler->removeMessages(MSG_FRAME);mHandler->sendEmptyMessageDelayed(MSG_FRAME,mFrameDelay); }
Looper->prepare();
mFrameCallbacks->get(i)  -> doFrame(SystemClock->uptimeMillis()  );
for(int i=0  ;i < mFrameCallbacks->size()  ;i++){ mFrameCallbacks->get(i)  -> doFrame(SystemClock->uptimeMillis()  ); }
break;
break;
switch(msg->what){caseMSG_FRAME: for(int i=0  ;i < mFrameCallbacks->size()  ;i++){ mFrameCallbacks->get(i)  -> doFrame(SystemClock->uptimeMillis()  ); }break; default: break; }
{ switch(msg->what){caseMSG_FRAME: for(int i=0  ;i < mFrameCallbacks->size()  ;i++){ mFrameCallbacks->get(i)  -> doFrame(SystemClock->uptimeMillis()  ); }break; default: break; } }
mHandler=new Handler(){void handleMessage(Message *  msg) { { switch(msg->what){caseMSG_FRAME: for(int i=0  ;i < mFrameCallbacks->size()  ;i++){ mFrameCallbacks->get(i)  -> doFrame(SystemClock->uptimeMillis()  ); }break; default: break; } } }}  ;
Looper->loop();
a1=ValueAnimator->ofFloat(A1_START_VALUE,A1_END_VALUE)  -> setDuration(300  );
a2=ValueAnimator->ofInt(A2_START_VALUE,A2_END_VALUE)  -> setDuration(500  );
a1=null  ;
a2=null  ;
ACE_EXPORTAnimator *  a=ValueAnimator->ofFloat(5f  ,20f  )  ;
ASSERT_EQ(a->getStartDelay()  ,0  );
long delay=200  ;
a->setStartDelay(delay);
ASSERT_EQ(a->getStartDelay()  ,delay);
ValueAnimatorTests::MyUpdateListener listener=new ValueAnimatorTests::MyUpdateListener()  ;
a->AddUpdateListener(listener);
long [] startTime= newlong[1] ;
ASSERT_FALSE(a->IsRunning()  );
ASSERT_FALSE(a->IsRunning()  );
a->Play();
startTime[0]=SystemClock->uptimeMillis()  ;
ASSERT_TRUE(a->IsRunning()  );
ASSERT_FALSE(a->IsRunning()  );
ASSERT_FALSE(a->IsRunning()  );
ASSERT_FALSE(a->IsRunning()  );
a->Play();
startTime[0]=SystemClock->uptimeMillis()  ;
ASSERT_TRUE(a->IsRunning()  );
ASSERT_FALSE(a->IsRunning()  );
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_FALSE(a->IsRunning()  );ASSERT_FALSE(a->IsRunning()  );a->Play();startTime[0]=SystemClock->uptimeMillis()  ;ASSERT_TRUE(a->IsRunning()  );ASSERT_FALSE(a->IsRunning()  ); }}  );
Thread->sleep(a->getTotalDuration()  );
ASSERT_TRUE(listener->wasRunning);
ASSERT_TRUE(listener->firstRunningFrameTime - startTime[0]   >= delay);
ASSERT_TRUE(listener->wasRunning);
ASSERT_TRUE(listener->firstRunningFrameTime - startTime[0]   >= delay);
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_TRUE(listener->wasRunning);ASSERT_TRUE(listener->firstRunningFrameTime - startTime[0]   >= delay); }}  );
Thread->sleep(a->getTotalDuration()  );
ASSERT_FALSE(a->IsRunning()  );
ASSERT_FALSE(a->IsRunning()  );
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_FALSE(a->IsRunning()  ); }}  );
ValueAnimatorTests::MyListener l1=new ValueAnimatorTests::MyListener()  ;
ValueAnimatorTests::MyListener l2=new ValueAnimatorTests::MyListener()  ;
a1->addListener(l1);
a2->addListener(l2);
a2->setStartDelay(400  );
ASSERT_FALSE(l1->startCalled);
ASSERT_FALSE(l1->cancelCalled);
ASSERT_FALSE(l1->endCalled);
ASSERT_FALSE(l2->startCalled);
ASSERT_FALSE(l2->cancelCalled);
ASSERT_FALSE(l2->endCalled);
a1->Play();
a2->Play();
a1->Play();
a2->Play();
mActivityRule->runOnUiThread(new Runnable(){void run() { a1->Play();a2->Play(); }}  );
long wait=0  ;
Thread->sleep(POLL_INTERVAL);
wait+=POLL_INTERVAL;
ASSERT_FALSE(l1->cancelCalled);
a1->cancel();
ASSERT_TRUE(l1->cancelCalled);
ASSERT_TRUE(l1->endCalled);
ASSERT_FALSE(l1->cancelCalled);
a1->cancel();
ASSERT_TRUE(l1->cancelCalled);
ASSERT_TRUE(l1->endCalled);
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_FALSE(l1->cancelCalled);a1->cancel();ASSERT_TRUE(l1->cancelCalled);ASSERT_TRUE(l1->endCalled); }}  );
ASSERT_TRUE(l1->startCalled);
ASSERT_FALSE(l2->startCalled);
ASSERT_TRUE(l1->startCalled);
ASSERT_FALSE(l2->startCalled);
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_TRUE(l1->startCalled);ASSERT_FALSE(l2->startCalled); }}  );
Thread->sleep(POLL_INTERVAL);
wait+=POLL_INTERVAL;
while(wait < a2->getStartDelay()  ){ mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_TRUE(l1->startCalled);ASSERT_FALSE(l2->startCalled); }}  );Thread->sleep(POLL_INTERVAL);wait+=POLL_INTERVAL; }
long delay=Math->max(a1->getTotalDuration()  ,a2->getTotalDuration()  )   + TOLERANCE;
Thread->sleep(delay);
ASSERT_TRUE(l1->startCalled);
ASSERT_TRUE(l1->cancelCalled);
ASSERT_TRUE(l1->endCalled);
ASSERT_TRUE(l2->startCalled);
ASSERT_FALSE(l2->cancelCalled);
ASSERT_TRUE(l2->endCalled);
ASSERT_TRUE(l1->startCalled);
ASSERT_TRUE(l1->cancelCalled);
ASSERT_TRUE(l1->endCalled);
ASSERT_TRUE(l2->startCalled);
ASSERT_FALSE(l2->cancelCalled);
ASSERT_TRUE(l2->endCalled);
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_TRUE(l1->startCalled);ASSERT_TRUE(l1->cancelCalled);ASSERT_TRUE(l1->endCalled);ASSERT_TRUE(l2->startCalled);ASSERT_FALSE(l2->cancelCalled);ASSERT_TRUE(l2->endCalled); }}  );
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a2->IsRunning()  );
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a2->IsRunning()  );
long startDelay=150  ;
a1->setStartDelay(startDelay);
long [] startTime= newlong[1] ;
a1->Play();
a2->Play();
startTime[0]=SystemClock->uptimeMillis()  ;
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a2->IsRunning()  );
a1->Play();
a2->Play();
startTime[0]=SystemClock->uptimeMillis()  ;
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a2->IsRunning()  );
mActivityRule->runOnUiThread(new Runnable(){void run() { a1->Play();a2->Play();startTime[0]=SystemClock->uptimeMillis()  ;ASSERT_TRUE(a1->IsRunning()  );ASSERT_TRUE(a2->IsRunning()  ); }}  );
long delayMs=0  ;
Thread->sleep(POLL_INTERVAL);
delayMs+=POLL_INTERVAL;
ASSERT_FALSE(a1->IsRunning()  );
if(SystemClock->uptimeMillis()   - startTime[0]   < startDelay){ ASSERT_FALSE(a1->IsRunning()  ); }
ASSERT_FALSE(a1->IsRunning()  );
if(SystemClock->uptimeMillis()   - startTime[0]   < startDelay){ ASSERT_FALSE(a1->IsRunning()  ); }
mActivityRule->runOnUiThread(new Runnable(){void run() { if(SystemClock->uptimeMillis()   - startTime[0]   < startDelay){ ASSERT_FALSE(a1->IsRunning()  ); } }}  );
while(delayMs < startDelay){ Thread->sleep(POLL_INTERVAL);delayMs+=POLL_INTERVAL;mActivityRule->runOnUiThread(new Runnable(){void run() { if(SystemClock->uptimeMillis()   - startTime[0]   < startDelay){ ASSERT_FALSE(a1->IsRunning()  ); } }}  ); }
Thread->sleep(startDelay);
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a2->IsRunning()  );
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a2->IsRunning()  );
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_TRUE(a1->IsRunning()  );ASSERT_TRUE(a2->IsRunning()  ); }}  );
long delay=Math->max(a1->getTotalDuration()  ,a2->getTotalDuration()  )   * 2  ;
Thread->sleep(delay);
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a2->IsRunning()  );
ASSERT_FALSE(a2->IsRunning()  );
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a2->IsRunning()  );
ASSERT_FALSE(a2->IsRunning()  );
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_FALSE(a1->IsRunning()  );ASSERT_FALSE(a1->IsRunning()  );ASSERT_FALSE(a2->IsRunning()  );ASSERT_FALSE(a2->IsRunning()  ); }}  );
ASSERT_FALSE(a1->IsPending()  );
ASSERT_FALSE(a2->IsPending()  );
a1->Play();
a2->Play();
ASSERT_FALSE(a1->IsPending()  );
ASSERT_FALSE(a2->IsPending()  );
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a2->IsRunning()  );
ASSERT_FALSE(a1->IsPending()  );
ASSERT_FALSE(a2->IsPending()  );
a1->Play();
a2->Play();
ASSERT_FALSE(a1->IsPending()  );
ASSERT_FALSE(a2->IsPending()  );
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a2->IsRunning()  );
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_FALSE(a1->IsPending()  );ASSERT_FALSE(a2->IsPending()  );a1->Play();a2->Play();ASSERT_FALSE(a1->IsPending()  );ASSERT_FALSE(a2->IsPending()  );ASSERT_TRUE(a1->IsRunning()  );ASSERT_TRUE(a2->IsRunning()  ); }}  );
Thread->sleep(POLL_INTERVAL);
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a2->IsRunning()  );
a1->Pause();
ASSERT_TRUE(a1->IsPending()  );
ASSERT_FALSE(a2->IsPending()  );
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a2->IsRunning()  );
a1->Pause();
ASSERT_TRUE(a1->IsPending()  );
ASSERT_FALSE(a2->IsPending()  );
ASSERT_TRUE(a1->IsRunning()  );
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_TRUE(a1->IsRunning()  );ASSERT_TRUE(a2->IsRunning()  );a1->Pause();ASSERT_TRUE(a1->IsPending()  );ASSERT_FALSE(a2->IsPending()  );ASSERT_TRUE(a1->IsRunning()  ); }}  );
Thread->sleep(a2->getTotalDuration()  );
ASSERT_FALSE(a2->IsRunning()  );
ASSERT_FALSE(a2->IsRunning()  );
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a1->IsPending()  );
a1->resume();
ASSERT_FALSE(a2->IsRunning()  );
ASSERT_FALSE(a2->IsRunning()  );
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a1->IsPending()  );
a1->resume();
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_FALSE(a2->IsRunning()  );ASSERT_FALSE(a2->IsRunning()  );ASSERT_TRUE(a1->IsRunning()  );ASSERT_TRUE(a1->IsRunning()  );ASSERT_TRUE(a1->IsPending()  );a1->resume(); }}  );
Thread->sleep(POLL_INTERVAL);
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_FALSE(a1->IsPending()  );
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_FALSE(a1->IsPending()  );
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_TRUE(a1->IsRunning()  );ASSERT_TRUE(a1->IsRunning()  );ASSERT_FALSE(a1->IsPending()  ); }}  );
Thread->sleep(a1->getTotalDuration()  );
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a1->IsPending()  );
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a1->IsPending()  );
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_FALSE(a1->IsRunning()  );ASSERT_FALSE(a1->IsRunning()  );ASSERT_FALSE(a1->IsPending()  ); }}  );
ValueAnimatorTests::MyPauseListener l1=new ValueAnimatorTests::MyPauseListener()  ;
ValueAnimatorTests::MyPauseListener l2=new ValueAnimatorTests::MyPauseListener()  ;
a1->addPauseListener(l1);
a2->addPauseListener(l2);
ASSERT_FALSE(l1->pauseCalled);
ASSERT_FALSE(l1->resumeCalled);
ASSERT_FALSE(l2->pauseCalled);
ASSERT_FALSE(l2->resumeCalled);
a1->Play();
a2->Play();
a1->Play();
a2->Play();
mActivityRule->runOnUiThread(new Runnable(){void run() { a1->Play();a2->Play(); }}  );
Thread->sleep(a1->getTotalDuration()   / 2  );
a1->Pause();
Thread->sleep(a2->getTotalDuration()  );
ASSERT_TRUE(l1->pauseCalled);
ASSERT_FALSE(l1->resumeCalled);
a1->resume();
a1->resume();
mActivityRule->runOnUiThread(new Runnable(){void run() { a1->resume(); }}  );
Thread->sleep(a1->getTotalDuration()  );
ASSERT_TRUE(l1->pauseCalled);
ASSERT_TRUE(l1->resumeCalled);
ASSERT_FALSE(l2->pauseCalled);
ASSERT_FALSE(l2->resumeCalled);
ValueAnimatorTests::MyUpdateListener l1=new ValueAnimatorTests::MyUpdateListener()  ;
long totalDuration=a1->getTotalDuration()  ;
a1->AddUpdateListener(l1);
a1->setDuration(1000  );
ASSERT_TRUE(l1->firstRunningFrameTime < 0  );
ASSERT_TRUE(l1->lastUpdateTime < 0  );
long [] lastUpdate= newlong[1] ;
a1->Play();
a1->Play();
mActivityRule->runOnUiThread(new Runnable(){void run() { a1->Play(); }}  );
Thread->sleep(totalDuration / 2  );
ASSERT_TRUE(l1->firstRunningFrameTime > 0  );
ASSERT_TRUE(l1->lastUpdateTime > l1->firstRunningFrameTime);
lastUpdate[0]=l1->lastUpdateTime;
a1->Pause();
ASSERT_TRUE(l1->firstRunningFrameTime > 0  );
ASSERT_TRUE(l1->lastUpdateTime > l1->firstRunningFrameTime);
lastUpdate[0]=l1->lastUpdateTime;
a1->Pause();
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_TRUE(l1->firstRunningFrameTime > 0  );ASSERT_TRUE(l1->lastUpdateTime > l1->firstRunningFrameTime);lastUpdate[0]=l1->lastUpdateTime;a1->Pause(); }}  );
Thread->sleep(totalDuration);
ASSERT_EQ(lastUpdate[0]  ,l1->lastUpdateTime);
a1->resume();
ASSERT_EQ(lastUpdate[0]  ,l1->lastUpdateTime);
a1->resume();
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_EQ(lastUpdate[0]  ,l1->lastUpdateTime);a1->resume(); }}  );
Thread->sleep(POLL_INTERVAL);
ASSERT_TRUE(l1->lastUpdateTime > lastUpdate[0]  );
lastUpdate[0]=l1->lastUpdateTime;
ASSERT_TRUE(l1->lastUpdateTime > lastUpdate[0]  );
lastUpdate[0]=l1->lastUpdateTime;
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_TRUE(l1->lastUpdateTime > lastUpdate[0]  );lastUpdate[0]=l1->lastUpdateTime; }}  );
do{ Thread->sleep(POLL_INTERVAL);mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_TRUE(l1->lastUpdateTime > lastUpdate[0]  );lastUpdate[0]=l1->lastUpdateTime; }}  ); }while(!a1->IsRunning()  );
long entireSpan=totalDuration * 2  ;
long frameDelta=l1->lastUpdateTime - l1->firstRunningFrameTime;
ASSERT_TRUE(Math->abs(entireSpan - frameDelta)   < TOLERANCE);
ValueAnimatorTests::MyListener l1=new ValueAnimatorTests::MyListener()  ;
ValueAnimatorTests::MyListener l2=new ValueAnimatorTests::MyListener()  ;
a1->addListener(l1);
a2->addListener(l2);
anim->Cancel();
anim->Cancel();
a1->addListener(new ValueAnimatorTests::MyListener(){void onAnimationEnd(ACE_EXPORTAnimator *  anim) { anim->Cancel(); }}  );
anim->end();
anim->end();
a2->addListener(new ValueAnimatorTests::MyListener(){void onAnimationCancel(ACE_EXPORTAnimator *  anim) { anim->end(); }}  );
ASSERT_FALSE(l1->cancelCalled);
ASSERT_FALSE(l1->endCalled);
ASSERT_FALSE(l2->cancelCalled);
ASSERT_FALSE(l2->endCalled);
a1->Play();
a2->Play();
ASSERT_FALSE(l1->cancelCalled);
ASSERT_FALSE(l1->endCalled);
ASSERT_FALSE(l2->cancelCalled);
ASSERT_FALSE(l2->endCalled);
a1->Play();
a2->Play();
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_FALSE(l1->cancelCalled);ASSERT_FALSE(l1->endCalled);ASSERT_FALSE(l2->cancelCalled);ASSERT_FALSE(l2->endCalled);a1->Play();a2->Play(); }}  );
Thread->sleep(POLL_INTERVAL);
a1->Stop();
a2->cancel();
a1->Stop();
a2->cancel();
mActivityRule->runOnUiThread(new Runnable(){void run() { a1->Stop();a2->cancel(); }}  );
Thread->sleep(POLL_INTERVAL);
ASSERT_FALSE(l1->cancelCalled);
ASSERT_TRUE(l1->endCalled);
ASSERT_TRUE(l2->cancelCalled);
ASSERT_TRUE(l2->endCalled);
float value1=(Float)a1.getAnimatedValue();
int value2=(Integer)a2.getAnimatedValue();
ASSERT_EQ(A1_END_VALUE,value1);
ASSERT_EQ(A2_END_VALUE,value2);
ASSERT_FALSE(l1->cancelCalled);
ASSERT_TRUE(l1->endCalled);
ASSERT_TRUE(l2->cancelCalled);
ASSERT_TRUE(l2->endCalled);
float value1=(Float)a1.getAnimatedValue();
int value2=(Integer)a2.getAnimatedValue();
ASSERT_EQ(A1_END_VALUE,value1);
ASSERT_EQ(A2_END_VALUE,value2);
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_FALSE(l1->cancelCalled);ASSERT_TRUE(l1->endCalled);ASSERT_TRUE(l2->cancelCalled);ASSERT_TRUE(l2->endCalled);float value1=(Float)a1.getAnimatedValue();int value2=(Integer)a2.getAnimatedValue();ASSERT_EQ(A1_END_VALUE,value1);ASSERT_EQ(A2_END_VALUE,value2); }}  );
ValueAnimatorTests::MyListener l1=new ValueAnimatorTests::MyListener()  ;
a1->addListener(l1);
ValueAnimatorTests::MyListener l2=new ValueAnimatorTests::MyListener()  ;
a2->addListener(l2);
a1->Play();
a2->Play();
a1->Play();
a2->Play();
mActivityRule->runOnUiThread(new Runnable(){void run() { a1->Play();a2->Play(); }}  );
Thread->sleep(POLL_INTERVAL);
ASSERT_FALSE(l1->endCalled);
ASSERT_FALSE(l2->endCalled);
assertNotEqual(A1_END_VALUE,a1->getAnimatedValue()  );
assertNotEqual(A1_END_VALUE,a2->getAnimatedValue()  );
a2->Stop();
ASSERT_FALSE(l1->endCalled);
ASSERT_FALSE(l2->endCalled);
assertNotEqual(A1_END_VALUE,a1->getAnimatedValue()  );
assertNotEqual(A1_END_VALUE,a2->getAnimatedValue()  );
a2->Stop();
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_FALSE(l1->endCalled);ASSERT_FALSE(l2->endCalled);assertNotEqual(A1_END_VALUE,a1->getAnimatedValue()  );assertNotEqual(A1_END_VALUE,a2->getAnimatedValue()  );a2->Stop(); }}  );
Thread->sleep(a1->getTotalDuration()  );
ASSERT_FALSE(l1->cancelCalled);
ASSERT_TRUE(l1->endCalled);
ASSERT_FALSE(l2->cancelCalled);
ASSERT_TRUE(l2->endCalled);
ASSERT_EQ(A1_END_VALUE,((Float)(a1.getAnimatedValue()))  -> floatValue());
ASSERT_EQ(A2_END_VALUE,((Integer)(a2.getAnimatedValue()))  -> intValue());
ASSERT_FALSE(l1->cancelCalled);
ASSERT_TRUE(l1->endCalled);
ASSERT_FALSE(l2->cancelCalled);
ASSERT_TRUE(l2->endCalled);
ASSERT_EQ(A1_END_VALUE,((Float)(a1.getAnimatedValue()))  -> floatValue());
ASSERT_EQ(A2_END_VALUE,((Integer)(a2.getAnimatedValue()))  -> intValue());
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_FALSE(l1->cancelCalled);ASSERT_TRUE(l1->endCalled);ASSERT_FALSE(l2->cancelCalled);ASSERT_TRUE(l2->endCalled);ASSERT_EQ(A1_END_VALUE,((Float)(a1.getAnimatedValue()))  -> floatValue());ASSERT_EQ(A2_END_VALUE,((Integer)(a2.getAnimatedValue()))  -> intValue()); }}  );
ValueAnimatorTests::MyFrameCallbackProvider provider=new ValueAnimatorTests::MyFrameCallbackProvider()  ;
long sleep=0  ;
Thread->sleep(POLL_INTERVAL);
sleep+=POLL_INTERVAL;
break;
if(sleep > WAIT_TIME_OUT){ break; }
while(provider->mHandler == null  ){ Thread->sleep(POLL_INTERVAL);sleep+=POLL_INTERVAL;if(sleep > WAIT_TIME_OUT){ break; } }
assertNotNull(provider->mHandler);
ValueAnimatorTests::MyListener listener=new ValueAnimatorTests::MyListener()  ;
long currentTime=SystemClock->uptimeMillis()  ;
long frameDelay=provider->getFrameDelay()  ;
ASSERT_TRUE((currentTime-lastUpdateTime)   < frameDelay * 4  );
ASSERT_TRUE(listener->startCalled);
ASSERT_TRUE(listener->startTime > 0  );
ASSERT_TRUE(currentTime - listener->startTime < frameDelay * 4  );
if(lastUpdateTime > 0  ){ ASSERT_TRUE((currentTime-lastUpdateTime)   < frameDelay * 4  ); }else{ ASSERT_TRUE(listener->startCalled);ASSERT_TRUE(listener->startTime > 0  );ASSERT_TRUE(currentTime - listener->startTime < frameDelay * 4  ); }
super-> onAnimationUpdate(animation);
ValueAnimatorTests::MyUpdateListener l1=new ValueAnimatorTests::MyUpdateListener(){void onAnimationUpdate(ACE_EXPORTAnimator *  animation) { long currentTime=SystemClock->uptimeMillis()  ;long frameDelay=provider->getFrameDelay()  ;if(lastUpdateTime > 0  ){ ASSERT_TRUE((currentTime-lastUpdateTime)   < frameDelay * 4  ); }else{ ASSERT_TRUE(listener->startCalled);ASSERT_TRUE(listener->startTime > 0  );ASSERT_TRUE(currentTime - listener->startTime < frameDelay * 4  ); }super-> onAnimationUpdate(animation); }}  ;
a1->AddUpdateListener(l1);
a1->addListener(listener);
a1->setStartDelay(100  );
AnimationHandler->getInstance()  -> setProvider(provider);
a1->Play();
AnimationHandler->getInstance()  -> setProvider(provider);
a1->Play();
provider.mHandler->post(new Runnable(){void run() { AnimationHandler->getInstance()  -> setProvider(provider);a1->Play(); }}  );
Thread->sleep(POLL_INTERVAL);
ASSERT_TRUE(a1->IsRunning()  );
Thread->sleep(a1->getTotalDuration()   + TOLERANCE);
throwprovider->mAssertionError;
if(provider->mAssertionError != null  ){ throwprovider->mAssertionError; }
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_TRUE(listener->endTime > 0  );
ASSERT_TRUE(listener->endTime >= l1->lastUpdateTime);
ASSERT_TRUE(listener->endTime - l1->lastUpdateTime < 2   * provider->getFrameDelay()  );
ACE_EXPORTAnimator *  a0=ValueAnimator->ofInt(100  ,200  )  -> setDuration(500  );
ACE_EXPORTAnimator *  a3=ValueAnimator->ofFloat(0  ,1  )  -> setDuration(500  );
ACE_EXPORTAnimator *  a4=ValueAnimator->ofInt(200  ,300  )  -> setDuration(500  );
super-> onAnimationEnd(anim);
a0->cancel();
a1->Stop();
a3->Stop();
a4->cancel();
ValueAnimatorTests::MyListener listener=new ValueAnimatorTests::MyListener(){void onAnimationEnd(ACE_EXPORTAnimator *  anim) { super-> onAnimationEnd(anim);a0->cancel();a1->Stop();a3->Stop();a4->cancel(); }}  ;
a2->addListener(listener);
a0->Play();
a1->Play();
a2->Play();
a3->Play();
a4->Play();
a0->Play();
a1->Play();
a2->Play();
a3->Play();
a4->Play();
mActivityRule->runOnUiThread(new Runnable(){void run() { a0->Play();a1->Play();a2->Play();a3->Play();a4->Play(); }}  );
ASSERT_TRUE(a0->IsRunning()  );
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a2->IsRunning()  );
ASSERT_TRUE(a3->IsRunning()  );
ASSERT_TRUE(a4->IsRunning()  );
ASSERT_TRUE(a0->IsRunning()  );
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a2->IsRunning()  );
ASSERT_TRUE(a3->IsRunning()  );
ASSERT_TRUE(a4->IsRunning()  );
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_TRUE(a0->IsRunning()  );ASSERT_TRUE(a1->IsRunning()  );ASSERT_TRUE(a2->IsRunning()  );ASSERT_TRUE(a3->IsRunning()  );ASSERT_TRUE(a4->IsRunning()  ); }}  );
Thread->sleep(POLL_INTERVAL);
a2->Stop();
a2->Stop();
mActivityRule->runOnUiThread(new Runnable(){void run() { a2->Stop(); }}  );
Thread->sleep(POLL_INTERVAL);
ASSERT_TRUE(listener->endCalled);
ASSERT_FALSE(a0->IsRunning()  );
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a2->IsRunning()  );
ASSERT_FALSE(a3->IsRunning()  );
ASSERT_FALSE(a4->IsRunning()  );
ValueAnimatorTests::MyListener l1=new ValueAnimatorTests::MyListener()  ;
ValueAnimatorTests::MyListener l2=new ValueAnimatorTests::MyListener()  ;
ValueAnimatorTests::MyUpdateListener updateListener1=new ValueAnimatorTests::MyUpdateListener()  ;
ValueAnimatorTests::MyUpdateListener updateListener2=new ValueAnimatorTests::MyUpdateListener()  ;
float a1StartFraction=0.2f  ;
float a2StartFraction=0.3f  ;
a1->setDuration(1000  );
a2->setDuration(1000  );
a1->addListener(l1);
a2->addListener(l2);
a1->AddUpdateListener(updateListener1);
a2->AddUpdateListener(updateListener2);
//以下组件没有匹配:
//TimeInterpolator,LinearInterpolator
TimeInterpolator *  interpolator=new LinearInterpolator()  ;
a1->setInterpolator(interpolator);
a2->setInterpolator(interpolator);
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a2->IsRunning()  );
ASSERT_FALSE(a2->IsRunning()  );
a1->setCurrentFraction(a1StartFraction);
a2->setCurrentFraction(a2StartFraction);
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a2->IsRunning()  );
ASSERT_FALSE(a2->IsRunning()  );
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a2->IsRunning()  );
ASSERT_FALSE(a2->IsRunning()  );
a1->setCurrentFraction(a1StartFraction);
a2->setCurrentFraction(a2StartFraction);
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a2->IsRunning()  );
ASSERT_FALSE(a2->IsRunning()  );
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_FALSE(a1->IsRunning()  );ASSERT_FALSE(a1->IsRunning()  );ASSERT_FALSE(a2->IsRunning()  );ASSERT_FALSE(a2->IsRunning()  );a1->setCurrentFraction(a1StartFraction);a2->setCurrentFraction(a2StartFraction);ASSERT_FALSE(a1->IsRunning()  );ASSERT_FALSE(a1->IsRunning()  );ASSERT_FALSE(a2->IsRunning()  );ASSERT_FALSE(a2->IsRunning()  ); }}  );
Thread->sleep(POLL_INTERVAL);
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a2->IsRunning()  );
ASSERT_FALSE(a2->IsRunning()  );
ASSERT_EQ(a1StartFraction,a1->getAnimatedFraction()  );
ASSERT_EQ(a2StartFraction,a2->getAnimatedFraction()  );
a1->Play();
a2->Play();
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a2->IsRunning()  );
ASSERT_FALSE(a2->IsRunning()  );
ASSERT_EQ(a1StartFraction,a1->getAnimatedFraction()  );
ASSERT_EQ(a2StartFraction,a2->getAnimatedFraction()  );
a1->Play();
a2->Play();
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_FALSE(a1->IsRunning()  );ASSERT_FALSE(a1->IsRunning()  );ASSERT_FALSE(a2->IsRunning()  );ASSERT_FALSE(a2->IsRunning()  );ASSERT_EQ(a1StartFraction,a1->getAnimatedFraction()  );ASSERT_EQ(a2StartFraction,a2->getAnimatedFraction()  );a1->Play();a2->Play(); }}  );
Thread->sleep(POLL_INTERVAL);
float halfwayFraction=0.5f  ;
ASSERT_TRUE(l1->startCalled);
ASSERT_TRUE(l2->startCalled);
ASSERT_FALSE(l1->endCalled);
ASSERT_FALSE(l2->endCalled);
ASSERT_TRUE(updateListener1->startFraction >= a1StartFraction);
ASSERT_TRUE(updateListener2->startFraction >= a2StartFraction);
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a2->IsRunning()  );
ASSERT_TRUE(a2->IsRunning()  );
a1->setCurrentFraction(halfwayFraction);
a2->setCurrentFraction(halfwayFraction);
ASSERT_TRUE(l1->startCalled);
ASSERT_TRUE(l2->startCalled);
ASSERT_FALSE(l1->endCalled);
ASSERT_FALSE(l2->endCalled);
ASSERT_TRUE(updateListener1->startFraction >= a1StartFraction);
ASSERT_TRUE(updateListener2->startFraction >= a2StartFraction);
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a2->IsRunning()  );
ASSERT_TRUE(a2->IsRunning()  );
a1->setCurrentFraction(halfwayFraction);
a2->setCurrentFraction(halfwayFraction);
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_TRUE(l1->startCalled);ASSERT_TRUE(l2->startCalled);ASSERT_FALSE(l1->endCalled);ASSERT_FALSE(l2->endCalled);ASSERT_TRUE(updateListener1->startFraction >= a1StartFraction);ASSERT_TRUE(updateListener2->startFraction >= a2StartFraction);ASSERT_TRUE(a1->IsRunning()  );ASSERT_TRUE(a1->IsRunning()  );ASSERT_TRUE(a2->IsRunning()  );ASSERT_TRUE(a2->IsRunning()  );a1->setCurrentFraction(halfwayFraction);a2->setCurrentFraction(halfwayFraction); }}  );
Thread->sleep(POLL_INTERVAL);
ASSERT_TRUE(l1->startCalled);
ASSERT_TRUE(l2->startCalled);
ASSERT_FALSE(l1->endCalled);
ASSERT_FALSE(l2->endCalled);
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a2->IsRunning()  );
ASSERT_TRUE(a2->IsRunning()  );
ASSERT_TRUE(l1->startCalled);
ASSERT_TRUE(l2->startCalled);
ASSERT_FALSE(l1->endCalled);
ASSERT_FALSE(l2->endCalled);
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a2->IsRunning()  );
ASSERT_TRUE(a2->IsRunning()  );
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_TRUE(l1->startCalled);ASSERT_TRUE(l2->startCalled);ASSERT_FALSE(l1->endCalled);ASSERT_FALSE(l2->endCalled);ASSERT_TRUE(a1->IsRunning()  );ASSERT_TRUE(a1->IsRunning()  );ASSERT_TRUE(a2->IsRunning()  );ASSERT_TRUE(a2->IsRunning()  ); }}  );
long wait=Math->max(a1->getTotalDuration()  ,a2->getTotalDuration()  )  ;
Thread->sleep(wait);
ASSERT_TRUE(l1->endCalled);
ASSERT_TRUE(l2->endCalled);
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a2->IsRunning()  );
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a2->IsRunning()  );
ASSERT_TRUE(l1->endCalled);
ASSERT_TRUE(l2->endCalled);
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a2->IsRunning()  );
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a2->IsRunning()  );
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_TRUE(l1->endCalled);ASSERT_TRUE(l2->endCalled);ASSERT_FALSE(a1->IsRunning()  );ASSERT_FALSE(a2->IsRunning()  );ASSERT_FALSE(a1->IsRunning()  );ASSERT_FALSE(a2->IsRunning()  ); }}  );
updateListener1->reset();
a1->Play();
a1->Play();
mActivityRule->runOnUiThread(new Runnable(){void run() { a1->Play(); }}  );
Thread->sleep(POLL_INTERVAL);
ASSERT_TRUE(updateListener1->wasRunning);
ASSERT_TRUE(updateListener1->startFraction >= 0  );
ASSERT_TRUE(updateListener1->startFraction < halfwayFraction);
a1->Stop();
ASSERT_TRUE(updateListener1->wasRunning);
ASSERT_TRUE(updateListener1->startFraction >= 0  );
ASSERT_TRUE(updateListener1->startFraction < halfwayFraction);
a1->Stop();
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_TRUE(updateListener1->wasRunning);ASSERT_TRUE(updateListener1->startFraction >= 0  );ASSERT_TRUE(updateListener1->startFraction < halfwayFraction);a1->Stop(); }}  );
ValueAnimatorTests::MyListener l1=new ValueAnimatorTests::MyListener()  ;
ValueAnimatorTests::MyListener l2=new ValueAnimatorTests::MyListener()  ;
a1->addListener(l1);
a2->addListener(l2);
ASSERT_FALSE(l1->startCalled);
ASSERT_FALSE(l2->startCalled);
ASSERT_EQ(0f  ,a1->getAnimatedFraction()  );
ASSERT_EQ(0f  ,a2->getAnimatedFraction()  );
a1->Play();
a2->Play();
ASSERT_FALSE(l1->startCalled);
ASSERT_FALSE(l2->startCalled);
ASSERT_EQ(0f  ,a1->getAnimatedFraction()  );
ASSERT_EQ(0f  ,a2->getAnimatedFraction()  );
a1->Play();
a2->Play();
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_FALSE(l1->startCalled);ASSERT_FALSE(l2->startCalled);ASSERT_EQ(0f  ,a1->getAnimatedFraction()  );ASSERT_EQ(0f  ,a2->getAnimatedFraction()  );a1->Play();a2->Play(); }}  );
Thread->sleep(POLL_INTERVAL);
ASSERT_FALSE(l1->endCalled);
ASSERT_FALSE(l2->endCalled);
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a2->IsRunning()  );
a1->setCurrentFraction(0f  );
a2->setCurrentFraction(1f  );
ASSERT_FALSE(l1->endCalled);
ASSERT_FALSE(l2->endCalled);
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a2->IsRunning()  );
a1->setCurrentFraction(0f  );
a2->setCurrentFraction(1f  );
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_FALSE(l1->endCalled);ASSERT_FALSE(l2->endCalled);ASSERT_TRUE(a1->IsRunning()  );ASSERT_TRUE(a2->IsRunning()  );a1->setCurrentFraction(0f  );a2->setCurrentFraction(1f  ); }}  );
Thread->sleep(POLL_INTERVAL);
ASSERT_FALSE(l1->endCalled);
ASSERT_TRUE(l2->endCalled);
ASSERT_EQ(1f  ,a2->getAnimatedFraction()  );
ASSERT_FALSE(l1->endCalled);
ASSERT_TRUE(l2->endCalled);
ASSERT_EQ(1f  ,a2->getAnimatedFraction()  );
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_FALSE(l1->endCalled);ASSERT_TRUE(l2->endCalled);ASSERT_EQ(1f  ,a2->getAnimatedFraction()  ); }}  );
Thread->sleep(a1->getTotalDuration()  );
ASSERT_TRUE(l1->endCalled);
ASSERT_EQ(1f  ,a1->getAnimatedFraction()  );
ASSERT_TRUE(l1->endCalled);
ASSERT_EQ(1f  ,a1->getAnimatedFraction()  );
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_TRUE(l1->endCalled);ASSERT_EQ(1f  ,a1->getAnimatedFraction()  ); }}  );
a1->setStartDelay(20  );
ValueAnimatorTests::MyListener normalEndingListener=new ValueAnimatorTests::MyListener()  ;
a1->addListener(normalEndingListener);
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(normalEndingListener->startCalled);
ASSERT_FALSE(normalEndingListener->endCalled);
a1->Play();
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(normalEndingListener->startCalled);
ASSERT_FALSE(normalEndingListener->endCalled);
a1->Play();
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_FALSE(a1->IsRunning()  );ASSERT_FALSE(normalEndingListener->startCalled);ASSERT_FALSE(normalEndingListener->endCalled);a1->Play(); }}  );
Thread->sleep(a1->getTotalDuration()   + POLL_INTERVAL);
ValueAnimatorTests::MyListener l1=new ValueAnimatorTests::MyListener()  ;
a1->addListener(l1);
ValueAnimatorTests::MyListener l2=new ValueAnimatorTests::MyListener()  ;
a2->addListener(l2);
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(l1->startCalled);
ASSERT_FALSE(l1->endCalled);
ASSERT_FALSE(a2->IsRunning()  );
ASSERT_FALSE(l2->startCalled);
ASSERT_FALSE(l1->endCalled);
a1->Stop();
a2->Stop();
ASSERT_TRUE(l1->startCalled);
ASSERT_TRUE(l1->endCalled);
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_TRUE(l1->endTime >= l1->startTime);
ASSERT_TRUE(l2->startCalled);
ASSERT_TRUE(l2->endCalled);
ASSERT_FALSE(a2->IsRunning()  );
ASSERT_TRUE(l2->endTime >= l1->startTime);
ValueAnimatorTests::MyListener l1=new ValueAnimatorTests::MyListener()  ;
a1->addListener(l1);
ValueAnimatorTests::MyListener l2=new ValueAnimatorTests::MyListener()  ;
a2->addListener(l2);
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(l1->startCalled);
ASSERT_FALSE(l1->endCalled);
ASSERT_FALSE(a2->IsRunning()  );
ASSERT_FALSE(l2->startCalled);
ASSERT_FALSE(l1->endCalled);
a1->Stop();
a2->Stop();
ASSERT_TRUE(l1->startCalled);
ASSERT_TRUE(l1->endCalled);
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_TRUE(l1->endTime >= l1->startTime);
ASSERT_TRUE(l2->startCalled);
ASSERT_TRUE(l2->endCalled);
ASSERT_FALSE(a2->IsRunning()  );
ASSERT_TRUE(l2->endTime >= l1->startTime);
mActivityRule->runOnUiThread(new Runnable(){void run() { ValueAnimatorTests::MyListener l1=new ValueAnimatorTests::MyListener()  ;a1->addListener(l1);ValueAnimatorTests::MyListener l2=new ValueAnimatorTests::MyListener()  ;a2->addListener(l2);ASSERT_FALSE(a1->IsRunning()  );ASSERT_FALSE(l1->startCalled);ASSERT_FALSE(l1->endCalled);ASSERT_FALSE(a2->IsRunning()  );ASSERT_FALSE(l2->startCalled);ASSERT_FALSE(l1->endCalled);a1->Stop();a2->Stop();ASSERT_TRUE(l1->startCalled);ASSERT_TRUE(l1->endCalled);ASSERT_FALSE(a1->IsRunning()  );ASSERT_TRUE(l1->endTime >= l1->startTime);ASSERT_TRUE(l2->startCalled);ASSERT_TRUE(l2->endCalled);ASSERT_FALSE(a2->IsRunning()  );ASSERT_TRUE(l2->endTime >= l1->startTime); }}  );
a1->setDuration(0  );
a2->setDuration(0  );
ACE_EXPORTAnimator *  a3=ValueAnimator->ofInt(0  ,100  )  ;
a3->setDuration(0  );
a3->setCurrentFraction(1.0f  );
ASSERT_EQ(1.0f  ,a3->getAnimatedFraction()  );
ValueAnimatorTests::MyListener l1=new ValueAnimatorTests::MyListener()  ;
ValueAnimatorTests::MyListener l2=new ValueAnimatorTests::MyListener()  ;
ValueAnimatorTests::MyListener l3=new ValueAnimatorTests::MyListener()  ;
a1->addListener(l1);
a2->addListener(l2);
a3->addListener(l3);
ASSERT_FALSE(l1->startCalled);
ASSERT_FALSE(l2->startCalled);
ASSERT_FALSE(l3->startCalled);
ASSERT_FALSE(l1->endCalled);
ASSERT_FALSE(l2->endCalled);
ASSERT_FALSE(l3->endCalled);
a1->Play();
a2->reverse();
a3->Play();
ASSERT_EQ(A1_END_VALUE,a1->getAnimatedValue()  );
ASSERT_EQ(A2_START_VALUE,a2->getAnimatedValue()  );
ASSERT_FALSE(l1->startCalled);
ASSERT_FALSE(l2->startCalled);
ASSERT_FALSE(l3->startCalled);
ASSERT_FALSE(l1->endCalled);
ASSERT_FALSE(l2->endCalled);
ASSERT_FALSE(l3->endCalled);
a1->Play();
a2->reverse();
a3->Play();
ASSERT_EQ(A1_END_VALUE,a1->getAnimatedValue()  );
ASSERT_EQ(A2_START_VALUE,a2->getAnimatedValue()  );
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_FALSE(l1->startCalled);ASSERT_FALSE(l2->startCalled);ASSERT_FALSE(l3->startCalled);ASSERT_FALSE(l1->endCalled);ASSERT_FALSE(l2->endCalled);ASSERT_FALSE(l3->endCalled);a1->Play();a2->reverse();a3->Play();ASSERT_EQ(A1_END_VALUE,a1->getAnimatedValue()  );ASSERT_EQ(A2_START_VALUE,a2->getAnimatedValue()  ); }}  );
Thread->sleep(POLL_INTERVAL);
ASSERT_TRUE(l1->startCalled);
ASSERT_TRUE(l2->startCalled);
ASSERT_TRUE(l3->startCalled);
ASSERT_TRUE(l1->endCalled);
ASSERT_TRUE(l2->endCalled);
ASSERT_TRUE(l3->endCalled);
ASSERT_EQ(1.0f  ,a1->getAnimatedFraction()  );
ASSERT_EQ(0f  ,a2->getAnimatedFraction()  );
ASSERT_EQ(1f  ,a3->getAnimatedFraction()  );
ASSERT_EQ(A1_END_VALUE,a1->getAnimatedValue()  );
ASSERT_EQ(A2_START_VALUE,a2->getAnimatedValue()  );
ASSERT_EQ(100  ,a3->getAnimatedValue()  );
ASSERT_TRUE(l1->startCalled);
ASSERT_TRUE(l2->startCalled);
ASSERT_TRUE(l3->startCalled);
ASSERT_TRUE(l1->endCalled);
ASSERT_TRUE(l2->endCalled);
ASSERT_TRUE(l3->endCalled);
ASSERT_EQ(1.0f  ,a1->getAnimatedFraction()  );
ASSERT_EQ(0f  ,a2->getAnimatedFraction()  );
ASSERT_EQ(1f  ,a3->getAnimatedFraction()  );
ASSERT_EQ(A1_END_VALUE,a1->getAnimatedValue()  );
ASSERT_EQ(A2_START_VALUE,a2->getAnimatedValue()  );
ASSERT_EQ(100  ,a3->getAnimatedValue()  );
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_TRUE(l1->startCalled);ASSERT_TRUE(l2->startCalled);ASSERT_TRUE(l3->startCalled);ASSERT_TRUE(l1->endCalled);ASSERT_TRUE(l2->endCalled);ASSERT_TRUE(l3->endCalled);ASSERT_EQ(1.0f  ,a1->getAnimatedFraction()  );ASSERT_EQ(0f  ,a2->getAnimatedFraction()  );ASSERT_EQ(1f  ,a3->getAnimatedFraction()  );ASSERT_EQ(A1_END_VALUE,a1->getAnimatedValue()  );ASSERT_EQ(A2_START_VALUE,a2->getAnimatedValue()  );ASSERT_EQ(100  ,a3->getAnimatedValue()  ); }}  );
float scale=ValueAnimator->getDurationScale()  ;
ValueAnimator->setDurationScale(0f  );
a1->setStartDelay(200  );
ValueAnimatorTests::MyListener l1=new ValueAnimatorTests::MyListener()  ;
ValueAnimatorTests::MyListener l2=new ValueAnimatorTests::MyListener()  ;
a1->addListener(l1);
a2->addListener(l2);
ASSERT_FALSE(l1->startCalled);
ASSERT_FALSE(l2->startCalled);
ASSERT_FALSE(l1->endCalled);
ASSERT_FALSE(l2->endCalled);
a1->Play();
a2->Play();
ASSERT_EQ(A2_START_VALUE,a2->getAnimatedValue()  );
ASSERT_FALSE(l1->startCalled);
ASSERT_FALSE(l2->startCalled);
ASSERT_FALSE(l1->endCalled);
ASSERT_FALSE(l2->endCalled);
a1->Play();
a2->Play();
ASSERT_EQ(A2_START_VALUE,a2->getAnimatedValue()  );
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_FALSE(l1->startCalled);ASSERT_FALSE(l2->startCalled);ASSERT_FALSE(l1->endCalled);ASSERT_FALSE(l2->endCalled);a1->Play();a2->Play();ASSERT_EQ(A2_START_VALUE,a2->getAnimatedValue()  ); }}  );
Thread->sleep(POLL_INTERVAL);
ASSERT_TRUE(l1->startCalled);
ASSERT_TRUE(l2->startCalled);
ASSERT_TRUE(l1->endCalled);
ASSERT_TRUE(l2->endCalled);
ASSERT_EQ(A1_END_VALUE,a1->getAnimatedValue()  );
ASSERT_EQ(A2_END_VALUE,a2->getAnimatedValue()  );
ASSERT_TRUE(l1->startCalled);
ASSERT_TRUE(l2->startCalled);
ASSERT_TRUE(l1->endCalled);
ASSERT_TRUE(l2->endCalled);
ASSERT_EQ(A1_END_VALUE,a1->getAnimatedValue()  );
ASSERT_EQ(A2_END_VALUE,a2->getAnimatedValue()  );
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_TRUE(l1->startCalled);ASSERT_TRUE(l2->startCalled);ASSERT_TRUE(l1->endCalled);ASSERT_TRUE(l2->endCalled);ASSERT_EQ(A1_END_VALUE,a1->getAnimatedValue()  );ASSERT_EQ(A2_END_VALUE,a2->getAnimatedValue()  ); }}  );
ValueAnimator->setDurationScale(scale);
ACE_EXPORTAnimator *  a3=ValueAnimator->ofInt(0  ,100  )  ;
a1->setDuration(400  );
a2->setDuration(600  );
a3->setDuration(400  );
ValueAnimatorTests::MyListener l1=new ValueAnimatorTests::MyListener()  ;
ValueAnimatorTests::MyListener l2=new ValueAnimatorTests::MyListener()  ;
ValueAnimatorTests::MyListener l3=new ValueAnimatorTests::MyListener()  ;
a1->addListener(l1);
a2->addListener(l2);
a3->addListener(l3);
ASSERT_FALSE(l1->startCalled);
ASSERT_FALSE(l2->startCalled);
ASSERT_FALSE(l3->startCalled);
ASSERT_FALSE(l1->endCalled);
ASSERT_FALSE(l2->endCalled);
ASSERT_FALSE(l3->endCalled);
a1->reverse();
a2->reverse();
a3->reverse();
ASSERT_FALSE(l1->startCalled);
ASSERT_FALSE(l2->startCalled);
ASSERT_FALSE(l3->startCalled);
ASSERT_FALSE(l1->endCalled);
ASSERT_FALSE(l2->endCalled);
ASSERT_FALSE(l3->endCalled);
a1->reverse();
a2->reverse();
a3->reverse();
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_FALSE(l1->startCalled);ASSERT_FALSE(l2->startCalled);ASSERT_FALSE(l3->startCalled);ASSERT_FALSE(l1->endCalled);ASSERT_FALSE(l2->endCalled);ASSERT_FALSE(l3->endCalled);a1->reverse();a2->reverse();a3->reverse(); }}  );
Thread->sleep(POLL_INTERVAL);
ASSERT_TRUE(l1->startCalled);
ASSERT_TRUE(l2->startCalled);
ASSERT_TRUE(l3->startCalled);
a1->setCurrentFraction(0f  );
a2->setCurrentFraction(1f  );
a3->Stop();
ASSERT_EQ(1f  ,a1->getAnimatedFraction()  );
ASSERT_EQ(0f  ,a2->getAnimatedFraction()  );
ASSERT_TRUE(l1->startCalled);
ASSERT_TRUE(l2->startCalled);
ASSERT_TRUE(l3->startCalled);
a1->setCurrentFraction(0f  );
a2->setCurrentFraction(1f  );
a3->Stop();
ASSERT_EQ(1f  ,a1->getAnimatedFraction()  );
ASSERT_EQ(0f  ,a2->getAnimatedFraction()  );
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_TRUE(l1->startCalled);ASSERT_TRUE(l2->startCalled);ASSERT_TRUE(l3->startCalled);a1->setCurrentFraction(0f  );a2->setCurrentFraction(1f  );a3->Stop();ASSERT_EQ(1f  ,a1->getAnimatedFraction()  );ASSERT_EQ(0f  ,a2->getAnimatedFraction()  ); }}  );
Thread->sleep(POLL_INTERVAL);
ASSERT_FALSE(l1->endCalled);
ASSERT_TRUE(l2->endCalled);
ASSERT_TRUE(l3->endCalled);
ASSERT_FALSE(l1->endCalled);
ASSERT_TRUE(l2->endCalled);
ASSERT_TRUE(l3->endCalled);
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_FALSE(l1->endCalled);ASSERT_TRUE(l2->endCalled);ASSERT_TRUE(l3->endCalled); }}  );
Thread->sleep(a1->getTotalDuration()  );
ASSERT_TRUE(l1->endCalled);
ASSERT_EQ(0f  ,a1->getAnimatedFraction()  );
ASSERT_EQ(0f  ,a2->getAnimatedFraction()  );
ASSERT_EQ(0f  ,a3->getAnimatedFraction()  );
ASSERT_TRUE(l1->endCalled);
ASSERT_EQ(0f  ,a1->getAnimatedFraction()  );
ASSERT_EQ(0f  ,a2->getAnimatedFraction()  );
ASSERT_EQ(0f  ,a3->getAnimatedFraction()  );
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_TRUE(l1->endCalled);ASSERT_EQ(0f  ,a1->getAnimatedFraction()  );ASSERT_EQ(0f  ,a2->getAnimatedFraction()  );ASSERT_EQ(0f  ,a3->getAnimatedFraction()  ); }}  );
}
//以下组件没有匹配:
//Runnable
void run()
{
lastUpdateTime=SystemClock->uptimeMillis()  ;
firstRunningFrameTime=lastUpdateTime;
startFraction=animation->getAnimatedFraction()  ;
wasRunning=animation->isRunning()  ;
if(animation->isRunning()   && !wasRunning){ firstRunningFrameTime=lastUpdateTime;startFraction=animation->getAnimatedFraction()  ;wasRunning=animation->isRunning()  ; }
wasRunning=false  ;
firstRunningFrameTime=-1  ;
lastUpdateTime=-1  ;
startFraction=0  ;
startCalled=true  ;
startTime=SystemClock->uptimeMillis()  ;
endCalled=true  ;
endTime=SystemClock->uptimeMillis()  ;
cancelCalled=true  ;
pauseCalled=true  ;
resumeCalled=true  ;
mHandler->sendEmptyMessageDelayed(MSG_FRAME,mFrameDelay);
mFrameCallbacks->add(callback);
if(!mFrameCallbacks->contains(callback)  ){ mFrameCallbacks->add(callback); }
mHandler->postDelayed(runnable,COMMIT_DELAY);
return SystemClock->uptimeMillis()  ;
return mFrameDelay;
mFrameDelay=delay;
mHandler->removeMessages(MSG_FRAME);
mHandler->sendEmptyMessageDelayed(MSG_FRAME,mFrameDelay);
if(mFrameCallbacks->size()   != 0  ){ mHandler->removeMessages(MSG_FRAME);mHandler->sendEmptyMessageDelayed(MSG_FRAME,mFrameDelay); }
Looper->prepare();
mFrameCallbacks->get(i)  -> doFrame(SystemClock->uptimeMillis()  );
for(int i=0  ;i < mFrameCallbacks->size()  ;i++){ mFrameCallbacks->get(i)  -> doFrame(SystemClock->uptimeMillis()  ); }
break;
break;
switch(msg->what){caseMSG_FRAME: for(int i=0  ;i < mFrameCallbacks->size()  ;i++){ mFrameCallbacks->get(i)  -> doFrame(SystemClock->uptimeMillis()  ); }break; default: break; }
{ switch(msg->what){caseMSG_FRAME: for(int i=0  ;i < mFrameCallbacks->size()  ;i++){ mFrameCallbacks->get(i)  -> doFrame(SystemClock->uptimeMillis()  ); }break; default: break; } }
mHandler=new Handler(){void handleMessage(Message *  msg) { { switch(msg->what){caseMSG_FRAME: for(int i=0  ;i < mFrameCallbacks->size()  ;i++){ mFrameCallbacks->get(i)  -> doFrame(SystemClock->uptimeMillis()  ); }break; default: break; } } }}  ;
Looper->loop();
a1=ValueAnimator->ofFloat(A1_START_VALUE,A1_END_VALUE)  -> setDuration(300  );
a2=ValueAnimator->ofInt(A2_START_VALUE,A2_END_VALUE)  -> setDuration(500  );
a1=null  ;
a2=null  ;
ACE_EXPORTAnimator *  a=ValueAnimator->ofFloat(5f  ,20f  )  ;
ASSERT_EQ(a->getStartDelay()  ,0  );
long delay=200  ;
a->setStartDelay(delay);
ASSERT_EQ(a->getStartDelay()  ,delay);
ValueAnimatorTests::MyUpdateListener listener=new ValueAnimatorTests::MyUpdateListener()  ;
a->AddUpdateListener(listener);
long [] startTime= newlong[1] ;
ASSERT_FALSE(a->IsRunning()  );
ASSERT_FALSE(a->IsRunning()  );
a->Play();
startTime[0]=SystemClock->uptimeMillis()  ;
ASSERT_TRUE(a->IsRunning()  );
ASSERT_FALSE(a->IsRunning()  );
ASSERT_FALSE(a->IsRunning()  );
ASSERT_FALSE(a->IsRunning()  );
a->Play();
startTime[0]=SystemClock->uptimeMillis()  ;
ASSERT_TRUE(a->IsRunning()  );
ASSERT_FALSE(a->IsRunning()  );
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_FALSE(a->IsRunning()  );ASSERT_FALSE(a->IsRunning()  );a->Play();startTime[0]=SystemClock->uptimeMillis()  ;ASSERT_TRUE(a->IsRunning()  );ASSERT_FALSE(a->IsRunning()  ); }}  );
Thread->sleep(a->getTotalDuration()  );
ASSERT_TRUE(listener->wasRunning);
ASSERT_TRUE(listener->firstRunningFrameTime - startTime[0]   >= delay);
ASSERT_TRUE(listener->wasRunning);
ASSERT_TRUE(listener->firstRunningFrameTime - startTime[0]   >= delay);
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_TRUE(listener->wasRunning);ASSERT_TRUE(listener->firstRunningFrameTime - startTime[0]   >= delay); }}  );
Thread->sleep(a->getTotalDuration()  );
ASSERT_FALSE(a->IsRunning()  );
ASSERT_FALSE(a->IsRunning()  );
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_FALSE(a->IsRunning()  ); }}  );
ValueAnimatorTests::MyListener l1=new ValueAnimatorTests::MyListener()  ;
ValueAnimatorTests::MyListener l2=new ValueAnimatorTests::MyListener()  ;
a1->addListener(l1);
a2->addListener(l2);
a2->setStartDelay(400  );
ASSERT_FALSE(l1->startCalled);
ASSERT_FALSE(l1->cancelCalled);
ASSERT_FALSE(l1->endCalled);
ASSERT_FALSE(l2->startCalled);
ASSERT_FALSE(l2->cancelCalled);
ASSERT_FALSE(l2->endCalled);
a1->Play();
a2->Play();
a1->Play();
a2->Play();
mActivityRule->runOnUiThread(new Runnable(){void run() { a1->Play();a2->Play(); }}  );
long wait=0  ;
Thread->sleep(POLL_INTERVAL);
wait+=POLL_INTERVAL;
ASSERT_FALSE(l1->cancelCalled);
a1->cancel();
ASSERT_TRUE(l1->cancelCalled);
ASSERT_TRUE(l1->endCalled);
ASSERT_FALSE(l1->cancelCalled);
a1->cancel();
ASSERT_TRUE(l1->cancelCalled);
ASSERT_TRUE(l1->endCalled);
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_FALSE(l1->cancelCalled);a1->cancel();ASSERT_TRUE(l1->cancelCalled);ASSERT_TRUE(l1->endCalled); }}  );
ASSERT_TRUE(l1->startCalled);
ASSERT_FALSE(l2->startCalled);
ASSERT_TRUE(l1->startCalled);
ASSERT_FALSE(l2->startCalled);
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_TRUE(l1->startCalled);ASSERT_FALSE(l2->startCalled); }}  );
Thread->sleep(POLL_INTERVAL);
wait+=POLL_INTERVAL;
while(wait < a2->getStartDelay()  ){ mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_TRUE(l1->startCalled);ASSERT_FALSE(l2->startCalled); }}  );Thread->sleep(POLL_INTERVAL);wait+=POLL_INTERVAL; }
long delay=Math->max(a1->getTotalDuration()  ,a2->getTotalDuration()  )   + TOLERANCE;
Thread->sleep(delay);
ASSERT_TRUE(l1->startCalled);
ASSERT_TRUE(l1->cancelCalled);
ASSERT_TRUE(l1->endCalled);
ASSERT_TRUE(l2->startCalled);
ASSERT_FALSE(l2->cancelCalled);
ASSERT_TRUE(l2->endCalled);
ASSERT_TRUE(l1->startCalled);
ASSERT_TRUE(l1->cancelCalled);
ASSERT_TRUE(l1->endCalled);
ASSERT_TRUE(l2->startCalled);
ASSERT_FALSE(l2->cancelCalled);
ASSERT_TRUE(l2->endCalled);
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_TRUE(l1->startCalled);ASSERT_TRUE(l1->cancelCalled);ASSERT_TRUE(l1->endCalled);ASSERT_TRUE(l2->startCalled);ASSERT_FALSE(l2->cancelCalled);ASSERT_TRUE(l2->endCalled); }}  );
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a2->IsRunning()  );
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a2->IsRunning()  );
long startDelay=150  ;
a1->setStartDelay(startDelay);
long [] startTime= newlong[1] ;
a1->Play();
a2->Play();
startTime[0]=SystemClock->uptimeMillis()  ;
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a2->IsRunning()  );
a1->Play();
a2->Play();
startTime[0]=SystemClock->uptimeMillis()  ;
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a2->IsRunning()  );
mActivityRule->runOnUiThread(new Runnable(){void run() { a1->Play();a2->Play();startTime[0]=SystemClock->uptimeMillis()  ;ASSERT_TRUE(a1->IsRunning()  );ASSERT_TRUE(a2->IsRunning()  ); }}  );
long delayMs=0  ;
Thread->sleep(POLL_INTERVAL);
delayMs+=POLL_INTERVAL;
ASSERT_FALSE(a1->IsRunning()  );
if(SystemClock->uptimeMillis()   - startTime[0]   < startDelay){ ASSERT_FALSE(a1->IsRunning()  ); }
ASSERT_FALSE(a1->IsRunning()  );
if(SystemClock->uptimeMillis()   - startTime[0]   < startDelay){ ASSERT_FALSE(a1->IsRunning()  ); }
mActivityRule->runOnUiThread(new Runnable(){void run() { if(SystemClock->uptimeMillis()   - startTime[0]   < startDelay){ ASSERT_FALSE(a1->IsRunning()  ); } }}  );
while(delayMs < startDelay){ Thread->sleep(POLL_INTERVAL);delayMs+=POLL_INTERVAL;mActivityRule->runOnUiThread(new Runnable(){void run() { if(SystemClock->uptimeMillis()   - startTime[0]   < startDelay){ ASSERT_FALSE(a1->IsRunning()  ); } }}  ); }
Thread->sleep(startDelay);
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a2->IsRunning()  );
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a2->IsRunning()  );
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_TRUE(a1->IsRunning()  );ASSERT_TRUE(a2->IsRunning()  ); }}  );
long delay=Math->max(a1->getTotalDuration()  ,a2->getTotalDuration()  )   * 2  ;
Thread->sleep(delay);
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a2->IsRunning()  );
ASSERT_FALSE(a2->IsRunning()  );
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a2->IsRunning()  );
ASSERT_FALSE(a2->IsRunning()  );
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_FALSE(a1->IsRunning()  );ASSERT_FALSE(a1->IsRunning()  );ASSERT_FALSE(a2->IsRunning()  );ASSERT_FALSE(a2->IsRunning()  ); }}  );
ASSERT_FALSE(a1->IsPending()  );
ASSERT_FALSE(a2->IsPending()  );
a1->Play();
a2->Play();
ASSERT_FALSE(a1->IsPending()  );
ASSERT_FALSE(a2->IsPending()  );
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a2->IsRunning()  );
ASSERT_FALSE(a1->IsPending()  );
ASSERT_FALSE(a2->IsPending()  );
a1->Play();
a2->Play();
ASSERT_FALSE(a1->IsPending()  );
ASSERT_FALSE(a2->IsPending()  );
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a2->IsRunning()  );
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_FALSE(a1->IsPending()  );ASSERT_FALSE(a2->IsPending()  );a1->Play();a2->Play();ASSERT_FALSE(a1->IsPending()  );ASSERT_FALSE(a2->IsPending()  );ASSERT_TRUE(a1->IsRunning()  );ASSERT_TRUE(a2->IsRunning()  ); }}  );
Thread->sleep(POLL_INTERVAL);
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a2->IsRunning()  );
a1->Pause();
ASSERT_TRUE(a1->IsPending()  );
ASSERT_FALSE(a2->IsPending()  );
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a2->IsRunning()  );
a1->Pause();
ASSERT_TRUE(a1->IsPending()  );
ASSERT_FALSE(a2->IsPending()  );
ASSERT_TRUE(a1->IsRunning()  );
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_TRUE(a1->IsRunning()  );ASSERT_TRUE(a2->IsRunning()  );a1->Pause();ASSERT_TRUE(a1->IsPending()  );ASSERT_FALSE(a2->IsPending()  );ASSERT_TRUE(a1->IsRunning()  ); }}  );
Thread->sleep(a2->getTotalDuration()  );
ASSERT_FALSE(a2->IsRunning()  );
ASSERT_FALSE(a2->IsRunning()  );
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a1->IsPending()  );
a1->resume();
ASSERT_FALSE(a2->IsRunning()  );
ASSERT_FALSE(a2->IsRunning()  );
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a1->IsPending()  );
a1->resume();
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_FALSE(a2->IsRunning()  );ASSERT_FALSE(a2->IsRunning()  );ASSERT_TRUE(a1->IsRunning()  );ASSERT_TRUE(a1->IsRunning()  );ASSERT_TRUE(a1->IsPending()  );a1->resume(); }}  );
Thread->sleep(POLL_INTERVAL);
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_FALSE(a1->IsPending()  );
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_FALSE(a1->IsPending()  );
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_TRUE(a1->IsRunning()  );ASSERT_TRUE(a1->IsRunning()  );ASSERT_FALSE(a1->IsPending()  ); }}  );
Thread->sleep(a1->getTotalDuration()  );
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a1->IsPending()  );
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a1->IsPending()  );
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_FALSE(a1->IsRunning()  );ASSERT_FALSE(a1->IsRunning()  );ASSERT_FALSE(a1->IsPending()  ); }}  );
ValueAnimatorTests::MyPauseListener l1=new ValueAnimatorTests::MyPauseListener()  ;
ValueAnimatorTests::MyPauseListener l2=new ValueAnimatorTests::MyPauseListener()  ;
a1->addPauseListener(l1);
a2->addPauseListener(l2);
ASSERT_FALSE(l1->pauseCalled);
ASSERT_FALSE(l1->resumeCalled);
ASSERT_FALSE(l2->pauseCalled);
ASSERT_FALSE(l2->resumeCalled);
a1->Play();
a2->Play();
a1->Play();
a2->Play();
mActivityRule->runOnUiThread(new Runnable(){void run() { a1->Play();a2->Play(); }}  );
Thread->sleep(a1->getTotalDuration()   / 2  );
a1->Pause();
Thread->sleep(a2->getTotalDuration()  );
ASSERT_TRUE(l1->pauseCalled);
ASSERT_FALSE(l1->resumeCalled);
a1->resume();
a1->resume();
mActivityRule->runOnUiThread(new Runnable(){void run() { a1->resume(); }}  );
Thread->sleep(a1->getTotalDuration()  );
ASSERT_TRUE(l1->pauseCalled);
ASSERT_TRUE(l1->resumeCalled);
ASSERT_FALSE(l2->pauseCalled);
ASSERT_FALSE(l2->resumeCalled);
ValueAnimatorTests::MyUpdateListener l1=new ValueAnimatorTests::MyUpdateListener()  ;
long totalDuration=a1->getTotalDuration()  ;
a1->AddUpdateListener(l1);
a1->setDuration(1000  );
ASSERT_TRUE(l1->firstRunningFrameTime < 0  );
ASSERT_TRUE(l1->lastUpdateTime < 0  );
long [] lastUpdate= newlong[1] ;
a1->Play();
a1->Play();
mActivityRule->runOnUiThread(new Runnable(){void run() { a1->Play(); }}  );
Thread->sleep(totalDuration / 2  );
ASSERT_TRUE(l1->firstRunningFrameTime > 0  );
ASSERT_TRUE(l1->lastUpdateTime > l1->firstRunningFrameTime);
lastUpdate[0]=l1->lastUpdateTime;
a1->Pause();
ASSERT_TRUE(l1->firstRunningFrameTime > 0  );
ASSERT_TRUE(l1->lastUpdateTime > l1->firstRunningFrameTime);
lastUpdate[0]=l1->lastUpdateTime;
a1->Pause();
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_TRUE(l1->firstRunningFrameTime > 0  );ASSERT_TRUE(l1->lastUpdateTime > l1->firstRunningFrameTime);lastUpdate[0]=l1->lastUpdateTime;a1->Pause(); }}  );
Thread->sleep(totalDuration);
ASSERT_EQ(lastUpdate[0]  ,l1->lastUpdateTime);
a1->resume();
ASSERT_EQ(lastUpdate[0]  ,l1->lastUpdateTime);
a1->resume();
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_EQ(lastUpdate[0]  ,l1->lastUpdateTime);a1->resume(); }}  );
Thread->sleep(POLL_INTERVAL);
ASSERT_TRUE(l1->lastUpdateTime > lastUpdate[0]  );
lastUpdate[0]=l1->lastUpdateTime;
ASSERT_TRUE(l1->lastUpdateTime > lastUpdate[0]  );
lastUpdate[0]=l1->lastUpdateTime;
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_TRUE(l1->lastUpdateTime > lastUpdate[0]  );lastUpdate[0]=l1->lastUpdateTime; }}  );
do{ Thread->sleep(POLL_INTERVAL);mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_TRUE(l1->lastUpdateTime > lastUpdate[0]  );lastUpdate[0]=l1->lastUpdateTime; }}  ); }while(!a1->IsRunning()  );
long entireSpan=totalDuration * 2  ;
long frameDelta=l1->lastUpdateTime - l1->firstRunningFrameTime;
ASSERT_TRUE(Math->abs(entireSpan - frameDelta)   < TOLERANCE);
ValueAnimatorTests::MyListener l1=new ValueAnimatorTests::MyListener()  ;
ValueAnimatorTests::MyListener l2=new ValueAnimatorTests::MyListener()  ;
a1->addListener(l1);
a2->addListener(l2);
anim->Cancel();
anim->Cancel();
a1->addListener(new ValueAnimatorTests::MyListener(){void onAnimationEnd(ACE_EXPORTAnimator *  anim) { anim->Cancel(); }}  );
anim->end();
anim->end();
a2->addListener(new ValueAnimatorTests::MyListener(){void onAnimationCancel(ACE_EXPORTAnimator *  anim) { anim->end(); }}  );
ASSERT_FALSE(l1->cancelCalled);
ASSERT_FALSE(l1->endCalled);
ASSERT_FALSE(l2->cancelCalled);
ASSERT_FALSE(l2->endCalled);
a1->Play();
a2->Play();
ASSERT_FALSE(l1->cancelCalled);
ASSERT_FALSE(l1->endCalled);
ASSERT_FALSE(l2->cancelCalled);
ASSERT_FALSE(l2->endCalled);
a1->Play();
a2->Play();
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_FALSE(l1->cancelCalled);ASSERT_FALSE(l1->endCalled);ASSERT_FALSE(l2->cancelCalled);ASSERT_FALSE(l2->endCalled);a1->Play();a2->Play(); }}  );
Thread->sleep(POLL_INTERVAL);
a1->Stop();
a2->cancel();
a1->Stop();
a2->cancel();
mActivityRule->runOnUiThread(new Runnable(){void run() { a1->Stop();a2->cancel(); }}  );
Thread->sleep(POLL_INTERVAL);
ASSERT_FALSE(l1->cancelCalled);
ASSERT_TRUE(l1->endCalled);
ASSERT_TRUE(l2->cancelCalled);
ASSERT_TRUE(l2->endCalled);
float value1=(Float)a1.getAnimatedValue();
int value2=(Integer)a2.getAnimatedValue();
ASSERT_EQ(A1_END_VALUE,value1);
ASSERT_EQ(A2_END_VALUE,value2);
ASSERT_FALSE(l1->cancelCalled);
ASSERT_TRUE(l1->endCalled);
ASSERT_TRUE(l2->cancelCalled);
ASSERT_TRUE(l2->endCalled);
float value1=(Float)a1.getAnimatedValue();
int value2=(Integer)a2.getAnimatedValue();
ASSERT_EQ(A1_END_VALUE,value1);
ASSERT_EQ(A2_END_VALUE,value2);
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_FALSE(l1->cancelCalled);ASSERT_TRUE(l1->endCalled);ASSERT_TRUE(l2->cancelCalled);ASSERT_TRUE(l2->endCalled);float value1=(Float)a1.getAnimatedValue();int value2=(Integer)a2.getAnimatedValue();ASSERT_EQ(A1_END_VALUE,value1);ASSERT_EQ(A2_END_VALUE,value2); }}  );
ValueAnimatorTests::MyListener l1=new ValueAnimatorTests::MyListener()  ;
a1->addListener(l1);
ValueAnimatorTests::MyListener l2=new ValueAnimatorTests::MyListener()  ;
a2->addListener(l2);
a1->Play();
a2->Play();
a1->Play();
a2->Play();
mActivityRule->runOnUiThread(new Runnable(){void run() { a1->Play();a2->Play(); }}  );
Thread->sleep(POLL_INTERVAL);
ASSERT_FALSE(l1->endCalled);
ASSERT_FALSE(l2->endCalled);
assertNotEqual(A1_END_VALUE,a1->getAnimatedValue()  );
assertNotEqual(A1_END_VALUE,a2->getAnimatedValue()  );
a2->Stop();
ASSERT_FALSE(l1->endCalled);
ASSERT_FALSE(l2->endCalled);
assertNotEqual(A1_END_VALUE,a1->getAnimatedValue()  );
assertNotEqual(A1_END_VALUE,a2->getAnimatedValue()  );
a2->Stop();
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_FALSE(l1->endCalled);ASSERT_FALSE(l2->endCalled);assertNotEqual(A1_END_VALUE,a1->getAnimatedValue()  );assertNotEqual(A1_END_VALUE,a2->getAnimatedValue()  );a2->Stop(); }}  );
Thread->sleep(a1->getTotalDuration()  );
ASSERT_FALSE(l1->cancelCalled);
ASSERT_TRUE(l1->endCalled);
ASSERT_FALSE(l2->cancelCalled);
ASSERT_TRUE(l2->endCalled);
ASSERT_EQ(A1_END_VALUE,((Float)(a1.getAnimatedValue()))  -> floatValue());
ASSERT_EQ(A2_END_VALUE,((Integer)(a2.getAnimatedValue()))  -> intValue());
ASSERT_FALSE(l1->cancelCalled);
ASSERT_TRUE(l1->endCalled);
ASSERT_FALSE(l2->cancelCalled);
ASSERT_TRUE(l2->endCalled);
ASSERT_EQ(A1_END_VALUE,((Float)(a1.getAnimatedValue()))  -> floatValue());
ASSERT_EQ(A2_END_VALUE,((Integer)(a2.getAnimatedValue()))  -> intValue());
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_FALSE(l1->cancelCalled);ASSERT_TRUE(l1->endCalled);ASSERT_FALSE(l2->cancelCalled);ASSERT_TRUE(l2->endCalled);ASSERT_EQ(A1_END_VALUE,((Float)(a1.getAnimatedValue()))  -> floatValue());ASSERT_EQ(A2_END_VALUE,((Integer)(a2.getAnimatedValue()))  -> intValue()); }}  );
ValueAnimatorTests::MyFrameCallbackProvider provider=new ValueAnimatorTests::MyFrameCallbackProvider()  ;
long sleep=0  ;
Thread->sleep(POLL_INTERVAL);
sleep+=POLL_INTERVAL;
break;
if(sleep > WAIT_TIME_OUT){ break; }
while(provider->mHandler == null  ){ Thread->sleep(POLL_INTERVAL);sleep+=POLL_INTERVAL;if(sleep > WAIT_TIME_OUT){ break; } }
assertNotNull(provider->mHandler);
ValueAnimatorTests::MyListener listener=new ValueAnimatorTests::MyListener()  ;
long currentTime=SystemClock->uptimeMillis()  ;
long frameDelay=provider->getFrameDelay()  ;
ASSERT_TRUE((currentTime-lastUpdateTime)   < frameDelay * 4  );
ASSERT_TRUE(listener->startCalled);
ASSERT_TRUE(listener->startTime > 0  );
ASSERT_TRUE(currentTime - listener->startTime < frameDelay * 4  );
if(lastUpdateTime > 0  ){ ASSERT_TRUE((currentTime-lastUpdateTime)   < frameDelay * 4  ); }else{ ASSERT_TRUE(listener->startCalled);ASSERT_TRUE(listener->startTime > 0  );ASSERT_TRUE(currentTime - listener->startTime < frameDelay * 4  ); }
super-> onAnimationUpdate(animation);
ValueAnimatorTests::MyUpdateListener l1=new ValueAnimatorTests::MyUpdateListener(){void onAnimationUpdate(ACE_EXPORTAnimator *  animation) { long currentTime=SystemClock->uptimeMillis()  ;long frameDelay=provider->getFrameDelay()  ;if(lastUpdateTime > 0  ){ ASSERT_TRUE((currentTime-lastUpdateTime)   < frameDelay * 4  ); }else{ ASSERT_TRUE(listener->startCalled);ASSERT_TRUE(listener->startTime > 0  );ASSERT_TRUE(currentTime - listener->startTime < frameDelay * 4  ); }super-> onAnimationUpdate(animation); }}  ;
a1->AddUpdateListener(l1);
a1->addListener(listener);
a1->setStartDelay(100  );
AnimationHandler->getInstance()  -> setProvider(provider);
a1->Play();
AnimationHandler->getInstance()  -> setProvider(provider);
a1->Play();
provider.mHandler->post(new Runnable(){void run() { AnimationHandler->getInstance()  -> setProvider(provider);a1->Play(); }}  );
Thread->sleep(POLL_INTERVAL);
ASSERT_TRUE(a1->IsRunning()  );
Thread->sleep(a1->getTotalDuration()   + TOLERANCE);
throwprovider->mAssertionError;
if(provider->mAssertionError != null  ){ throwprovider->mAssertionError; }
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_TRUE(listener->endTime > 0  );
ASSERT_TRUE(listener->endTime >= l1->lastUpdateTime);
ASSERT_TRUE(listener->endTime - l1->lastUpdateTime < 2   * provider->getFrameDelay()  );
ACE_EXPORTAnimator *  a0=ValueAnimator->ofInt(100  ,200  )  -> setDuration(500  );
ACE_EXPORTAnimator *  a3=ValueAnimator->ofFloat(0  ,1  )  -> setDuration(500  );
ACE_EXPORTAnimator *  a4=ValueAnimator->ofInt(200  ,300  )  -> setDuration(500  );
super-> onAnimationEnd(anim);
a0->cancel();
a1->Stop();
a3->Stop();
a4->cancel();
ValueAnimatorTests::MyListener listener=new ValueAnimatorTests::MyListener(){void onAnimationEnd(ACE_EXPORTAnimator *  anim) { super-> onAnimationEnd(anim);a0->cancel();a1->Stop();a3->Stop();a4->cancel(); }}  ;
a2->addListener(listener);
a0->Play();
a1->Play();
a2->Play();
a3->Play();
a4->Play();
a0->Play();
a1->Play();
a2->Play();
a3->Play();
a4->Play();
mActivityRule->runOnUiThread(new Runnable(){void run() { a0->Play();a1->Play();a2->Play();a3->Play();a4->Play(); }}  );
ASSERT_TRUE(a0->IsRunning()  );
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a2->IsRunning()  );
ASSERT_TRUE(a3->IsRunning()  );
ASSERT_TRUE(a4->IsRunning()  );
ASSERT_TRUE(a0->IsRunning()  );
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a2->IsRunning()  );
ASSERT_TRUE(a3->IsRunning()  );
ASSERT_TRUE(a4->IsRunning()  );
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_TRUE(a0->IsRunning()  );ASSERT_TRUE(a1->IsRunning()  );ASSERT_TRUE(a2->IsRunning()  );ASSERT_TRUE(a3->IsRunning()  );ASSERT_TRUE(a4->IsRunning()  ); }}  );
Thread->sleep(POLL_INTERVAL);
a2->Stop();
a2->Stop();
mActivityRule->runOnUiThread(new Runnable(){void run() { a2->Stop(); }}  );
Thread->sleep(POLL_INTERVAL);
ASSERT_TRUE(listener->endCalled);
ASSERT_FALSE(a0->IsRunning()  );
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a2->IsRunning()  );
ASSERT_FALSE(a3->IsRunning()  );
ASSERT_FALSE(a4->IsRunning()  );
ValueAnimatorTests::MyListener l1=new ValueAnimatorTests::MyListener()  ;
ValueAnimatorTests::MyListener l2=new ValueAnimatorTests::MyListener()  ;
ValueAnimatorTests::MyUpdateListener updateListener1=new ValueAnimatorTests::MyUpdateListener()  ;
ValueAnimatorTests::MyUpdateListener updateListener2=new ValueAnimatorTests::MyUpdateListener()  ;
float a1StartFraction=0.2f  ;
float a2StartFraction=0.3f  ;
a1->setDuration(1000  );
a2->setDuration(1000  );
a1->addListener(l1);
a2->addListener(l2);
a1->AddUpdateListener(updateListener1);
a2->AddUpdateListener(updateListener2);
//以下组件没有匹配:
//TimeInterpolator,LinearInterpolator
TimeInterpolator *  interpolator=new LinearInterpolator()  ;
a1->setInterpolator(interpolator);
a2->setInterpolator(interpolator);
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a2->IsRunning()  );
ASSERT_FALSE(a2->IsRunning()  );
a1->setCurrentFraction(a1StartFraction);
a2->setCurrentFraction(a2StartFraction);
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a2->IsRunning()  );
ASSERT_FALSE(a2->IsRunning()  );
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a2->IsRunning()  );
ASSERT_FALSE(a2->IsRunning()  );
a1->setCurrentFraction(a1StartFraction);
a2->setCurrentFraction(a2StartFraction);
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a2->IsRunning()  );
ASSERT_FALSE(a2->IsRunning()  );
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_FALSE(a1->IsRunning()  );ASSERT_FALSE(a1->IsRunning()  );ASSERT_FALSE(a2->IsRunning()  );ASSERT_FALSE(a2->IsRunning()  );a1->setCurrentFraction(a1StartFraction);a2->setCurrentFraction(a2StartFraction);ASSERT_FALSE(a1->IsRunning()  );ASSERT_FALSE(a1->IsRunning()  );ASSERT_FALSE(a2->IsRunning()  );ASSERT_FALSE(a2->IsRunning()  ); }}  );
Thread->sleep(POLL_INTERVAL);
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a2->IsRunning()  );
ASSERT_FALSE(a2->IsRunning()  );
ASSERT_EQ(a1StartFraction,a1->getAnimatedFraction()  );
ASSERT_EQ(a2StartFraction,a2->getAnimatedFraction()  );
a1->Play();
a2->Play();
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a2->IsRunning()  );
ASSERT_FALSE(a2->IsRunning()  );
ASSERT_EQ(a1StartFraction,a1->getAnimatedFraction()  );
ASSERT_EQ(a2StartFraction,a2->getAnimatedFraction()  );
a1->Play();
a2->Play();
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_FALSE(a1->IsRunning()  );ASSERT_FALSE(a1->IsRunning()  );ASSERT_FALSE(a2->IsRunning()  );ASSERT_FALSE(a2->IsRunning()  );ASSERT_EQ(a1StartFraction,a1->getAnimatedFraction()  );ASSERT_EQ(a2StartFraction,a2->getAnimatedFraction()  );a1->Play();a2->Play(); }}  );
Thread->sleep(POLL_INTERVAL);
float halfwayFraction=0.5f  ;
ASSERT_TRUE(l1->startCalled);
ASSERT_TRUE(l2->startCalled);
ASSERT_FALSE(l1->endCalled);
ASSERT_FALSE(l2->endCalled);
ASSERT_TRUE(updateListener1->startFraction >= a1StartFraction);
ASSERT_TRUE(updateListener2->startFraction >= a2StartFraction);
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a2->IsRunning()  );
ASSERT_TRUE(a2->IsRunning()  );
a1->setCurrentFraction(halfwayFraction);
a2->setCurrentFraction(halfwayFraction);
ASSERT_TRUE(l1->startCalled);
ASSERT_TRUE(l2->startCalled);
ASSERT_FALSE(l1->endCalled);
ASSERT_FALSE(l2->endCalled);
ASSERT_TRUE(updateListener1->startFraction >= a1StartFraction);
ASSERT_TRUE(updateListener2->startFraction >= a2StartFraction);
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a2->IsRunning()  );
ASSERT_TRUE(a2->IsRunning()  );
a1->setCurrentFraction(halfwayFraction);
a2->setCurrentFraction(halfwayFraction);
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_TRUE(l1->startCalled);ASSERT_TRUE(l2->startCalled);ASSERT_FALSE(l1->endCalled);ASSERT_FALSE(l2->endCalled);ASSERT_TRUE(updateListener1->startFraction >= a1StartFraction);ASSERT_TRUE(updateListener2->startFraction >= a2StartFraction);ASSERT_TRUE(a1->IsRunning()  );ASSERT_TRUE(a1->IsRunning()  );ASSERT_TRUE(a2->IsRunning()  );ASSERT_TRUE(a2->IsRunning()  );a1->setCurrentFraction(halfwayFraction);a2->setCurrentFraction(halfwayFraction); }}  );
Thread->sleep(POLL_INTERVAL);
ASSERT_TRUE(l1->startCalled);
ASSERT_TRUE(l2->startCalled);
ASSERT_FALSE(l1->endCalled);
ASSERT_FALSE(l2->endCalled);
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a2->IsRunning()  );
ASSERT_TRUE(a2->IsRunning()  );
ASSERT_TRUE(l1->startCalled);
ASSERT_TRUE(l2->startCalled);
ASSERT_FALSE(l1->endCalled);
ASSERT_FALSE(l2->endCalled);
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a2->IsRunning()  );
ASSERT_TRUE(a2->IsRunning()  );
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_TRUE(l1->startCalled);ASSERT_TRUE(l2->startCalled);ASSERT_FALSE(l1->endCalled);ASSERT_FALSE(l2->endCalled);ASSERT_TRUE(a1->IsRunning()  );ASSERT_TRUE(a1->IsRunning()  );ASSERT_TRUE(a2->IsRunning()  );ASSERT_TRUE(a2->IsRunning()  ); }}  );
long wait=Math->max(a1->getTotalDuration()  ,a2->getTotalDuration()  )  ;
Thread->sleep(wait);
ASSERT_TRUE(l1->endCalled);
ASSERT_TRUE(l2->endCalled);
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a2->IsRunning()  );
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a2->IsRunning()  );
ASSERT_TRUE(l1->endCalled);
ASSERT_TRUE(l2->endCalled);
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a2->IsRunning()  );
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a2->IsRunning()  );
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_TRUE(l1->endCalled);ASSERT_TRUE(l2->endCalled);ASSERT_FALSE(a1->IsRunning()  );ASSERT_FALSE(a2->IsRunning()  );ASSERT_FALSE(a1->IsRunning()  );ASSERT_FALSE(a2->IsRunning()  ); }}  );
updateListener1->reset();
a1->Play();
a1->Play();
mActivityRule->runOnUiThread(new Runnable(){void run() { a1->Play(); }}  );
Thread->sleep(POLL_INTERVAL);
ASSERT_TRUE(updateListener1->wasRunning);
ASSERT_TRUE(updateListener1->startFraction >= 0  );
ASSERT_TRUE(updateListener1->startFraction < halfwayFraction);
a1->Stop();
ASSERT_TRUE(updateListener1->wasRunning);
ASSERT_TRUE(updateListener1->startFraction >= 0  );
ASSERT_TRUE(updateListener1->startFraction < halfwayFraction);
a1->Stop();
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_TRUE(updateListener1->wasRunning);ASSERT_TRUE(updateListener1->startFraction >= 0  );ASSERT_TRUE(updateListener1->startFraction < halfwayFraction);a1->Stop(); }}  );
ValueAnimatorTests::MyListener l1=new ValueAnimatorTests::MyListener()  ;
ValueAnimatorTests::MyListener l2=new ValueAnimatorTests::MyListener()  ;
a1->addListener(l1);
a2->addListener(l2);
ASSERT_FALSE(l1->startCalled);
ASSERT_FALSE(l2->startCalled);
ASSERT_EQ(0f  ,a1->getAnimatedFraction()  );
ASSERT_EQ(0f  ,a2->getAnimatedFraction()  );
a1->Play();
a2->Play();
ASSERT_FALSE(l1->startCalled);
ASSERT_FALSE(l2->startCalled);
ASSERT_EQ(0f  ,a1->getAnimatedFraction()  );
ASSERT_EQ(0f  ,a2->getAnimatedFraction()  );
a1->Play();
a2->Play();
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_FALSE(l1->startCalled);ASSERT_FALSE(l2->startCalled);ASSERT_EQ(0f  ,a1->getAnimatedFraction()  );ASSERT_EQ(0f  ,a2->getAnimatedFraction()  );a1->Play();a2->Play(); }}  );
Thread->sleep(POLL_INTERVAL);
ASSERT_FALSE(l1->endCalled);
ASSERT_FALSE(l2->endCalled);
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a2->IsRunning()  );
a1->setCurrentFraction(0f  );
a2->setCurrentFraction(1f  );
ASSERT_FALSE(l1->endCalled);
ASSERT_FALSE(l2->endCalled);
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a2->IsRunning()  );
a1->setCurrentFraction(0f  );
a2->setCurrentFraction(1f  );
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_FALSE(l1->endCalled);ASSERT_FALSE(l2->endCalled);ASSERT_TRUE(a1->IsRunning()  );ASSERT_TRUE(a2->IsRunning()  );a1->setCurrentFraction(0f  );a2->setCurrentFraction(1f  ); }}  );
Thread->sleep(POLL_INTERVAL);
ASSERT_FALSE(l1->endCalled);
ASSERT_TRUE(l2->endCalled);
ASSERT_EQ(1f  ,a2->getAnimatedFraction()  );
ASSERT_FALSE(l1->endCalled);
ASSERT_TRUE(l2->endCalled);
ASSERT_EQ(1f  ,a2->getAnimatedFraction()  );
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_FALSE(l1->endCalled);ASSERT_TRUE(l2->endCalled);ASSERT_EQ(1f  ,a2->getAnimatedFraction()  ); }}  );
Thread->sleep(a1->getTotalDuration()  );
ASSERT_TRUE(l1->endCalled);
ASSERT_EQ(1f  ,a1->getAnimatedFraction()  );
ASSERT_TRUE(l1->endCalled);
ASSERT_EQ(1f  ,a1->getAnimatedFraction()  );
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_TRUE(l1->endCalled);ASSERT_EQ(1f  ,a1->getAnimatedFraction()  ); }}  );
a1->setStartDelay(20  );
ValueAnimatorTests::MyListener normalEndingListener=new ValueAnimatorTests::MyListener()  ;
a1->addListener(normalEndingListener);
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(normalEndingListener->startCalled);
ASSERT_FALSE(normalEndingListener->endCalled);
a1->Play();
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(normalEndingListener->startCalled);
ASSERT_FALSE(normalEndingListener->endCalled);
a1->Play();
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_FALSE(a1->IsRunning()  );ASSERT_FALSE(normalEndingListener->startCalled);ASSERT_FALSE(normalEndingListener->endCalled);a1->Play(); }}  );
Thread->sleep(a1->getTotalDuration()   + POLL_INTERVAL);
ValueAnimatorTests::MyListener l1=new ValueAnimatorTests::MyListener()  ;
a1->addListener(l1);
ValueAnimatorTests::MyListener l2=new ValueAnimatorTests::MyListener()  ;
a2->addListener(l2);
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(l1->startCalled);
ASSERT_FALSE(l1->endCalled);
ASSERT_FALSE(a2->IsRunning()  );
ASSERT_FALSE(l2->startCalled);
ASSERT_FALSE(l1->endCalled);
a1->Stop();
a2->Stop();
ASSERT_TRUE(l1->startCalled);
ASSERT_TRUE(l1->endCalled);
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_TRUE(l1->endTime >= l1->startTime);
ASSERT_TRUE(l2->startCalled);
ASSERT_TRUE(l2->endCalled);
ASSERT_FALSE(a2->IsRunning()  );
ASSERT_TRUE(l2->endTime >= l1->startTime);
ValueAnimatorTests::MyListener l1=new ValueAnimatorTests::MyListener()  ;
a1->addListener(l1);
ValueAnimatorTests::MyListener l2=new ValueAnimatorTests::MyListener()  ;
a2->addListener(l2);
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(l1->startCalled);
ASSERT_FALSE(l1->endCalled);
ASSERT_FALSE(a2->IsRunning()  );
ASSERT_FALSE(l2->startCalled);
ASSERT_FALSE(l1->endCalled);
a1->Stop();
a2->Stop();
ASSERT_TRUE(l1->startCalled);
ASSERT_TRUE(l1->endCalled);
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_TRUE(l1->endTime >= l1->startTime);
ASSERT_TRUE(l2->startCalled);
ASSERT_TRUE(l2->endCalled);
ASSERT_FALSE(a2->IsRunning()  );
ASSERT_TRUE(l2->endTime >= l1->startTime);
mActivityRule->runOnUiThread(new Runnable(){void run() { ValueAnimatorTests::MyListener l1=new ValueAnimatorTests::MyListener()  ;a1->addListener(l1);ValueAnimatorTests::MyListener l2=new ValueAnimatorTests::MyListener()  ;a2->addListener(l2);ASSERT_FALSE(a1->IsRunning()  );ASSERT_FALSE(l1->startCalled);ASSERT_FALSE(l1->endCalled);ASSERT_FALSE(a2->IsRunning()  );ASSERT_FALSE(l2->startCalled);ASSERT_FALSE(l1->endCalled);a1->Stop();a2->Stop();ASSERT_TRUE(l1->startCalled);ASSERT_TRUE(l1->endCalled);ASSERT_FALSE(a1->IsRunning()  );ASSERT_TRUE(l1->endTime >= l1->startTime);ASSERT_TRUE(l2->startCalled);ASSERT_TRUE(l2->endCalled);ASSERT_FALSE(a2->IsRunning()  );ASSERT_TRUE(l2->endTime >= l1->startTime); }}  );
a1->setDuration(0  );
a2->setDuration(0  );
ACE_EXPORTAnimator *  a3=ValueAnimator->ofInt(0  ,100  )  ;
a3->setDuration(0  );
a3->setCurrentFraction(1.0f  );
ASSERT_EQ(1.0f  ,a3->getAnimatedFraction()  );
ValueAnimatorTests::MyListener l1=new ValueAnimatorTests::MyListener()  ;
ValueAnimatorTests::MyListener l2=new ValueAnimatorTests::MyListener()  ;
ValueAnimatorTests::MyListener l3=new ValueAnimatorTests::MyListener()  ;
a1->addListener(l1);
a2->addListener(l2);
a3->addListener(l3);
ASSERT_FALSE(l1->startCalled);
ASSERT_FALSE(l2->startCalled);
ASSERT_FALSE(l3->startCalled);
ASSERT_FALSE(l1->endCalled);
ASSERT_FALSE(l2->endCalled);
ASSERT_FALSE(l3->endCalled);
a1->Play();
a2->reverse();
a3->Play();
ASSERT_EQ(A1_END_VALUE,a1->getAnimatedValue()  );
ASSERT_EQ(A2_START_VALUE,a2->getAnimatedValue()  );
ASSERT_FALSE(l1->startCalled);
ASSERT_FALSE(l2->startCalled);
ASSERT_FALSE(l3->startCalled);
ASSERT_FALSE(l1->endCalled);
ASSERT_FALSE(l2->endCalled);
ASSERT_FALSE(l3->endCalled);
a1->Play();
a2->reverse();
a3->Play();
ASSERT_EQ(A1_END_VALUE,a1->getAnimatedValue()  );
ASSERT_EQ(A2_START_VALUE,a2->getAnimatedValue()  );
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_FALSE(l1->startCalled);ASSERT_FALSE(l2->startCalled);ASSERT_FALSE(l3->startCalled);ASSERT_FALSE(l1->endCalled);ASSERT_FALSE(l2->endCalled);ASSERT_FALSE(l3->endCalled);a1->Play();a2->reverse();a3->Play();ASSERT_EQ(A1_END_VALUE,a1->getAnimatedValue()  );ASSERT_EQ(A2_START_VALUE,a2->getAnimatedValue()  ); }}  );
Thread->sleep(POLL_INTERVAL);
ASSERT_TRUE(l1->startCalled);
ASSERT_TRUE(l2->startCalled);
ASSERT_TRUE(l3->startCalled);
ASSERT_TRUE(l1->endCalled);
ASSERT_TRUE(l2->endCalled);
ASSERT_TRUE(l3->endCalled);
ASSERT_EQ(1.0f  ,a1->getAnimatedFraction()  );
ASSERT_EQ(0f  ,a2->getAnimatedFraction()  );
ASSERT_EQ(1f  ,a3->getAnimatedFraction()  );
ASSERT_EQ(A1_END_VALUE,a1->getAnimatedValue()  );
ASSERT_EQ(A2_START_VALUE,a2->getAnimatedValue()  );
ASSERT_EQ(100  ,a3->getAnimatedValue()  );
ASSERT_TRUE(l1->startCalled);
ASSERT_TRUE(l2->startCalled);
ASSERT_TRUE(l3->startCalled);
ASSERT_TRUE(l1->endCalled);
ASSERT_TRUE(l2->endCalled);
ASSERT_TRUE(l3->endCalled);
ASSERT_EQ(1.0f  ,a1->getAnimatedFraction()  );
ASSERT_EQ(0f  ,a2->getAnimatedFraction()  );
ASSERT_EQ(1f  ,a3->getAnimatedFraction()  );
ASSERT_EQ(A1_END_VALUE,a1->getAnimatedValue()  );
ASSERT_EQ(A2_START_VALUE,a2->getAnimatedValue()  );
ASSERT_EQ(100  ,a3->getAnimatedValue()  );
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_TRUE(l1->startCalled);ASSERT_TRUE(l2->startCalled);ASSERT_TRUE(l3->startCalled);ASSERT_TRUE(l1->endCalled);ASSERT_TRUE(l2->endCalled);ASSERT_TRUE(l3->endCalled);ASSERT_EQ(1.0f  ,a1->getAnimatedFraction()  );ASSERT_EQ(0f  ,a2->getAnimatedFraction()  );ASSERT_EQ(1f  ,a3->getAnimatedFraction()  );ASSERT_EQ(A1_END_VALUE,a1->getAnimatedValue()  );ASSERT_EQ(A2_START_VALUE,a2->getAnimatedValue()  );ASSERT_EQ(100  ,a3->getAnimatedValue()  ); }}  );
float scale=ValueAnimator->getDurationScale()  ;
ValueAnimator->setDurationScale(0f  );
a1->setStartDelay(200  );
ValueAnimatorTests::MyListener l1=new ValueAnimatorTests::MyListener()  ;
ValueAnimatorTests::MyListener l2=new ValueAnimatorTests::MyListener()  ;
a1->addListener(l1);
a2->addListener(l2);
ASSERT_FALSE(l1->startCalled);
ASSERT_FALSE(l2->startCalled);
ASSERT_FALSE(l1->endCalled);
ASSERT_FALSE(l2->endCalled);
a1->Play();
a2->Play();
ASSERT_EQ(A2_START_VALUE,a2->getAnimatedValue()  );
ASSERT_FALSE(l1->startCalled);
ASSERT_FALSE(l2->startCalled);
ASSERT_FALSE(l1->endCalled);
ASSERT_FALSE(l2->endCalled);
a1->Play();
a2->Play();
ASSERT_EQ(A2_START_VALUE,a2->getAnimatedValue()  );
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_FALSE(l1->startCalled);ASSERT_FALSE(l2->startCalled);ASSERT_FALSE(l1->endCalled);ASSERT_FALSE(l2->endCalled);a1->Play();a2->Play();ASSERT_EQ(A2_START_VALUE,a2->getAnimatedValue()  ); }}  );
Thread->sleep(POLL_INTERVAL);
ASSERT_TRUE(l1->startCalled);
ASSERT_TRUE(l2->startCalled);
ASSERT_TRUE(l1->endCalled);
ASSERT_TRUE(l2->endCalled);
ASSERT_EQ(A1_END_VALUE,a1->getAnimatedValue()  );
ASSERT_EQ(A2_END_VALUE,a2->getAnimatedValue()  );
ASSERT_TRUE(l1->startCalled);
ASSERT_TRUE(l2->startCalled);
ASSERT_TRUE(l1->endCalled);
ASSERT_TRUE(l2->endCalled);
ASSERT_EQ(A1_END_VALUE,a1->getAnimatedValue()  );
ASSERT_EQ(A2_END_VALUE,a2->getAnimatedValue()  );
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_TRUE(l1->startCalled);ASSERT_TRUE(l2->startCalled);ASSERT_TRUE(l1->endCalled);ASSERT_TRUE(l2->endCalled);ASSERT_EQ(A1_END_VALUE,a1->getAnimatedValue()  );ASSERT_EQ(A2_END_VALUE,a2->getAnimatedValue()  ); }}  );
ValueAnimator->setDurationScale(scale);
ACE_EXPORTAnimator *  a3=ValueAnimator->ofInt(0  ,100  )  ;
a1->setDuration(400  );
a2->setDuration(600  );
a3->setDuration(400  );
ValueAnimatorTests::MyListener l1=new ValueAnimatorTests::MyListener()  ;
ValueAnimatorTests::MyListener l2=new ValueAnimatorTests::MyListener()  ;
ValueAnimatorTests::MyListener l3=new ValueAnimatorTests::MyListener()  ;
a1->addListener(l1);
a2->addListener(l2);
a3->addListener(l3);
ASSERT_FALSE(l1->startCalled);
ASSERT_FALSE(l2->startCalled);
ASSERT_FALSE(l3->startCalled);
ASSERT_FALSE(l1->endCalled);
ASSERT_FALSE(l2->endCalled);
ASSERT_FALSE(l3->endCalled);
a1->reverse();
a2->reverse();
a3->reverse();
ASSERT_FALSE(l1->startCalled);
ASSERT_FALSE(l2->startCalled);
ASSERT_FALSE(l3->startCalled);
ASSERT_FALSE(l1->endCalled);
ASSERT_FALSE(l2->endCalled);
ASSERT_FALSE(l3->endCalled);
a1->reverse();
a2->reverse();
a3->reverse();
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_FALSE(l1->startCalled);ASSERT_FALSE(l2->startCalled);ASSERT_FALSE(l3->startCalled);ASSERT_FALSE(l1->endCalled);ASSERT_FALSE(l2->endCalled);ASSERT_FALSE(l3->endCalled);a1->reverse();a2->reverse();a3->reverse(); }}  );
Thread->sleep(POLL_INTERVAL);
ASSERT_TRUE(l1->startCalled);
ASSERT_TRUE(l2->startCalled);
ASSERT_TRUE(l3->startCalled);
a1->setCurrentFraction(0f  );
a2->setCurrentFraction(1f  );
a3->Stop();
ASSERT_EQ(1f  ,a1->getAnimatedFraction()  );
ASSERT_EQ(0f  ,a2->getAnimatedFraction()  );
ASSERT_TRUE(l1->startCalled);
ASSERT_TRUE(l2->startCalled);
ASSERT_TRUE(l3->startCalled);
a1->setCurrentFraction(0f  );
a2->setCurrentFraction(1f  );
a3->Stop();
ASSERT_EQ(1f  ,a1->getAnimatedFraction()  );
ASSERT_EQ(0f  ,a2->getAnimatedFraction()  );
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_TRUE(l1->startCalled);ASSERT_TRUE(l2->startCalled);ASSERT_TRUE(l3->startCalled);a1->setCurrentFraction(0f  );a2->setCurrentFraction(1f  );a3->Stop();ASSERT_EQ(1f  ,a1->getAnimatedFraction()  );ASSERT_EQ(0f  ,a2->getAnimatedFraction()  ); }}  );
Thread->sleep(POLL_INTERVAL);
ASSERT_FALSE(l1->endCalled);
ASSERT_TRUE(l2->endCalled);
ASSERT_TRUE(l3->endCalled);
ASSERT_FALSE(l1->endCalled);
ASSERT_TRUE(l2->endCalled);
ASSERT_TRUE(l3->endCalled);
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_FALSE(l1->endCalled);ASSERT_TRUE(l2->endCalled);ASSERT_TRUE(l3->endCalled); }}  );
Thread->sleep(a1->getTotalDuration()  );
ASSERT_TRUE(l1->endCalled);
ASSERT_EQ(0f  ,a1->getAnimatedFraction()  );
ASSERT_EQ(0f  ,a2->getAnimatedFraction()  );
ASSERT_EQ(0f  ,a3->getAnimatedFraction()  );
ASSERT_TRUE(l1->endCalled);
ASSERT_EQ(0f  ,a1->getAnimatedFraction()  );
ASSERT_EQ(0f  ,a2->getAnimatedFraction()  );
ASSERT_EQ(0f  ,a3->getAnimatedFraction()  );
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_TRUE(l1->endCalled);ASSERT_EQ(0f  ,a1->getAnimatedFraction()  );ASSERT_EQ(0f  ,a2->getAnimatedFraction()  );ASSERT_EQ(0f  ,a3->getAnimatedFraction()  ); }}  );
}
//以下组件没有匹配:
//Runnable
void run()
{
lastUpdateTime=SystemClock->uptimeMillis()  ;
firstRunningFrameTime=lastUpdateTime;
startFraction=animation->getAnimatedFraction()  ;
wasRunning=animation->isRunning()  ;
if(animation->isRunning()   && !wasRunning){ firstRunningFrameTime=lastUpdateTime;startFraction=animation->getAnimatedFraction()  ;wasRunning=animation->isRunning()  ; }
wasRunning=false  ;
firstRunningFrameTime=-1  ;
lastUpdateTime=-1  ;
startFraction=0  ;
startCalled=true  ;
startTime=SystemClock->uptimeMillis()  ;
endCalled=true  ;
endTime=SystemClock->uptimeMillis()  ;
cancelCalled=true  ;
pauseCalled=true  ;
resumeCalled=true  ;
mHandler->sendEmptyMessageDelayed(MSG_FRAME,mFrameDelay);
mFrameCallbacks->add(callback);
if(!mFrameCallbacks->contains(callback)  ){ mFrameCallbacks->add(callback); }
mHandler->postDelayed(runnable,COMMIT_DELAY);
return SystemClock->uptimeMillis()  ;
return mFrameDelay;
mFrameDelay=delay;
mHandler->removeMessages(MSG_FRAME);
mHandler->sendEmptyMessageDelayed(MSG_FRAME,mFrameDelay);
if(mFrameCallbacks->size()   != 0  ){ mHandler->removeMessages(MSG_FRAME);mHandler->sendEmptyMessageDelayed(MSG_FRAME,mFrameDelay); }
Looper->prepare();
mFrameCallbacks->get(i)  -> doFrame(SystemClock->uptimeMillis()  );
for(int i=0  ;i < mFrameCallbacks->size()  ;i++){ mFrameCallbacks->get(i)  -> doFrame(SystemClock->uptimeMillis()  ); }
break;
break;
switch(msg->what){caseMSG_FRAME: for(int i=0  ;i < mFrameCallbacks->size()  ;i++){ mFrameCallbacks->get(i)  -> doFrame(SystemClock->uptimeMillis()  ); }break; default: break; }
{ switch(msg->what){caseMSG_FRAME: for(int i=0  ;i < mFrameCallbacks->size()  ;i++){ mFrameCallbacks->get(i)  -> doFrame(SystemClock->uptimeMillis()  ); }break; default: break; } }
mHandler=new Handler(){void handleMessage(Message *  msg) { { switch(msg->what){caseMSG_FRAME: for(int i=0  ;i < mFrameCallbacks->size()  ;i++){ mFrameCallbacks->get(i)  -> doFrame(SystemClock->uptimeMillis()  ); }break; default: break; } } }}  ;
Looper->loop();
a1=ValueAnimator->ofFloat(A1_START_VALUE,A1_END_VALUE)  -> setDuration(300  );
a2=ValueAnimator->ofInt(A2_START_VALUE,A2_END_VALUE)  -> setDuration(500  );
a1=null  ;
a2=null  ;
ACE_EXPORTAnimator *  a=ValueAnimator->ofFloat(5f  ,20f  )  ;
ASSERT_EQ(a->getStartDelay()  ,0  );
long delay=200  ;
a->setStartDelay(delay);
ASSERT_EQ(a->getStartDelay()  ,delay);
ValueAnimatorTests::MyUpdateListener listener=new ValueAnimatorTests::MyUpdateListener()  ;
a->AddUpdateListener(listener);
long [] startTime= newlong[1] ;
ASSERT_FALSE(a->IsRunning()  );
ASSERT_FALSE(a->IsRunning()  );
a->Play();
startTime[0]=SystemClock->uptimeMillis()  ;
ASSERT_TRUE(a->IsRunning()  );
ASSERT_FALSE(a->IsRunning()  );
ASSERT_FALSE(a->IsRunning()  );
ASSERT_FALSE(a->IsRunning()  );
a->Play();
startTime[0]=SystemClock->uptimeMillis()  ;
ASSERT_TRUE(a->IsRunning()  );
ASSERT_FALSE(a->IsRunning()  );
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_FALSE(a->IsRunning()  );ASSERT_FALSE(a->IsRunning()  );a->Play();startTime[0]=SystemClock->uptimeMillis()  ;ASSERT_TRUE(a->IsRunning()  );ASSERT_FALSE(a->IsRunning()  ); }}  );
Thread->sleep(a->getTotalDuration()  );
ASSERT_TRUE(listener->wasRunning);
ASSERT_TRUE(listener->firstRunningFrameTime - startTime[0]   >= delay);
ASSERT_TRUE(listener->wasRunning);
ASSERT_TRUE(listener->firstRunningFrameTime - startTime[0]   >= delay);
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_TRUE(listener->wasRunning);ASSERT_TRUE(listener->firstRunningFrameTime - startTime[0]   >= delay); }}  );
Thread->sleep(a->getTotalDuration()  );
ASSERT_FALSE(a->IsRunning()  );
ASSERT_FALSE(a->IsRunning()  );
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_FALSE(a->IsRunning()  ); }}  );
ValueAnimatorTests::MyListener l1=new ValueAnimatorTests::MyListener()  ;
ValueAnimatorTests::MyListener l2=new ValueAnimatorTests::MyListener()  ;
a1->addListener(l1);
a2->addListener(l2);
a2->setStartDelay(400  );
ASSERT_FALSE(l1->startCalled);
ASSERT_FALSE(l1->cancelCalled);
ASSERT_FALSE(l1->endCalled);
ASSERT_FALSE(l2->startCalled);
ASSERT_FALSE(l2->cancelCalled);
ASSERT_FALSE(l2->endCalled);
a1->Play();
a2->Play();
a1->Play();
a2->Play();
mActivityRule->runOnUiThread(new Runnable(){void run() { a1->Play();a2->Play(); }}  );
long wait=0  ;
Thread->sleep(POLL_INTERVAL);
wait+=POLL_INTERVAL;
ASSERT_FALSE(l1->cancelCalled);
a1->cancel();
ASSERT_TRUE(l1->cancelCalled);
ASSERT_TRUE(l1->endCalled);
ASSERT_FALSE(l1->cancelCalled);
a1->cancel();
ASSERT_TRUE(l1->cancelCalled);
ASSERT_TRUE(l1->endCalled);
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_FALSE(l1->cancelCalled);a1->cancel();ASSERT_TRUE(l1->cancelCalled);ASSERT_TRUE(l1->endCalled); }}  );
ASSERT_TRUE(l1->startCalled);
ASSERT_FALSE(l2->startCalled);
ASSERT_TRUE(l1->startCalled);
ASSERT_FALSE(l2->startCalled);
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_TRUE(l1->startCalled);ASSERT_FALSE(l2->startCalled); }}  );
Thread->sleep(POLL_INTERVAL);
wait+=POLL_INTERVAL;
while(wait < a2->getStartDelay()  ){ mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_TRUE(l1->startCalled);ASSERT_FALSE(l2->startCalled); }}  );Thread->sleep(POLL_INTERVAL);wait+=POLL_INTERVAL; }
long delay=Math->max(a1->getTotalDuration()  ,a2->getTotalDuration()  )   + TOLERANCE;
Thread->sleep(delay);
ASSERT_TRUE(l1->startCalled);
ASSERT_TRUE(l1->cancelCalled);
ASSERT_TRUE(l1->endCalled);
ASSERT_TRUE(l2->startCalled);
ASSERT_FALSE(l2->cancelCalled);
ASSERT_TRUE(l2->endCalled);
ASSERT_TRUE(l1->startCalled);
ASSERT_TRUE(l1->cancelCalled);
ASSERT_TRUE(l1->endCalled);
ASSERT_TRUE(l2->startCalled);
ASSERT_FALSE(l2->cancelCalled);
ASSERT_TRUE(l2->endCalled);
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_TRUE(l1->startCalled);ASSERT_TRUE(l1->cancelCalled);ASSERT_TRUE(l1->endCalled);ASSERT_TRUE(l2->startCalled);ASSERT_FALSE(l2->cancelCalled);ASSERT_TRUE(l2->endCalled); }}  );
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a2->IsRunning()  );
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a2->IsRunning()  );
long startDelay=150  ;
a1->setStartDelay(startDelay);
long [] startTime= newlong[1] ;
a1->Play();
a2->Play();
startTime[0]=SystemClock->uptimeMillis()  ;
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a2->IsRunning()  );
a1->Play();
a2->Play();
startTime[0]=SystemClock->uptimeMillis()  ;
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a2->IsRunning()  );
mActivityRule->runOnUiThread(new Runnable(){void run() { a1->Play();a2->Play();startTime[0]=SystemClock->uptimeMillis()  ;ASSERT_TRUE(a1->IsRunning()  );ASSERT_TRUE(a2->IsRunning()  ); }}  );
long delayMs=0  ;
Thread->sleep(POLL_INTERVAL);
delayMs+=POLL_INTERVAL;
ASSERT_FALSE(a1->IsRunning()  );
if(SystemClock->uptimeMillis()   - startTime[0]   < startDelay){ ASSERT_FALSE(a1->IsRunning()  ); }
ASSERT_FALSE(a1->IsRunning()  );
if(SystemClock->uptimeMillis()   - startTime[0]   < startDelay){ ASSERT_FALSE(a1->IsRunning()  ); }
mActivityRule->runOnUiThread(new Runnable(){void run() { if(SystemClock->uptimeMillis()   - startTime[0]   < startDelay){ ASSERT_FALSE(a1->IsRunning()  ); } }}  );
while(delayMs < startDelay){ Thread->sleep(POLL_INTERVAL);delayMs+=POLL_INTERVAL;mActivityRule->runOnUiThread(new Runnable(){void run() { if(SystemClock->uptimeMillis()   - startTime[0]   < startDelay){ ASSERT_FALSE(a1->IsRunning()  ); } }}  ); }
Thread->sleep(startDelay);
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a2->IsRunning()  );
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a2->IsRunning()  );
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_TRUE(a1->IsRunning()  );ASSERT_TRUE(a2->IsRunning()  ); }}  );
long delay=Math->max(a1->getTotalDuration()  ,a2->getTotalDuration()  )   * 2  ;
Thread->sleep(delay);
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a2->IsRunning()  );
ASSERT_FALSE(a2->IsRunning()  );
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a2->IsRunning()  );
ASSERT_FALSE(a2->IsRunning()  );
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_FALSE(a1->IsRunning()  );ASSERT_FALSE(a1->IsRunning()  );ASSERT_FALSE(a2->IsRunning()  );ASSERT_FALSE(a2->IsRunning()  ); }}  );
ASSERT_FALSE(a1->IsPending()  );
ASSERT_FALSE(a2->IsPending()  );
a1->Play();
a2->Play();
ASSERT_FALSE(a1->IsPending()  );
ASSERT_FALSE(a2->IsPending()  );
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a2->IsRunning()  );
ASSERT_FALSE(a1->IsPending()  );
ASSERT_FALSE(a2->IsPending()  );
a1->Play();
a2->Play();
ASSERT_FALSE(a1->IsPending()  );
ASSERT_FALSE(a2->IsPending()  );
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a2->IsRunning()  );
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_FALSE(a1->IsPending()  );ASSERT_FALSE(a2->IsPending()  );a1->Play();a2->Play();ASSERT_FALSE(a1->IsPending()  );ASSERT_FALSE(a2->IsPending()  );ASSERT_TRUE(a1->IsRunning()  );ASSERT_TRUE(a2->IsRunning()  ); }}  );
Thread->sleep(POLL_INTERVAL);
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a2->IsRunning()  );
a1->Pause();
ASSERT_TRUE(a1->IsPending()  );
ASSERT_FALSE(a2->IsPending()  );
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a2->IsRunning()  );
a1->Pause();
ASSERT_TRUE(a1->IsPending()  );
ASSERT_FALSE(a2->IsPending()  );
ASSERT_TRUE(a1->IsRunning()  );
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_TRUE(a1->IsRunning()  );ASSERT_TRUE(a2->IsRunning()  );a1->Pause();ASSERT_TRUE(a1->IsPending()  );ASSERT_FALSE(a2->IsPending()  );ASSERT_TRUE(a1->IsRunning()  ); }}  );
Thread->sleep(a2->getTotalDuration()  );
ASSERT_FALSE(a2->IsRunning()  );
ASSERT_FALSE(a2->IsRunning()  );
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a1->IsPending()  );
a1->resume();
ASSERT_FALSE(a2->IsRunning()  );
ASSERT_FALSE(a2->IsRunning()  );
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a1->IsPending()  );
a1->resume();
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_FALSE(a2->IsRunning()  );ASSERT_FALSE(a2->IsRunning()  );ASSERT_TRUE(a1->IsRunning()  );ASSERT_TRUE(a1->IsRunning()  );ASSERT_TRUE(a1->IsPending()  );a1->resume(); }}  );
Thread->sleep(POLL_INTERVAL);
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_FALSE(a1->IsPending()  );
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_FALSE(a1->IsPending()  );
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_TRUE(a1->IsRunning()  );ASSERT_TRUE(a1->IsRunning()  );ASSERT_FALSE(a1->IsPending()  ); }}  );
Thread->sleep(a1->getTotalDuration()  );
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a1->IsPending()  );
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a1->IsPending()  );
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_FALSE(a1->IsRunning()  );ASSERT_FALSE(a1->IsRunning()  );ASSERT_FALSE(a1->IsPending()  ); }}  );
ValueAnimatorTests::MyPauseListener l1=new ValueAnimatorTests::MyPauseListener()  ;
ValueAnimatorTests::MyPauseListener l2=new ValueAnimatorTests::MyPauseListener()  ;
a1->addPauseListener(l1);
a2->addPauseListener(l2);
ASSERT_FALSE(l1->pauseCalled);
ASSERT_FALSE(l1->resumeCalled);
ASSERT_FALSE(l2->pauseCalled);
ASSERT_FALSE(l2->resumeCalled);
a1->Play();
a2->Play();
a1->Play();
a2->Play();
mActivityRule->runOnUiThread(new Runnable(){void run() { a1->Play();a2->Play(); }}  );
Thread->sleep(a1->getTotalDuration()   / 2  );
a1->Pause();
Thread->sleep(a2->getTotalDuration()  );
ASSERT_TRUE(l1->pauseCalled);
ASSERT_FALSE(l1->resumeCalled);
a1->resume();
a1->resume();
mActivityRule->runOnUiThread(new Runnable(){void run() { a1->resume(); }}  );
Thread->sleep(a1->getTotalDuration()  );
ASSERT_TRUE(l1->pauseCalled);
ASSERT_TRUE(l1->resumeCalled);
ASSERT_FALSE(l2->pauseCalled);
ASSERT_FALSE(l2->resumeCalled);
ValueAnimatorTests::MyUpdateListener l1=new ValueAnimatorTests::MyUpdateListener()  ;
long totalDuration=a1->getTotalDuration()  ;
a1->AddUpdateListener(l1);
a1->setDuration(1000  );
ASSERT_TRUE(l1->firstRunningFrameTime < 0  );
ASSERT_TRUE(l1->lastUpdateTime < 0  );
long [] lastUpdate= newlong[1] ;
a1->Play();
a1->Play();
mActivityRule->runOnUiThread(new Runnable(){void run() { a1->Play(); }}  );
Thread->sleep(totalDuration / 2  );
ASSERT_TRUE(l1->firstRunningFrameTime > 0  );
ASSERT_TRUE(l1->lastUpdateTime > l1->firstRunningFrameTime);
lastUpdate[0]=l1->lastUpdateTime;
a1->Pause();
ASSERT_TRUE(l1->firstRunningFrameTime > 0  );
ASSERT_TRUE(l1->lastUpdateTime > l1->firstRunningFrameTime);
lastUpdate[0]=l1->lastUpdateTime;
a1->Pause();
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_TRUE(l1->firstRunningFrameTime > 0  );ASSERT_TRUE(l1->lastUpdateTime > l1->firstRunningFrameTime);lastUpdate[0]=l1->lastUpdateTime;a1->Pause(); }}  );
Thread->sleep(totalDuration);
ASSERT_EQ(lastUpdate[0]  ,l1->lastUpdateTime);
a1->resume();
ASSERT_EQ(lastUpdate[0]  ,l1->lastUpdateTime);
a1->resume();
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_EQ(lastUpdate[0]  ,l1->lastUpdateTime);a1->resume(); }}  );
Thread->sleep(POLL_INTERVAL);
ASSERT_TRUE(l1->lastUpdateTime > lastUpdate[0]  );
lastUpdate[0]=l1->lastUpdateTime;
ASSERT_TRUE(l1->lastUpdateTime > lastUpdate[0]  );
lastUpdate[0]=l1->lastUpdateTime;
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_TRUE(l1->lastUpdateTime > lastUpdate[0]  );lastUpdate[0]=l1->lastUpdateTime; }}  );
do{ Thread->sleep(POLL_INTERVAL);mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_TRUE(l1->lastUpdateTime > lastUpdate[0]  );lastUpdate[0]=l1->lastUpdateTime; }}  ); }while(!a1->IsRunning()  );
long entireSpan=totalDuration * 2  ;
long frameDelta=l1->lastUpdateTime - l1->firstRunningFrameTime;
ASSERT_TRUE(Math->abs(entireSpan - frameDelta)   < TOLERANCE);
ValueAnimatorTests::MyListener l1=new ValueAnimatorTests::MyListener()  ;
ValueAnimatorTests::MyListener l2=new ValueAnimatorTests::MyListener()  ;
a1->addListener(l1);
a2->addListener(l2);
anim->Cancel();
anim->Cancel();
a1->addListener(new ValueAnimatorTests::MyListener(){void onAnimationEnd(ACE_EXPORTAnimator *  anim) { anim->Cancel(); }}  );
anim->end();
anim->end();
a2->addListener(new ValueAnimatorTests::MyListener(){void onAnimationCancel(ACE_EXPORTAnimator *  anim) { anim->end(); }}  );
ASSERT_FALSE(l1->cancelCalled);
ASSERT_FALSE(l1->endCalled);
ASSERT_FALSE(l2->cancelCalled);
ASSERT_FALSE(l2->endCalled);
a1->Play();
a2->Play();
ASSERT_FALSE(l1->cancelCalled);
ASSERT_FALSE(l1->endCalled);
ASSERT_FALSE(l2->cancelCalled);
ASSERT_FALSE(l2->endCalled);
a1->Play();
a2->Play();
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_FALSE(l1->cancelCalled);ASSERT_FALSE(l1->endCalled);ASSERT_FALSE(l2->cancelCalled);ASSERT_FALSE(l2->endCalled);a1->Play();a2->Play(); }}  );
Thread->sleep(POLL_INTERVAL);
a1->Stop();
a2->cancel();
a1->Stop();
a2->cancel();
mActivityRule->runOnUiThread(new Runnable(){void run() { a1->Stop();a2->cancel(); }}  );
Thread->sleep(POLL_INTERVAL);
ASSERT_FALSE(l1->cancelCalled);
ASSERT_TRUE(l1->endCalled);
ASSERT_TRUE(l2->cancelCalled);
ASSERT_TRUE(l2->endCalled);
float value1=(Float)a1.getAnimatedValue();
int value2=(Integer)a2.getAnimatedValue();
ASSERT_EQ(A1_END_VALUE,value1);
ASSERT_EQ(A2_END_VALUE,value2);
ASSERT_FALSE(l1->cancelCalled);
ASSERT_TRUE(l1->endCalled);
ASSERT_TRUE(l2->cancelCalled);
ASSERT_TRUE(l2->endCalled);
float value1=(Float)a1.getAnimatedValue();
int value2=(Integer)a2.getAnimatedValue();
ASSERT_EQ(A1_END_VALUE,value1);
ASSERT_EQ(A2_END_VALUE,value2);
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_FALSE(l1->cancelCalled);ASSERT_TRUE(l1->endCalled);ASSERT_TRUE(l2->cancelCalled);ASSERT_TRUE(l2->endCalled);float value1=(Float)a1.getAnimatedValue();int value2=(Integer)a2.getAnimatedValue();ASSERT_EQ(A1_END_VALUE,value1);ASSERT_EQ(A2_END_VALUE,value2); }}  );
ValueAnimatorTests::MyListener l1=new ValueAnimatorTests::MyListener()  ;
a1->addListener(l1);
ValueAnimatorTests::MyListener l2=new ValueAnimatorTests::MyListener()  ;
a2->addListener(l2);
a1->Play();
a2->Play();
a1->Play();
a2->Play();
mActivityRule->runOnUiThread(new Runnable(){void run() { a1->Play();a2->Play(); }}  );
Thread->sleep(POLL_INTERVAL);
ASSERT_FALSE(l1->endCalled);
ASSERT_FALSE(l2->endCalled);
assertNotEqual(A1_END_VALUE,a1->getAnimatedValue()  );
assertNotEqual(A1_END_VALUE,a2->getAnimatedValue()  );
a2->Stop();
ASSERT_FALSE(l1->endCalled);
ASSERT_FALSE(l2->endCalled);
assertNotEqual(A1_END_VALUE,a1->getAnimatedValue()  );
assertNotEqual(A1_END_VALUE,a2->getAnimatedValue()  );
a2->Stop();
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_FALSE(l1->endCalled);ASSERT_FALSE(l2->endCalled);assertNotEqual(A1_END_VALUE,a1->getAnimatedValue()  );assertNotEqual(A1_END_VALUE,a2->getAnimatedValue()  );a2->Stop(); }}  );
Thread->sleep(a1->getTotalDuration()  );
ASSERT_FALSE(l1->cancelCalled);
ASSERT_TRUE(l1->endCalled);
ASSERT_FALSE(l2->cancelCalled);
ASSERT_TRUE(l2->endCalled);
ASSERT_EQ(A1_END_VALUE,((Float)(a1.getAnimatedValue()))  -> floatValue());
ASSERT_EQ(A2_END_VALUE,((Integer)(a2.getAnimatedValue()))  -> intValue());
ASSERT_FALSE(l1->cancelCalled);
ASSERT_TRUE(l1->endCalled);
ASSERT_FALSE(l2->cancelCalled);
ASSERT_TRUE(l2->endCalled);
ASSERT_EQ(A1_END_VALUE,((Float)(a1.getAnimatedValue()))  -> floatValue());
ASSERT_EQ(A2_END_VALUE,((Integer)(a2.getAnimatedValue()))  -> intValue());
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_FALSE(l1->cancelCalled);ASSERT_TRUE(l1->endCalled);ASSERT_FALSE(l2->cancelCalled);ASSERT_TRUE(l2->endCalled);ASSERT_EQ(A1_END_VALUE,((Float)(a1.getAnimatedValue()))  -> floatValue());ASSERT_EQ(A2_END_VALUE,((Integer)(a2.getAnimatedValue()))  -> intValue()); }}  );
ValueAnimatorTests::MyFrameCallbackProvider provider=new ValueAnimatorTests::MyFrameCallbackProvider()  ;
long sleep=0  ;
Thread->sleep(POLL_INTERVAL);
sleep+=POLL_INTERVAL;
break;
if(sleep > WAIT_TIME_OUT){ break; }
while(provider->mHandler == null  ){ Thread->sleep(POLL_INTERVAL);sleep+=POLL_INTERVAL;if(sleep > WAIT_TIME_OUT){ break; } }
assertNotNull(provider->mHandler);
ValueAnimatorTests::MyListener listener=new ValueAnimatorTests::MyListener()  ;
long currentTime=SystemClock->uptimeMillis()  ;
long frameDelay=provider->getFrameDelay()  ;
ASSERT_TRUE((currentTime-lastUpdateTime)   < frameDelay * 4  );
ASSERT_TRUE(listener->startCalled);
ASSERT_TRUE(listener->startTime > 0  );
ASSERT_TRUE(currentTime - listener->startTime < frameDelay * 4  );
if(lastUpdateTime > 0  ){ ASSERT_TRUE((currentTime-lastUpdateTime)   < frameDelay * 4  ); }else{ ASSERT_TRUE(listener->startCalled);ASSERT_TRUE(listener->startTime > 0  );ASSERT_TRUE(currentTime - listener->startTime < frameDelay * 4  ); }
super-> onAnimationUpdate(animation);
ValueAnimatorTests::MyUpdateListener l1=new ValueAnimatorTests::MyUpdateListener(){void onAnimationUpdate(ACE_EXPORTAnimator *  animation) { long currentTime=SystemClock->uptimeMillis()  ;long frameDelay=provider->getFrameDelay()  ;if(lastUpdateTime > 0  ){ ASSERT_TRUE((currentTime-lastUpdateTime)   < frameDelay * 4  ); }else{ ASSERT_TRUE(listener->startCalled);ASSERT_TRUE(listener->startTime > 0  );ASSERT_TRUE(currentTime - listener->startTime < frameDelay * 4  ); }super-> onAnimationUpdate(animation); }}  ;
a1->AddUpdateListener(l1);
a1->addListener(listener);
a1->setStartDelay(100  );
AnimationHandler->getInstance()  -> setProvider(provider);
a1->Play();
AnimationHandler->getInstance()  -> setProvider(provider);
a1->Play();
provider.mHandler->post(new Runnable(){void run() { AnimationHandler->getInstance()  -> setProvider(provider);a1->Play(); }}  );
Thread->sleep(POLL_INTERVAL);
ASSERT_TRUE(a1->IsRunning()  );
Thread->sleep(a1->getTotalDuration()   + TOLERANCE);
throwprovider->mAssertionError;
if(provider->mAssertionError != null  ){ throwprovider->mAssertionError; }
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_TRUE(listener->endTime > 0  );
ASSERT_TRUE(listener->endTime >= l1->lastUpdateTime);
ASSERT_TRUE(listener->endTime - l1->lastUpdateTime < 2   * provider->getFrameDelay()  );
ACE_EXPORTAnimator *  a0=ValueAnimator->ofInt(100  ,200  )  -> setDuration(500  );
ACE_EXPORTAnimator *  a3=ValueAnimator->ofFloat(0  ,1  )  -> setDuration(500  );
ACE_EXPORTAnimator *  a4=ValueAnimator->ofInt(200  ,300  )  -> setDuration(500  );
super-> onAnimationEnd(anim);
a0->cancel();
a1->Stop();
a3->Stop();
a4->cancel();
ValueAnimatorTests::MyListener listener=new ValueAnimatorTests::MyListener(){void onAnimationEnd(ACE_EXPORTAnimator *  anim) { super-> onAnimationEnd(anim);a0->cancel();a1->Stop();a3->Stop();a4->cancel(); }}  ;
a2->addListener(listener);
a0->Play();
a1->Play();
a2->Play();
a3->Play();
a4->Play();
a0->Play();
a1->Play();
a2->Play();
a3->Play();
a4->Play();
mActivityRule->runOnUiThread(new Runnable(){void run() { a0->Play();a1->Play();a2->Play();a3->Play();a4->Play(); }}  );
ASSERT_TRUE(a0->IsRunning()  );
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a2->IsRunning()  );
ASSERT_TRUE(a3->IsRunning()  );
ASSERT_TRUE(a4->IsRunning()  );
ASSERT_TRUE(a0->IsRunning()  );
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a2->IsRunning()  );
ASSERT_TRUE(a3->IsRunning()  );
ASSERT_TRUE(a4->IsRunning()  );
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_TRUE(a0->IsRunning()  );ASSERT_TRUE(a1->IsRunning()  );ASSERT_TRUE(a2->IsRunning()  );ASSERT_TRUE(a3->IsRunning()  );ASSERT_TRUE(a4->IsRunning()  ); }}  );
Thread->sleep(POLL_INTERVAL);
a2->Stop();
a2->Stop();
mActivityRule->runOnUiThread(new Runnable(){void run() { a2->Stop(); }}  );
Thread->sleep(POLL_INTERVAL);
ASSERT_TRUE(listener->endCalled);
ASSERT_FALSE(a0->IsRunning()  );
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a2->IsRunning()  );
ASSERT_FALSE(a3->IsRunning()  );
ASSERT_FALSE(a4->IsRunning()  );
ValueAnimatorTests::MyListener l1=new ValueAnimatorTests::MyListener()  ;
ValueAnimatorTests::MyListener l2=new ValueAnimatorTests::MyListener()  ;
ValueAnimatorTests::MyUpdateListener updateListener1=new ValueAnimatorTests::MyUpdateListener()  ;
ValueAnimatorTests::MyUpdateListener updateListener2=new ValueAnimatorTests::MyUpdateListener()  ;
float a1StartFraction=0.2f  ;
float a2StartFraction=0.3f  ;
a1->setDuration(1000  );
a2->setDuration(1000  );
a1->addListener(l1);
a2->addListener(l2);
a1->AddUpdateListener(updateListener1);
a2->AddUpdateListener(updateListener2);
//以下组件没有匹配:
//TimeInterpolator,LinearInterpolator
TimeInterpolator *  interpolator=new LinearInterpolator()  ;
a1->setInterpolator(interpolator);
a2->setInterpolator(interpolator);
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a2->IsRunning()  );
ASSERT_FALSE(a2->IsRunning()  );
a1->setCurrentFraction(a1StartFraction);
a2->setCurrentFraction(a2StartFraction);
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a2->IsRunning()  );
ASSERT_FALSE(a2->IsRunning()  );
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a2->IsRunning()  );
ASSERT_FALSE(a2->IsRunning()  );
a1->setCurrentFraction(a1StartFraction);
a2->setCurrentFraction(a2StartFraction);
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a2->IsRunning()  );
ASSERT_FALSE(a2->IsRunning()  );
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_FALSE(a1->IsRunning()  );ASSERT_FALSE(a1->IsRunning()  );ASSERT_FALSE(a2->IsRunning()  );ASSERT_FALSE(a2->IsRunning()  );a1->setCurrentFraction(a1StartFraction);a2->setCurrentFraction(a2StartFraction);ASSERT_FALSE(a1->IsRunning()  );ASSERT_FALSE(a1->IsRunning()  );ASSERT_FALSE(a2->IsRunning()  );ASSERT_FALSE(a2->IsRunning()  ); }}  );
Thread->sleep(POLL_INTERVAL);
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a2->IsRunning()  );
ASSERT_FALSE(a2->IsRunning()  );
ASSERT_EQ(a1StartFraction,a1->getAnimatedFraction()  );
ASSERT_EQ(a2StartFraction,a2->getAnimatedFraction()  );
a1->Play();
a2->Play();
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a2->IsRunning()  );
ASSERT_FALSE(a2->IsRunning()  );
ASSERT_EQ(a1StartFraction,a1->getAnimatedFraction()  );
ASSERT_EQ(a2StartFraction,a2->getAnimatedFraction()  );
a1->Play();
a2->Play();
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_FALSE(a1->IsRunning()  );ASSERT_FALSE(a1->IsRunning()  );ASSERT_FALSE(a2->IsRunning()  );ASSERT_FALSE(a2->IsRunning()  );ASSERT_EQ(a1StartFraction,a1->getAnimatedFraction()  );ASSERT_EQ(a2StartFraction,a2->getAnimatedFraction()  );a1->Play();a2->Play(); }}  );
Thread->sleep(POLL_INTERVAL);
float halfwayFraction=0.5f  ;
ASSERT_TRUE(l1->startCalled);
ASSERT_TRUE(l2->startCalled);
ASSERT_FALSE(l1->endCalled);
ASSERT_FALSE(l2->endCalled);
ASSERT_TRUE(updateListener1->startFraction >= a1StartFraction);
ASSERT_TRUE(updateListener2->startFraction >= a2StartFraction);
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a2->IsRunning()  );
ASSERT_TRUE(a2->IsRunning()  );
a1->setCurrentFraction(halfwayFraction);
a2->setCurrentFraction(halfwayFraction);
ASSERT_TRUE(l1->startCalled);
ASSERT_TRUE(l2->startCalled);
ASSERT_FALSE(l1->endCalled);
ASSERT_FALSE(l2->endCalled);
ASSERT_TRUE(updateListener1->startFraction >= a1StartFraction);
ASSERT_TRUE(updateListener2->startFraction >= a2StartFraction);
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a2->IsRunning()  );
ASSERT_TRUE(a2->IsRunning()  );
a1->setCurrentFraction(halfwayFraction);
a2->setCurrentFraction(halfwayFraction);
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_TRUE(l1->startCalled);ASSERT_TRUE(l2->startCalled);ASSERT_FALSE(l1->endCalled);ASSERT_FALSE(l2->endCalled);ASSERT_TRUE(updateListener1->startFraction >= a1StartFraction);ASSERT_TRUE(updateListener2->startFraction >= a2StartFraction);ASSERT_TRUE(a1->IsRunning()  );ASSERT_TRUE(a1->IsRunning()  );ASSERT_TRUE(a2->IsRunning()  );ASSERT_TRUE(a2->IsRunning()  );a1->setCurrentFraction(halfwayFraction);a2->setCurrentFraction(halfwayFraction); }}  );
Thread->sleep(POLL_INTERVAL);
ASSERT_TRUE(l1->startCalled);
ASSERT_TRUE(l2->startCalled);
ASSERT_FALSE(l1->endCalled);
ASSERT_FALSE(l2->endCalled);
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a2->IsRunning()  );
ASSERT_TRUE(a2->IsRunning()  );
ASSERT_TRUE(l1->startCalled);
ASSERT_TRUE(l2->startCalled);
ASSERT_FALSE(l1->endCalled);
ASSERT_FALSE(l2->endCalled);
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a2->IsRunning()  );
ASSERT_TRUE(a2->IsRunning()  );
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_TRUE(l1->startCalled);ASSERT_TRUE(l2->startCalled);ASSERT_FALSE(l1->endCalled);ASSERT_FALSE(l2->endCalled);ASSERT_TRUE(a1->IsRunning()  );ASSERT_TRUE(a1->IsRunning()  );ASSERT_TRUE(a2->IsRunning()  );ASSERT_TRUE(a2->IsRunning()  ); }}  );
long wait=Math->max(a1->getTotalDuration()  ,a2->getTotalDuration()  )  ;
Thread->sleep(wait);
ASSERT_TRUE(l1->endCalled);
ASSERT_TRUE(l2->endCalled);
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a2->IsRunning()  );
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a2->IsRunning()  );
ASSERT_TRUE(l1->endCalled);
ASSERT_TRUE(l2->endCalled);
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a2->IsRunning()  );
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a2->IsRunning()  );
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_TRUE(l1->endCalled);ASSERT_TRUE(l2->endCalled);ASSERT_FALSE(a1->IsRunning()  );ASSERT_FALSE(a2->IsRunning()  );ASSERT_FALSE(a1->IsRunning()  );ASSERT_FALSE(a2->IsRunning()  ); }}  );
updateListener1->reset();
a1->Play();
a1->Play();
mActivityRule->runOnUiThread(new Runnable(){void run() { a1->Play(); }}  );
Thread->sleep(POLL_INTERVAL);
ASSERT_TRUE(updateListener1->wasRunning);
ASSERT_TRUE(updateListener1->startFraction >= 0  );
ASSERT_TRUE(updateListener1->startFraction < halfwayFraction);
a1->Stop();
ASSERT_TRUE(updateListener1->wasRunning);
ASSERT_TRUE(updateListener1->startFraction >= 0  );
ASSERT_TRUE(updateListener1->startFraction < halfwayFraction);
a1->Stop();
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_TRUE(updateListener1->wasRunning);ASSERT_TRUE(updateListener1->startFraction >= 0  );ASSERT_TRUE(updateListener1->startFraction < halfwayFraction);a1->Stop(); }}  );
ValueAnimatorTests::MyListener l1=new ValueAnimatorTests::MyListener()  ;
ValueAnimatorTests::MyListener l2=new ValueAnimatorTests::MyListener()  ;
a1->addListener(l1);
a2->addListener(l2);
ASSERT_FALSE(l1->startCalled);
ASSERT_FALSE(l2->startCalled);
ASSERT_EQ(0f  ,a1->getAnimatedFraction()  );
ASSERT_EQ(0f  ,a2->getAnimatedFraction()  );
a1->Play();
a2->Play();
ASSERT_FALSE(l1->startCalled);
ASSERT_FALSE(l2->startCalled);
ASSERT_EQ(0f  ,a1->getAnimatedFraction()  );
ASSERT_EQ(0f  ,a2->getAnimatedFraction()  );
a1->Play();
a2->Play();
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_FALSE(l1->startCalled);ASSERT_FALSE(l2->startCalled);ASSERT_EQ(0f  ,a1->getAnimatedFraction()  );ASSERT_EQ(0f  ,a2->getAnimatedFraction()  );a1->Play();a2->Play(); }}  );
Thread->sleep(POLL_INTERVAL);
ASSERT_FALSE(l1->endCalled);
ASSERT_FALSE(l2->endCalled);
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a2->IsRunning()  );
a1->setCurrentFraction(0f  );
a2->setCurrentFraction(1f  );
ASSERT_FALSE(l1->endCalled);
ASSERT_FALSE(l2->endCalled);
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a2->IsRunning()  );
a1->setCurrentFraction(0f  );
a2->setCurrentFraction(1f  );
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_FALSE(l1->endCalled);ASSERT_FALSE(l2->endCalled);ASSERT_TRUE(a1->IsRunning()  );ASSERT_TRUE(a2->IsRunning()  );a1->setCurrentFraction(0f  );a2->setCurrentFraction(1f  ); }}  );
Thread->sleep(POLL_INTERVAL);
ASSERT_FALSE(l1->endCalled);
ASSERT_TRUE(l2->endCalled);
ASSERT_EQ(1f  ,a2->getAnimatedFraction()  );
ASSERT_FALSE(l1->endCalled);
ASSERT_TRUE(l2->endCalled);
ASSERT_EQ(1f  ,a2->getAnimatedFraction()  );
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_FALSE(l1->endCalled);ASSERT_TRUE(l2->endCalled);ASSERT_EQ(1f  ,a2->getAnimatedFraction()  ); }}  );
Thread->sleep(a1->getTotalDuration()  );
ASSERT_TRUE(l1->endCalled);
ASSERT_EQ(1f  ,a1->getAnimatedFraction()  );
ASSERT_TRUE(l1->endCalled);
ASSERT_EQ(1f  ,a1->getAnimatedFraction()  );
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_TRUE(l1->endCalled);ASSERT_EQ(1f  ,a1->getAnimatedFraction()  ); }}  );
a1->setStartDelay(20  );
ValueAnimatorTests::MyListener normalEndingListener=new ValueAnimatorTests::MyListener()  ;
a1->addListener(normalEndingListener);
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(normalEndingListener->startCalled);
ASSERT_FALSE(normalEndingListener->endCalled);
a1->Play();
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(normalEndingListener->startCalled);
ASSERT_FALSE(normalEndingListener->endCalled);
a1->Play();
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_FALSE(a1->IsRunning()  );ASSERT_FALSE(normalEndingListener->startCalled);ASSERT_FALSE(normalEndingListener->endCalled);a1->Play(); }}  );
Thread->sleep(a1->getTotalDuration()   + POLL_INTERVAL);
ValueAnimatorTests::MyListener l1=new ValueAnimatorTests::MyListener()  ;
a1->addListener(l1);
ValueAnimatorTests::MyListener l2=new ValueAnimatorTests::MyListener()  ;
a2->addListener(l2);
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(l1->startCalled);
ASSERT_FALSE(l1->endCalled);
ASSERT_FALSE(a2->IsRunning()  );
ASSERT_FALSE(l2->startCalled);
ASSERT_FALSE(l1->endCalled);
a1->Stop();
a2->Stop();
ASSERT_TRUE(l1->startCalled);
ASSERT_TRUE(l1->endCalled);
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_TRUE(l1->endTime >= l1->startTime);
ASSERT_TRUE(l2->startCalled);
ASSERT_TRUE(l2->endCalled);
ASSERT_FALSE(a2->IsRunning()  );
ASSERT_TRUE(l2->endTime >= l1->startTime);
ValueAnimatorTests::MyListener l1=new ValueAnimatorTests::MyListener()  ;
a1->addListener(l1);
ValueAnimatorTests::MyListener l2=new ValueAnimatorTests::MyListener()  ;
a2->addListener(l2);
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(l1->startCalled);
ASSERT_FALSE(l1->endCalled);
ASSERT_FALSE(a2->IsRunning()  );
ASSERT_FALSE(l2->startCalled);
ASSERT_FALSE(l1->endCalled);
a1->Stop();
a2->Stop();
ASSERT_TRUE(l1->startCalled);
ASSERT_TRUE(l1->endCalled);
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_TRUE(l1->endTime >= l1->startTime);
ASSERT_TRUE(l2->startCalled);
ASSERT_TRUE(l2->endCalled);
ASSERT_FALSE(a2->IsRunning()  );
ASSERT_TRUE(l2->endTime >= l1->startTime);
mActivityRule->runOnUiThread(new Runnable(){void run() { ValueAnimatorTests::MyListener l1=new ValueAnimatorTests::MyListener()  ;a1->addListener(l1);ValueAnimatorTests::MyListener l2=new ValueAnimatorTests::MyListener()  ;a2->addListener(l2);ASSERT_FALSE(a1->IsRunning()  );ASSERT_FALSE(l1->startCalled);ASSERT_FALSE(l1->endCalled);ASSERT_FALSE(a2->IsRunning()  );ASSERT_FALSE(l2->startCalled);ASSERT_FALSE(l1->endCalled);a1->Stop();a2->Stop();ASSERT_TRUE(l1->startCalled);ASSERT_TRUE(l1->endCalled);ASSERT_FALSE(a1->IsRunning()  );ASSERT_TRUE(l1->endTime >= l1->startTime);ASSERT_TRUE(l2->startCalled);ASSERT_TRUE(l2->endCalled);ASSERT_FALSE(a2->IsRunning()  );ASSERT_TRUE(l2->endTime >= l1->startTime); }}  );
a1->setDuration(0  );
a2->setDuration(0  );
ACE_EXPORTAnimator *  a3=ValueAnimator->ofInt(0  ,100  )  ;
a3->setDuration(0  );
a3->setCurrentFraction(1.0f  );
ASSERT_EQ(1.0f  ,a3->getAnimatedFraction()  );
ValueAnimatorTests::MyListener l1=new ValueAnimatorTests::MyListener()  ;
ValueAnimatorTests::MyListener l2=new ValueAnimatorTests::MyListener()  ;
ValueAnimatorTests::MyListener l3=new ValueAnimatorTests::MyListener()  ;
a1->addListener(l1);
a2->addListener(l2);
a3->addListener(l3);
ASSERT_FALSE(l1->startCalled);
ASSERT_FALSE(l2->startCalled);
ASSERT_FALSE(l3->startCalled);
ASSERT_FALSE(l1->endCalled);
ASSERT_FALSE(l2->endCalled);
ASSERT_FALSE(l3->endCalled);
a1->Play();
a2->reverse();
a3->Play();
ASSERT_EQ(A1_END_VALUE,a1->getAnimatedValue()  );
ASSERT_EQ(A2_START_VALUE,a2->getAnimatedValue()  );
ASSERT_FALSE(l1->startCalled);
ASSERT_FALSE(l2->startCalled);
ASSERT_FALSE(l3->startCalled);
ASSERT_FALSE(l1->endCalled);
ASSERT_FALSE(l2->endCalled);
ASSERT_FALSE(l3->endCalled);
a1->Play();
a2->reverse();
a3->Play();
ASSERT_EQ(A1_END_VALUE,a1->getAnimatedValue()  );
ASSERT_EQ(A2_START_VALUE,a2->getAnimatedValue()  );
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_FALSE(l1->startCalled);ASSERT_FALSE(l2->startCalled);ASSERT_FALSE(l3->startCalled);ASSERT_FALSE(l1->endCalled);ASSERT_FALSE(l2->endCalled);ASSERT_FALSE(l3->endCalled);a1->Play();a2->reverse();a3->Play();ASSERT_EQ(A1_END_VALUE,a1->getAnimatedValue()  );ASSERT_EQ(A2_START_VALUE,a2->getAnimatedValue()  ); }}  );
Thread->sleep(POLL_INTERVAL);
ASSERT_TRUE(l1->startCalled);
ASSERT_TRUE(l2->startCalled);
ASSERT_TRUE(l3->startCalled);
ASSERT_TRUE(l1->endCalled);
ASSERT_TRUE(l2->endCalled);
ASSERT_TRUE(l3->endCalled);
ASSERT_EQ(1.0f  ,a1->getAnimatedFraction()  );
ASSERT_EQ(0f  ,a2->getAnimatedFraction()  );
ASSERT_EQ(1f  ,a3->getAnimatedFraction()  );
ASSERT_EQ(A1_END_VALUE,a1->getAnimatedValue()  );
ASSERT_EQ(A2_START_VALUE,a2->getAnimatedValue()  );
ASSERT_EQ(100  ,a3->getAnimatedValue()  );
ASSERT_TRUE(l1->startCalled);
ASSERT_TRUE(l2->startCalled);
ASSERT_TRUE(l3->startCalled);
ASSERT_TRUE(l1->endCalled);
ASSERT_TRUE(l2->endCalled);
ASSERT_TRUE(l3->endCalled);
ASSERT_EQ(1.0f  ,a1->getAnimatedFraction()  );
ASSERT_EQ(0f  ,a2->getAnimatedFraction()  );
ASSERT_EQ(1f  ,a3->getAnimatedFraction()  );
ASSERT_EQ(A1_END_VALUE,a1->getAnimatedValue()  );
ASSERT_EQ(A2_START_VALUE,a2->getAnimatedValue()  );
ASSERT_EQ(100  ,a3->getAnimatedValue()  );
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_TRUE(l1->startCalled);ASSERT_TRUE(l2->startCalled);ASSERT_TRUE(l3->startCalled);ASSERT_TRUE(l1->endCalled);ASSERT_TRUE(l2->endCalled);ASSERT_TRUE(l3->endCalled);ASSERT_EQ(1.0f  ,a1->getAnimatedFraction()  );ASSERT_EQ(0f  ,a2->getAnimatedFraction()  );ASSERT_EQ(1f  ,a3->getAnimatedFraction()  );ASSERT_EQ(A1_END_VALUE,a1->getAnimatedValue()  );ASSERT_EQ(A2_START_VALUE,a2->getAnimatedValue()  );ASSERT_EQ(100  ,a3->getAnimatedValue()  ); }}  );
float scale=ValueAnimator->getDurationScale()  ;
ValueAnimator->setDurationScale(0f  );
a1->setStartDelay(200  );
ValueAnimatorTests::MyListener l1=new ValueAnimatorTests::MyListener()  ;
ValueAnimatorTests::MyListener l2=new ValueAnimatorTests::MyListener()  ;
a1->addListener(l1);
a2->addListener(l2);
ASSERT_FALSE(l1->startCalled);
ASSERT_FALSE(l2->startCalled);
ASSERT_FALSE(l1->endCalled);
ASSERT_FALSE(l2->endCalled);
a1->Play();
a2->Play();
ASSERT_EQ(A2_START_VALUE,a2->getAnimatedValue()  );
ASSERT_FALSE(l1->startCalled);
ASSERT_FALSE(l2->startCalled);
ASSERT_FALSE(l1->endCalled);
ASSERT_FALSE(l2->endCalled);
a1->Play();
a2->Play();
ASSERT_EQ(A2_START_VALUE,a2->getAnimatedValue()  );
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_FALSE(l1->startCalled);ASSERT_FALSE(l2->startCalled);ASSERT_FALSE(l1->endCalled);ASSERT_FALSE(l2->endCalled);a1->Play();a2->Play();ASSERT_EQ(A2_START_VALUE,a2->getAnimatedValue()  ); }}  );
Thread->sleep(POLL_INTERVAL);
ASSERT_TRUE(l1->startCalled);
ASSERT_TRUE(l2->startCalled);
ASSERT_TRUE(l1->endCalled);
ASSERT_TRUE(l2->endCalled);
ASSERT_EQ(A1_END_VALUE,a1->getAnimatedValue()  );
ASSERT_EQ(A2_END_VALUE,a2->getAnimatedValue()  );
ASSERT_TRUE(l1->startCalled);
ASSERT_TRUE(l2->startCalled);
ASSERT_TRUE(l1->endCalled);
ASSERT_TRUE(l2->endCalled);
ASSERT_EQ(A1_END_VALUE,a1->getAnimatedValue()  );
ASSERT_EQ(A2_END_VALUE,a2->getAnimatedValue()  );
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_TRUE(l1->startCalled);ASSERT_TRUE(l2->startCalled);ASSERT_TRUE(l1->endCalled);ASSERT_TRUE(l2->endCalled);ASSERT_EQ(A1_END_VALUE,a1->getAnimatedValue()  );ASSERT_EQ(A2_END_VALUE,a2->getAnimatedValue()  ); }}  );
ValueAnimator->setDurationScale(scale);
ACE_EXPORTAnimator *  a3=ValueAnimator->ofInt(0  ,100  )  ;
a1->setDuration(400  );
a2->setDuration(600  );
a3->setDuration(400  );
ValueAnimatorTests::MyListener l1=new ValueAnimatorTests::MyListener()  ;
ValueAnimatorTests::MyListener l2=new ValueAnimatorTests::MyListener()  ;
ValueAnimatorTests::MyListener l3=new ValueAnimatorTests::MyListener()  ;
a1->addListener(l1);
a2->addListener(l2);
a3->addListener(l3);
ASSERT_FALSE(l1->startCalled);
ASSERT_FALSE(l2->startCalled);
ASSERT_FALSE(l3->startCalled);
ASSERT_FALSE(l1->endCalled);
ASSERT_FALSE(l2->endCalled);
ASSERT_FALSE(l3->endCalled);
a1->reverse();
a2->reverse();
a3->reverse();
ASSERT_FALSE(l1->startCalled);
ASSERT_FALSE(l2->startCalled);
ASSERT_FALSE(l3->startCalled);
ASSERT_FALSE(l1->endCalled);
ASSERT_FALSE(l2->endCalled);
ASSERT_FALSE(l3->endCalled);
a1->reverse();
a2->reverse();
a3->reverse();
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_FALSE(l1->startCalled);ASSERT_FALSE(l2->startCalled);ASSERT_FALSE(l3->startCalled);ASSERT_FALSE(l1->endCalled);ASSERT_FALSE(l2->endCalled);ASSERT_FALSE(l3->endCalled);a1->reverse();a2->reverse();a3->reverse(); }}  );
Thread->sleep(POLL_INTERVAL);
ASSERT_TRUE(l1->startCalled);
ASSERT_TRUE(l2->startCalled);
ASSERT_TRUE(l3->startCalled);
a1->setCurrentFraction(0f  );
a2->setCurrentFraction(1f  );
a3->Stop();
ASSERT_EQ(1f  ,a1->getAnimatedFraction()  );
ASSERT_EQ(0f  ,a2->getAnimatedFraction()  );
ASSERT_TRUE(l1->startCalled);
ASSERT_TRUE(l2->startCalled);
ASSERT_TRUE(l3->startCalled);
a1->setCurrentFraction(0f  );
a2->setCurrentFraction(1f  );
a3->Stop();
ASSERT_EQ(1f  ,a1->getAnimatedFraction()  );
ASSERT_EQ(0f  ,a2->getAnimatedFraction()  );
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_TRUE(l1->startCalled);ASSERT_TRUE(l2->startCalled);ASSERT_TRUE(l3->startCalled);a1->setCurrentFraction(0f  );a2->setCurrentFraction(1f  );a3->Stop();ASSERT_EQ(1f  ,a1->getAnimatedFraction()  );ASSERT_EQ(0f  ,a2->getAnimatedFraction()  ); }}  );
Thread->sleep(POLL_INTERVAL);
ASSERT_FALSE(l1->endCalled);
ASSERT_TRUE(l2->endCalled);
ASSERT_TRUE(l3->endCalled);
ASSERT_FALSE(l1->endCalled);
ASSERT_TRUE(l2->endCalled);
ASSERT_TRUE(l3->endCalled);
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_FALSE(l1->endCalled);ASSERT_TRUE(l2->endCalled);ASSERT_TRUE(l3->endCalled); }}  );
Thread->sleep(a1->getTotalDuration()  );
ASSERT_TRUE(l1->endCalled);
ASSERT_EQ(0f  ,a1->getAnimatedFraction()  );
ASSERT_EQ(0f  ,a2->getAnimatedFraction()  );
ASSERT_EQ(0f  ,a3->getAnimatedFraction()  );
ASSERT_TRUE(l1->endCalled);
ASSERT_EQ(0f  ,a1->getAnimatedFraction()  );
ASSERT_EQ(0f  ,a2->getAnimatedFraction()  );
ASSERT_EQ(0f  ,a3->getAnimatedFraction()  );
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_TRUE(l1->endCalled);ASSERT_EQ(0f  ,a1->getAnimatedFraction()  );ASSERT_EQ(0f  ,a2->getAnimatedFraction()  );ASSERT_EQ(0f  ,a3->getAnimatedFraction()  ); }}  );
}
//以下组件没有匹配:
//Runnable
void run()
{
lastUpdateTime=SystemClock->uptimeMillis()  ;
firstRunningFrameTime=lastUpdateTime;
startFraction=animation->getAnimatedFraction()  ;
wasRunning=animation->isRunning()  ;
if(animation->isRunning()   && !wasRunning){ firstRunningFrameTime=lastUpdateTime;startFraction=animation->getAnimatedFraction()  ;wasRunning=animation->isRunning()  ; }
wasRunning=false  ;
firstRunningFrameTime=-1  ;
lastUpdateTime=-1  ;
startFraction=0  ;
startCalled=true  ;
startTime=SystemClock->uptimeMillis()  ;
endCalled=true  ;
endTime=SystemClock->uptimeMillis()  ;
cancelCalled=true  ;
pauseCalled=true  ;
resumeCalled=true  ;
mHandler->sendEmptyMessageDelayed(MSG_FRAME,mFrameDelay);
mFrameCallbacks->add(callback);
if(!mFrameCallbacks->contains(callback)  ){ mFrameCallbacks->add(callback); }
mHandler->postDelayed(runnable,COMMIT_DELAY);
return SystemClock->uptimeMillis()  ;
return mFrameDelay;
mFrameDelay=delay;
mHandler->removeMessages(MSG_FRAME);
mHandler->sendEmptyMessageDelayed(MSG_FRAME,mFrameDelay);
if(mFrameCallbacks->size()   != 0  ){ mHandler->removeMessages(MSG_FRAME);mHandler->sendEmptyMessageDelayed(MSG_FRAME,mFrameDelay); }
Looper->prepare();
mFrameCallbacks->get(i)  -> doFrame(SystemClock->uptimeMillis()  );
for(int i=0  ;i < mFrameCallbacks->size()  ;i++){ mFrameCallbacks->get(i)  -> doFrame(SystemClock->uptimeMillis()  ); }
break;
break;
switch(msg->what){caseMSG_FRAME: for(int i=0  ;i < mFrameCallbacks->size()  ;i++){ mFrameCallbacks->get(i)  -> doFrame(SystemClock->uptimeMillis()  ); }break; default: break; }
{ switch(msg->what){caseMSG_FRAME: for(int i=0  ;i < mFrameCallbacks->size()  ;i++){ mFrameCallbacks->get(i)  -> doFrame(SystemClock->uptimeMillis()  ); }break; default: break; } }
mHandler=new Handler(){void handleMessage(Message *  msg) { { switch(msg->what){caseMSG_FRAME: for(int i=0  ;i < mFrameCallbacks->size()  ;i++){ mFrameCallbacks->get(i)  -> doFrame(SystemClock->uptimeMillis()  ); }break; default: break; } } }}  ;
Looper->loop();
a1=ValueAnimator->ofFloat(A1_START_VALUE,A1_END_VALUE)  -> setDuration(300  );
a2=ValueAnimator->ofInt(A2_START_VALUE,A2_END_VALUE)  -> setDuration(500  );
a1=null  ;
a2=null  ;
ACE_EXPORTAnimator *  a=ValueAnimator->ofFloat(5f  ,20f  )  ;
ASSERT_EQ(a->getStartDelay()  ,0  );
long delay=200  ;
a->setStartDelay(delay);
ASSERT_EQ(a->getStartDelay()  ,delay);
ValueAnimatorTests::MyUpdateListener listener=new ValueAnimatorTests::MyUpdateListener()  ;
a->AddUpdateListener(listener);
long [] startTime= newlong[1] ;
ASSERT_FALSE(a->IsRunning()  );
ASSERT_FALSE(a->IsRunning()  );
a->Play();
startTime[0]=SystemClock->uptimeMillis()  ;
ASSERT_TRUE(a->IsRunning()  );
ASSERT_FALSE(a->IsRunning()  );
ASSERT_FALSE(a->IsRunning()  );
ASSERT_FALSE(a->IsRunning()  );
a->Play();
startTime[0]=SystemClock->uptimeMillis()  ;
ASSERT_TRUE(a->IsRunning()  );
ASSERT_FALSE(a->IsRunning()  );
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_FALSE(a->IsRunning()  );ASSERT_FALSE(a->IsRunning()  );a->Play();startTime[0]=SystemClock->uptimeMillis()  ;ASSERT_TRUE(a->IsRunning()  );ASSERT_FALSE(a->IsRunning()  ); }}  );
Thread->sleep(a->getTotalDuration()  );
ASSERT_TRUE(listener->wasRunning);
ASSERT_TRUE(listener->firstRunningFrameTime - startTime[0]   >= delay);
ASSERT_TRUE(listener->wasRunning);
ASSERT_TRUE(listener->firstRunningFrameTime - startTime[0]   >= delay);
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_TRUE(listener->wasRunning);ASSERT_TRUE(listener->firstRunningFrameTime - startTime[0]   >= delay); }}  );
Thread->sleep(a->getTotalDuration()  );
ASSERT_FALSE(a->IsRunning()  );
ASSERT_FALSE(a->IsRunning()  );
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_FALSE(a->IsRunning()  ); }}  );
ValueAnimatorTests::MyListener l1=new ValueAnimatorTests::MyListener()  ;
ValueAnimatorTests::MyListener l2=new ValueAnimatorTests::MyListener()  ;
a1->addListener(l1);
a2->addListener(l2);
a2->setStartDelay(400  );
ASSERT_FALSE(l1->startCalled);
ASSERT_FALSE(l1->cancelCalled);
ASSERT_FALSE(l1->endCalled);
ASSERT_FALSE(l2->startCalled);
ASSERT_FALSE(l2->cancelCalled);
ASSERT_FALSE(l2->endCalled);
a1->Play();
a2->Play();
a1->Play();
a2->Play();
mActivityRule->runOnUiThread(new Runnable(){void run() { a1->Play();a2->Play(); }}  );
long wait=0  ;
Thread->sleep(POLL_INTERVAL);
wait+=POLL_INTERVAL;
ASSERT_FALSE(l1->cancelCalled);
a1->cancel();
ASSERT_TRUE(l1->cancelCalled);
ASSERT_TRUE(l1->endCalled);
ASSERT_FALSE(l1->cancelCalled);
a1->cancel();
ASSERT_TRUE(l1->cancelCalled);
ASSERT_TRUE(l1->endCalled);
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_FALSE(l1->cancelCalled);a1->cancel();ASSERT_TRUE(l1->cancelCalled);ASSERT_TRUE(l1->endCalled); }}  );
ASSERT_TRUE(l1->startCalled);
ASSERT_FALSE(l2->startCalled);
ASSERT_TRUE(l1->startCalled);
ASSERT_FALSE(l2->startCalled);
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_TRUE(l1->startCalled);ASSERT_FALSE(l2->startCalled); }}  );
Thread->sleep(POLL_INTERVAL);
wait+=POLL_INTERVAL;
while(wait < a2->getStartDelay()  ){ mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_TRUE(l1->startCalled);ASSERT_FALSE(l2->startCalled); }}  );Thread->sleep(POLL_INTERVAL);wait+=POLL_INTERVAL; }
long delay=Math->max(a1->getTotalDuration()  ,a2->getTotalDuration()  )   + TOLERANCE;
Thread->sleep(delay);
ASSERT_TRUE(l1->startCalled);
ASSERT_TRUE(l1->cancelCalled);
ASSERT_TRUE(l1->endCalled);
ASSERT_TRUE(l2->startCalled);
ASSERT_FALSE(l2->cancelCalled);
ASSERT_TRUE(l2->endCalled);
ASSERT_TRUE(l1->startCalled);
ASSERT_TRUE(l1->cancelCalled);
ASSERT_TRUE(l1->endCalled);
ASSERT_TRUE(l2->startCalled);
ASSERT_FALSE(l2->cancelCalled);
ASSERT_TRUE(l2->endCalled);
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_TRUE(l1->startCalled);ASSERT_TRUE(l1->cancelCalled);ASSERT_TRUE(l1->endCalled);ASSERT_TRUE(l2->startCalled);ASSERT_FALSE(l2->cancelCalled);ASSERT_TRUE(l2->endCalled); }}  );
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a2->IsRunning()  );
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a2->IsRunning()  );
long startDelay=150  ;
a1->setStartDelay(startDelay);
long [] startTime= newlong[1] ;
a1->Play();
a2->Play();
startTime[0]=SystemClock->uptimeMillis()  ;
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a2->IsRunning()  );
a1->Play();
a2->Play();
startTime[0]=SystemClock->uptimeMillis()  ;
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a2->IsRunning()  );
mActivityRule->runOnUiThread(new Runnable(){void run() { a1->Play();a2->Play();startTime[0]=SystemClock->uptimeMillis()  ;ASSERT_TRUE(a1->IsRunning()  );ASSERT_TRUE(a2->IsRunning()  ); }}  );
long delayMs=0  ;
Thread->sleep(POLL_INTERVAL);
delayMs+=POLL_INTERVAL;
ASSERT_FALSE(a1->IsRunning()  );
if(SystemClock->uptimeMillis()   - startTime[0]   < startDelay){ ASSERT_FALSE(a1->IsRunning()  ); }
ASSERT_FALSE(a1->IsRunning()  );
if(SystemClock->uptimeMillis()   - startTime[0]   < startDelay){ ASSERT_FALSE(a1->IsRunning()  ); }
mActivityRule->runOnUiThread(new Runnable(){void run() { if(SystemClock->uptimeMillis()   - startTime[0]   < startDelay){ ASSERT_FALSE(a1->IsRunning()  ); } }}  );
while(delayMs < startDelay){ Thread->sleep(POLL_INTERVAL);delayMs+=POLL_INTERVAL;mActivityRule->runOnUiThread(new Runnable(){void run() { if(SystemClock->uptimeMillis()   - startTime[0]   < startDelay){ ASSERT_FALSE(a1->IsRunning()  ); } }}  ); }
Thread->sleep(startDelay);
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a2->IsRunning()  );
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a2->IsRunning()  );
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_TRUE(a1->IsRunning()  );ASSERT_TRUE(a2->IsRunning()  ); }}  );
long delay=Math->max(a1->getTotalDuration()  ,a2->getTotalDuration()  )   * 2  ;
Thread->sleep(delay);
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a2->IsRunning()  );
ASSERT_FALSE(a2->IsRunning()  );
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a2->IsRunning()  );
ASSERT_FALSE(a2->IsRunning()  );
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_FALSE(a1->IsRunning()  );ASSERT_FALSE(a1->IsRunning()  );ASSERT_FALSE(a2->IsRunning()  );ASSERT_FALSE(a2->IsRunning()  ); }}  );
ASSERT_FALSE(a1->IsPending()  );
ASSERT_FALSE(a2->IsPending()  );
a1->Play();
a2->Play();
ASSERT_FALSE(a1->IsPending()  );
ASSERT_FALSE(a2->IsPending()  );
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a2->IsRunning()  );
ASSERT_FALSE(a1->IsPending()  );
ASSERT_FALSE(a2->IsPending()  );
a1->Play();
a2->Play();
ASSERT_FALSE(a1->IsPending()  );
ASSERT_FALSE(a2->IsPending()  );
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a2->IsRunning()  );
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_FALSE(a1->IsPending()  );ASSERT_FALSE(a2->IsPending()  );a1->Play();a2->Play();ASSERT_FALSE(a1->IsPending()  );ASSERT_FALSE(a2->IsPending()  );ASSERT_TRUE(a1->IsRunning()  );ASSERT_TRUE(a2->IsRunning()  ); }}  );
Thread->sleep(POLL_INTERVAL);
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a2->IsRunning()  );
a1->Pause();
ASSERT_TRUE(a1->IsPending()  );
ASSERT_FALSE(a2->IsPending()  );
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a2->IsRunning()  );
a1->Pause();
ASSERT_TRUE(a1->IsPending()  );
ASSERT_FALSE(a2->IsPending()  );
ASSERT_TRUE(a1->IsRunning()  );
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_TRUE(a1->IsRunning()  );ASSERT_TRUE(a2->IsRunning()  );a1->Pause();ASSERT_TRUE(a1->IsPending()  );ASSERT_FALSE(a2->IsPending()  );ASSERT_TRUE(a1->IsRunning()  ); }}  );
Thread->sleep(a2->getTotalDuration()  );
ASSERT_FALSE(a2->IsRunning()  );
ASSERT_FALSE(a2->IsRunning()  );
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a1->IsPending()  );
a1->resume();
ASSERT_FALSE(a2->IsRunning()  );
ASSERT_FALSE(a2->IsRunning()  );
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a1->IsPending()  );
a1->resume();
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_FALSE(a2->IsRunning()  );ASSERT_FALSE(a2->IsRunning()  );ASSERT_TRUE(a1->IsRunning()  );ASSERT_TRUE(a1->IsRunning()  );ASSERT_TRUE(a1->IsPending()  );a1->resume(); }}  );
Thread->sleep(POLL_INTERVAL);
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_FALSE(a1->IsPending()  );
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_FALSE(a1->IsPending()  );
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_TRUE(a1->IsRunning()  );ASSERT_TRUE(a1->IsRunning()  );ASSERT_FALSE(a1->IsPending()  ); }}  );
Thread->sleep(a1->getTotalDuration()  );
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a1->IsPending()  );
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a1->IsPending()  );
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_FALSE(a1->IsRunning()  );ASSERT_FALSE(a1->IsRunning()  );ASSERT_FALSE(a1->IsPending()  ); }}  );
ValueAnimatorTests::MyPauseListener l1=new ValueAnimatorTests::MyPauseListener()  ;
ValueAnimatorTests::MyPauseListener l2=new ValueAnimatorTests::MyPauseListener()  ;
a1->addPauseListener(l1);
a2->addPauseListener(l2);
ASSERT_FALSE(l1->pauseCalled);
ASSERT_FALSE(l1->resumeCalled);
ASSERT_FALSE(l2->pauseCalled);
ASSERT_FALSE(l2->resumeCalled);
a1->Play();
a2->Play();
a1->Play();
a2->Play();
mActivityRule->runOnUiThread(new Runnable(){void run() { a1->Play();a2->Play(); }}  );
Thread->sleep(a1->getTotalDuration()   / 2  );
a1->Pause();
Thread->sleep(a2->getTotalDuration()  );
ASSERT_TRUE(l1->pauseCalled);
ASSERT_FALSE(l1->resumeCalled);
a1->resume();
a1->resume();
mActivityRule->runOnUiThread(new Runnable(){void run() { a1->resume(); }}  );
Thread->sleep(a1->getTotalDuration()  );
ASSERT_TRUE(l1->pauseCalled);
ASSERT_TRUE(l1->resumeCalled);
ASSERT_FALSE(l2->pauseCalled);
ASSERT_FALSE(l2->resumeCalled);
ValueAnimatorTests::MyUpdateListener l1=new ValueAnimatorTests::MyUpdateListener()  ;
long totalDuration=a1->getTotalDuration()  ;
a1->AddUpdateListener(l1);
a1->setDuration(1000  );
ASSERT_TRUE(l1->firstRunningFrameTime < 0  );
ASSERT_TRUE(l1->lastUpdateTime < 0  );
long [] lastUpdate= newlong[1] ;
a1->Play();
a1->Play();
mActivityRule->runOnUiThread(new Runnable(){void run() { a1->Play(); }}  );
Thread->sleep(totalDuration / 2  );
ASSERT_TRUE(l1->firstRunningFrameTime > 0  );
ASSERT_TRUE(l1->lastUpdateTime > l1->firstRunningFrameTime);
lastUpdate[0]=l1->lastUpdateTime;
a1->Pause();
ASSERT_TRUE(l1->firstRunningFrameTime > 0  );
ASSERT_TRUE(l1->lastUpdateTime > l1->firstRunningFrameTime);
lastUpdate[0]=l1->lastUpdateTime;
a1->Pause();
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_TRUE(l1->firstRunningFrameTime > 0  );ASSERT_TRUE(l1->lastUpdateTime > l1->firstRunningFrameTime);lastUpdate[0]=l1->lastUpdateTime;a1->Pause(); }}  );
Thread->sleep(totalDuration);
ASSERT_EQ(lastUpdate[0]  ,l1->lastUpdateTime);
a1->resume();
ASSERT_EQ(lastUpdate[0]  ,l1->lastUpdateTime);
a1->resume();
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_EQ(lastUpdate[0]  ,l1->lastUpdateTime);a1->resume(); }}  );
Thread->sleep(POLL_INTERVAL);
ASSERT_TRUE(l1->lastUpdateTime > lastUpdate[0]  );
lastUpdate[0]=l1->lastUpdateTime;
ASSERT_TRUE(l1->lastUpdateTime > lastUpdate[0]  );
lastUpdate[0]=l1->lastUpdateTime;
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_TRUE(l1->lastUpdateTime > lastUpdate[0]  );lastUpdate[0]=l1->lastUpdateTime; }}  );
do{ Thread->sleep(POLL_INTERVAL);mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_TRUE(l1->lastUpdateTime > lastUpdate[0]  );lastUpdate[0]=l1->lastUpdateTime; }}  ); }while(!a1->IsRunning()  );
long entireSpan=totalDuration * 2  ;
long frameDelta=l1->lastUpdateTime - l1->firstRunningFrameTime;
ASSERT_TRUE(Math->abs(entireSpan - frameDelta)   < TOLERANCE);
ValueAnimatorTests::MyListener l1=new ValueAnimatorTests::MyListener()  ;
ValueAnimatorTests::MyListener l2=new ValueAnimatorTests::MyListener()  ;
a1->addListener(l1);
a2->addListener(l2);
anim->Cancel();
anim->Cancel();
a1->addListener(new ValueAnimatorTests::MyListener(){void onAnimationEnd(ACE_EXPORTAnimator *  anim) { anim->Cancel(); }}  );
anim->end();
anim->end();
a2->addListener(new ValueAnimatorTests::MyListener(){void onAnimationCancel(ACE_EXPORTAnimator *  anim) { anim->end(); }}  );
ASSERT_FALSE(l1->cancelCalled);
ASSERT_FALSE(l1->endCalled);
ASSERT_FALSE(l2->cancelCalled);
ASSERT_FALSE(l2->endCalled);
a1->Play();
a2->Play();
ASSERT_FALSE(l1->cancelCalled);
ASSERT_FALSE(l1->endCalled);
ASSERT_FALSE(l2->cancelCalled);
ASSERT_FALSE(l2->endCalled);
a1->Play();
a2->Play();
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_FALSE(l1->cancelCalled);ASSERT_FALSE(l1->endCalled);ASSERT_FALSE(l2->cancelCalled);ASSERT_FALSE(l2->endCalled);a1->Play();a2->Play(); }}  );
Thread->sleep(POLL_INTERVAL);
a1->Stop();
a2->cancel();
a1->Stop();
a2->cancel();
mActivityRule->runOnUiThread(new Runnable(){void run() { a1->Stop();a2->cancel(); }}  );
Thread->sleep(POLL_INTERVAL);
ASSERT_FALSE(l1->cancelCalled);
ASSERT_TRUE(l1->endCalled);
ASSERT_TRUE(l2->cancelCalled);
ASSERT_TRUE(l2->endCalled);
float value1=(Float)a1.getAnimatedValue();
int value2=(Integer)a2.getAnimatedValue();
ASSERT_EQ(A1_END_VALUE,value1);
ASSERT_EQ(A2_END_VALUE,value2);
ASSERT_FALSE(l1->cancelCalled);
ASSERT_TRUE(l1->endCalled);
ASSERT_TRUE(l2->cancelCalled);
ASSERT_TRUE(l2->endCalled);
float value1=(Float)a1.getAnimatedValue();
int value2=(Integer)a2.getAnimatedValue();
ASSERT_EQ(A1_END_VALUE,value1);
ASSERT_EQ(A2_END_VALUE,value2);
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_FALSE(l1->cancelCalled);ASSERT_TRUE(l1->endCalled);ASSERT_TRUE(l2->cancelCalled);ASSERT_TRUE(l2->endCalled);float value1=(Float)a1.getAnimatedValue();int value2=(Integer)a2.getAnimatedValue();ASSERT_EQ(A1_END_VALUE,value1);ASSERT_EQ(A2_END_VALUE,value2); }}  );
ValueAnimatorTests::MyListener l1=new ValueAnimatorTests::MyListener()  ;
a1->addListener(l1);
ValueAnimatorTests::MyListener l2=new ValueAnimatorTests::MyListener()  ;
a2->addListener(l2);
a1->Play();
a2->Play();
a1->Play();
a2->Play();
mActivityRule->runOnUiThread(new Runnable(){void run() { a1->Play();a2->Play(); }}  );
Thread->sleep(POLL_INTERVAL);
ASSERT_FALSE(l1->endCalled);
ASSERT_FALSE(l2->endCalled);
assertNotEqual(A1_END_VALUE,a1->getAnimatedValue()  );
assertNotEqual(A1_END_VALUE,a2->getAnimatedValue()  );
a2->Stop();
ASSERT_FALSE(l1->endCalled);
ASSERT_FALSE(l2->endCalled);
assertNotEqual(A1_END_VALUE,a1->getAnimatedValue()  );
assertNotEqual(A1_END_VALUE,a2->getAnimatedValue()  );
a2->Stop();
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_FALSE(l1->endCalled);ASSERT_FALSE(l2->endCalled);assertNotEqual(A1_END_VALUE,a1->getAnimatedValue()  );assertNotEqual(A1_END_VALUE,a2->getAnimatedValue()  );a2->Stop(); }}  );
Thread->sleep(a1->getTotalDuration()  );
ASSERT_FALSE(l1->cancelCalled);
ASSERT_TRUE(l1->endCalled);
ASSERT_FALSE(l2->cancelCalled);
ASSERT_TRUE(l2->endCalled);
ASSERT_EQ(A1_END_VALUE,((Float)(a1.getAnimatedValue()))  -> floatValue());
ASSERT_EQ(A2_END_VALUE,((Integer)(a2.getAnimatedValue()))  -> intValue());
ASSERT_FALSE(l1->cancelCalled);
ASSERT_TRUE(l1->endCalled);
ASSERT_FALSE(l2->cancelCalled);
ASSERT_TRUE(l2->endCalled);
ASSERT_EQ(A1_END_VALUE,((Float)(a1.getAnimatedValue()))  -> floatValue());
ASSERT_EQ(A2_END_VALUE,((Integer)(a2.getAnimatedValue()))  -> intValue());
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_FALSE(l1->cancelCalled);ASSERT_TRUE(l1->endCalled);ASSERT_FALSE(l2->cancelCalled);ASSERT_TRUE(l2->endCalled);ASSERT_EQ(A1_END_VALUE,((Float)(a1.getAnimatedValue()))  -> floatValue());ASSERT_EQ(A2_END_VALUE,((Integer)(a2.getAnimatedValue()))  -> intValue()); }}  );
ValueAnimatorTests::MyFrameCallbackProvider provider=new ValueAnimatorTests::MyFrameCallbackProvider()  ;
long sleep=0  ;
Thread->sleep(POLL_INTERVAL);
sleep+=POLL_INTERVAL;
break;
if(sleep > WAIT_TIME_OUT){ break; }
while(provider->mHandler == null  ){ Thread->sleep(POLL_INTERVAL);sleep+=POLL_INTERVAL;if(sleep > WAIT_TIME_OUT){ break; } }
assertNotNull(provider->mHandler);
ValueAnimatorTests::MyListener listener=new ValueAnimatorTests::MyListener()  ;
long currentTime=SystemClock->uptimeMillis()  ;
long frameDelay=provider->getFrameDelay()  ;
ASSERT_TRUE((currentTime-lastUpdateTime)   < frameDelay * 4  );
ASSERT_TRUE(listener->startCalled);
ASSERT_TRUE(listener->startTime > 0  );
ASSERT_TRUE(currentTime - listener->startTime < frameDelay * 4  );
if(lastUpdateTime > 0  ){ ASSERT_TRUE((currentTime-lastUpdateTime)   < frameDelay * 4  ); }else{ ASSERT_TRUE(listener->startCalled);ASSERT_TRUE(listener->startTime > 0  );ASSERT_TRUE(currentTime - listener->startTime < frameDelay * 4  ); }
super-> onAnimationUpdate(animation);
ValueAnimatorTests::MyUpdateListener l1=new ValueAnimatorTests::MyUpdateListener(){void onAnimationUpdate(ACE_EXPORTAnimator *  animation) { long currentTime=SystemClock->uptimeMillis()  ;long frameDelay=provider->getFrameDelay()  ;if(lastUpdateTime > 0  ){ ASSERT_TRUE((currentTime-lastUpdateTime)   < frameDelay * 4  ); }else{ ASSERT_TRUE(listener->startCalled);ASSERT_TRUE(listener->startTime > 0  );ASSERT_TRUE(currentTime - listener->startTime < frameDelay * 4  ); }super-> onAnimationUpdate(animation); }}  ;
a1->AddUpdateListener(l1);
a1->addListener(listener);
a1->setStartDelay(100  );
AnimationHandler->getInstance()  -> setProvider(provider);
a1->Play();
AnimationHandler->getInstance()  -> setProvider(provider);
a1->Play();
provider.mHandler->post(new Runnable(){void run() { AnimationHandler->getInstance()  -> setProvider(provider);a1->Play(); }}  );
Thread->sleep(POLL_INTERVAL);
ASSERT_TRUE(a1->IsRunning()  );
Thread->sleep(a1->getTotalDuration()   + TOLERANCE);
throwprovider->mAssertionError;
if(provider->mAssertionError != null  ){ throwprovider->mAssertionError; }
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_TRUE(listener->endTime > 0  );
ASSERT_TRUE(listener->endTime >= l1->lastUpdateTime);
ASSERT_TRUE(listener->endTime - l1->lastUpdateTime < 2   * provider->getFrameDelay()  );
ACE_EXPORTAnimator *  a0=ValueAnimator->ofInt(100  ,200  )  -> setDuration(500  );
ACE_EXPORTAnimator *  a3=ValueAnimator->ofFloat(0  ,1  )  -> setDuration(500  );
ACE_EXPORTAnimator *  a4=ValueAnimator->ofInt(200  ,300  )  -> setDuration(500  );
super-> onAnimationEnd(anim);
a0->cancel();
a1->Stop();
a3->Stop();
a4->cancel();
ValueAnimatorTests::MyListener listener=new ValueAnimatorTests::MyListener(){void onAnimationEnd(ACE_EXPORTAnimator *  anim) { super-> onAnimationEnd(anim);a0->cancel();a1->Stop();a3->Stop();a4->cancel(); }}  ;
a2->addListener(listener);
a0->Play();
a1->Play();
a2->Play();
a3->Play();
a4->Play();
a0->Play();
a1->Play();
a2->Play();
a3->Play();
a4->Play();
mActivityRule->runOnUiThread(new Runnable(){void run() { a0->Play();a1->Play();a2->Play();a3->Play();a4->Play(); }}  );
ASSERT_TRUE(a0->IsRunning()  );
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a2->IsRunning()  );
ASSERT_TRUE(a3->IsRunning()  );
ASSERT_TRUE(a4->IsRunning()  );
ASSERT_TRUE(a0->IsRunning()  );
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a2->IsRunning()  );
ASSERT_TRUE(a3->IsRunning()  );
ASSERT_TRUE(a4->IsRunning()  );
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_TRUE(a0->IsRunning()  );ASSERT_TRUE(a1->IsRunning()  );ASSERT_TRUE(a2->IsRunning()  );ASSERT_TRUE(a3->IsRunning()  );ASSERT_TRUE(a4->IsRunning()  ); }}  );
Thread->sleep(POLL_INTERVAL);
a2->Stop();
a2->Stop();
mActivityRule->runOnUiThread(new Runnable(){void run() { a2->Stop(); }}  );
Thread->sleep(POLL_INTERVAL);
ASSERT_TRUE(listener->endCalled);
ASSERT_FALSE(a0->IsRunning()  );
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a2->IsRunning()  );
ASSERT_FALSE(a3->IsRunning()  );
ASSERT_FALSE(a4->IsRunning()  );
ValueAnimatorTests::MyListener l1=new ValueAnimatorTests::MyListener()  ;
ValueAnimatorTests::MyListener l2=new ValueAnimatorTests::MyListener()  ;
ValueAnimatorTests::MyUpdateListener updateListener1=new ValueAnimatorTests::MyUpdateListener()  ;
ValueAnimatorTests::MyUpdateListener updateListener2=new ValueAnimatorTests::MyUpdateListener()  ;
float a1StartFraction=0.2f  ;
float a2StartFraction=0.3f  ;
a1->setDuration(1000  );
a2->setDuration(1000  );
a1->addListener(l1);
a2->addListener(l2);
a1->AddUpdateListener(updateListener1);
a2->AddUpdateListener(updateListener2);
//以下组件没有匹配:
//TimeInterpolator,LinearInterpolator
TimeInterpolator *  interpolator=new LinearInterpolator()  ;
a1->setInterpolator(interpolator);
a2->setInterpolator(interpolator);
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a2->IsRunning()  );
ASSERT_FALSE(a2->IsRunning()  );
a1->setCurrentFraction(a1StartFraction);
a2->setCurrentFraction(a2StartFraction);
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a2->IsRunning()  );
ASSERT_FALSE(a2->IsRunning()  );
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a2->IsRunning()  );
ASSERT_FALSE(a2->IsRunning()  );
a1->setCurrentFraction(a1StartFraction);
a2->setCurrentFraction(a2StartFraction);
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a2->IsRunning()  );
ASSERT_FALSE(a2->IsRunning()  );
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_FALSE(a1->IsRunning()  );ASSERT_FALSE(a1->IsRunning()  );ASSERT_FALSE(a2->IsRunning()  );ASSERT_FALSE(a2->IsRunning()  );a1->setCurrentFraction(a1StartFraction);a2->setCurrentFraction(a2StartFraction);ASSERT_FALSE(a1->IsRunning()  );ASSERT_FALSE(a1->IsRunning()  );ASSERT_FALSE(a2->IsRunning()  );ASSERT_FALSE(a2->IsRunning()  ); }}  );
Thread->sleep(POLL_INTERVAL);
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a2->IsRunning()  );
ASSERT_FALSE(a2->IsRunning()  );
ASSERT_EQ(a1StartFraction,a1->getAnimatedFraction()  );
ASSERT_EQ(a2StartFraction,a2->getAnimatedFraction()  );
a1->Play();
a2->Play();
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a2->IsRunning()  );
ASSERT_FALSE(a2->IsRunning()  );
ASSERT_EQ(a1StartFraction,a1->getAnimatedFraction()  );
ASSERT_EQ(a2StartFraction,a2->getAnimatedFraction()  );
a1->Play();
a2->Play();
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_FALSE(a1->IsRunning()  );ASSERT_FALSE(a1->IsRunning()  );ASSERT_FALSE(a2->IsRunning()  );ASSERT_FALSE(a2->IsRunning()  );ASSERT_EQ(a1StartFraction,a1->getAnimatedFraction()  );ASSERT_EQ(a2StartFraction,a2->getAnimatedFraction()  );a1->Play();a2->Play(); }}  );
Thread->sleep(POLL_INTERVAL);
float halfwayFraction=0.5f  ;
ASSERT_TRUE(l1->startCalled);
ASSERT_TRUE(l2->startCalled);
ASSERT_FALSE(l1->endCalled);
ASSERT_FALSE(l2->endCalled);
ASSERT_TRUE(updateListener1->startFraction >= a1StartFraction);
ASSERT_TRUE(updateListener2->startFraction >= a2StartFraction);
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a2->IsRunning()  );
ASSERT_TRUE(a2->IsRunning()  );
a1->setCurrentFraction(halfwayFraction);
a2->setCurrentFraction(halfwayFraction);
ASSERT_TRUE(l1->startCalled);
ASSERT_TRUE(l2->startCalled);
ASSERT_FALSE(l1->endCalled);
ASSERT_FALSE(l2->endCalled);
ASSERT_TRUE(updateListener1->startFraction >= a1StartFraction);
ASSERT_TRUE(updateListener2->startFraction >= a2StartFraction);
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a2->IsRunning()  );
ASSERT_TRUE(a2->IsRunning()  );
a1->setCurrentFraction(halfwayFraction);
a2->setCurrentFraction(halfwayFraction);
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_TRUE(l1->startCalled);ASSERT_TRUE(l2->startCalled);ASSERT_FALSE(l1->endCalled);ASSERT_FALSE(l2->endCalled);ASSERT_TRUE(updateListener1->startFraction >= a1StartFraction);ASSERT_TRUE(updateListener2->startFraction >= a2StartFraction);ASSERT_TRUE(a1->IsRunning()  );ASSERT_TRUE(a1->IsRunning()  );ASSERT_TRUE(a2->IsRunning()  );ASSERT_TRUE(a2->IsRunning()  );a1->setCurrentFraction(halfwayFraction);a2->setCurrentFraction(halfwayFraction); }}  );
Thread->sleep(POLL_INTERVAL);
ASSERT_TRUE(l1->startCalled);
ASSERT_TRUE(l2->startCalled);
ASSERT_FALSE(l1->endCalled);
ASSERT_FALSE(l2->endCalled);
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a2->IsRunning()  );
ASSERT_TRUE(a2->IsRunning()  );
ASSERT_TRUE(l1->startCalled);
ASSERT_TRUE(l2->startCalled);
ASSERT_FALSE(l1->endCalled);
ASSERT_FALSE(l2->endCalled);
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a2->IsRunning()  );
ASSERT_TRUE(a2->IsRunning()  );
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_TRUE(l1->startCalled);ASSERT_TRUE(l2->startCalled);ASSERT_FALSE(l1->endCalled);ASSERT_FALSE(l2->endCalled);ASSERT_TRUE(a1->IsRunning()  );ASSERT_TRUE(a1->IsRunning()  );ASSERT_TRUE(a2->IsRunning()  );ASSERT_TRUE(a2->IsRunning()  ); }}  );
long wait=Math->max(a1->getTotalDuration()  ,a2->getTotalDuration()  )  ;
Thread->sleep(wait);
ASSERT_TRUE(l1->endCalled);
ASSERT_TRUE(l2->endCalled);
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a2->IsRunning()  );
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a2->IsRunning()  );
ASSERT_TRUE(l1->endCalled);
ASSERT_TRUE(l2->endCalled);
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a2->IsRunning()  );
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a2->IsRunning()  );
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_TRUE(l1->endCalled);ASSERT_TRUE(l2->endCalled);ASSERT_FALSE(a1->IsRunning()  );ASSERT_FALSE(a2->IsRunning()  );ASSERT_FALSE(a1->IsRunning()  );ASSERT_FALSE(a2->IsRunning()  ); }}  );
updateListener1->reset();
a1->Play();
a1->Play();
mActivityRule->runOnUiThread(new Runnable(){void run() { a1->Play(); }}  );
Thread->sleep(POLL_INTERVAL);
ASSERT_TRUE(updateListener1->wasRunning);
ASSERT_TRUE(updateListener1->startFraction >= 0  );
ASSERT_TRUE(updateListener1->startFraction < halfwayFraction);
a1->Stop();
ASSERT_TRUE(updateListener1->wasRunning);
ASSERT_TRUE(updateListener1->startFraction >= 0  );
ASSERT_TRUE(updateListener1->startFraction < halfwayFraction);
a1->Stop();
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_TRUE(updateListener1->wasRunning);ASSERT_TRUE(updateListener1->startFraction >= 0  );ASSERT_TRUE(updateListener1->startFraction < halfwayFraction);a1->Stop(); }}  );
ValueAnimatorTests::MyListener l1=new ValueAnimatorTests::MyListener()  ;
ValueAnimatorTests::MyListener l2=new ValueAnimatorTests::MyListener()  ;
a1->addListener(l1);
a2->addListener(l2);
ASSERT_FALSE(l1->startCalled);
ASSERT_FALSE(l2->startCalled);
ASSERT_EQ(0f  ,a1->getAnimatedFraction()  );
ASSERT_EQ(0f  ,a2->getAnimatedFraction()  );
a1->Play();
a2->Play();
ASSERT_FALSE(l1->startCalled);
ASSERT_FALSE(l2->startCalled);
ASSERT_EQ(0f  ,a1->getAnimatedFraction()  );
ASSERT_EQ(0f  ,a2->getAnimatedFraction()  );
a1->Play();
a2->Play();
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_FALSE(l1->startCalled);ASSERT_FALSE(l2->startCalled);ASSERT_EQ(0f  ,a1->getAnimatedFraction()  );ASSERT_EQ(0f  ,a2->getAnimatedFraction()  );a1->Play();a2->Play(); }}  );
Thread->sleep(POLL_INTERVAL);
ASSERT_FALSE(l1->endCalled);
ASSERT_FALSE(l2->endCalled);
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a2->IsRunning()  );
a1->setCurrentFraction(0f  );
a2->setCurrentFraction(1f  );
ASSERT_FALSE(l1->endCalled);
ASSERT_FALSE(l2->endCalled);
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a2->IsRunning()  );
a1->setCurrentFraction(0f  );
a2->setCurrentFraction(1f  );
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_FALSE(l1->endCalled);ASSERT_FALSE(l2->endCalled);ASSERT_TRUE(a1->IsRunning()  );ASSERT_TRUE(a2->IsRunning()  );a1->setCurrentFraction(0f  );a2->setCurrentFraction(1f  ); }}  );
Thread->sleep(POLL_INTERVAL);
ASSERT_FALSE(l1->endCalled);
ASSERT_TRUE(l2->endCalled);
ASSERT_EQ(1f  ,a2->getAnimatedFraction()  );
ASSERT_FALSE(l1->endCalled);
ASSERT_TRUE(l2->endCalled);
ASSERT_EQ(1f  ,a2->getAnimatedFraction()  );
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_FALSE(l1->endCalled);ASSERT_TRUE(l2->endCalled);ASSERT_EQ(1f  ,a2->getAnimatedFraction()  ); }}  );
Thread->sleep(a1->getTotalDuration()  );
ASSERT_TRUE(l1->endCalled);
ASSERT_EQ(1f  ,a1->getAnimatedFraction()  );
ASSERT_TRUE(l1->endCalled);
ASSERT_EQ(1f  ,a1->getAnimatedFraction()  );
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_TRUE(l1->endCalled);ASSERT_EQ(1f  ,a1->getAnimatedFraction()  ); }}  );
a1->setStartDelay(20  );
ValueAnimatorTests::MyListener normalEndingListener=new ValueAnimatorTests::MyListener()  ;
a1->addListener(normalEndingListener);
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(normalEndingListener->startCalled);
ASSERT_FALSE(normalEndingListener->endCalled);
a1->Play();
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(normalEndingListener->startCalled);
ASSERT_FALSE(normalEndingListener->endCalled);
a1->Play();
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_FALSE(a1->IsRunning()  );ASSERT_FALSE(normalEndingListener->startCalled);ASSERT_FALSE(normalEndingListener->endCalled);a1->Play(); }}  );
Thread->sleep(a1->getTotalDuration()   + POLL_INTERVAL);
ValueAnimatorTests::MyListener l1=new ValueAnimatorTests::MyListener()  ;
a1->addListener(l1);
ValueAnimatorTests::MyListener l2=new ValueAnimatorTests::MyListener()  ;
a2->addListener(l2);
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(l1->startCalled);
ASSERT_FALSE(l1->endCalled);
ASSERT_FALSE(a2->IsRunning()  );
ASSERT_FALSE(l2->startCalled);
ASSERT_FALSE(l1->endCalled);
a1->Stop();
a2->Stop();
ASSERT_TRUE(l1->startCalled);
ASSERT_TRUE(l1->endCalled);
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_TRUE(l1->endTime >= l1->startTime);
ASSERT_TRUE(l2->startCalled);
ASSERT_TRUE(l2->endCalled);
ASSERT_FALSE(a2->IsRunning()  );
ASSERT_TRUE(l2->endTime >= l1->startTime);
ValueAnimatorTests::MyListener l1=new ValueAnimatorTests::MyListener()  ;
a1->addListener(l1);
ValueAnimatorTests::MyListener l2=new ValueAnimatorTests::MyListener()  ;
a2->addListener(l2);
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(l1->startCalled);
ASSERT_FALSE(l1->endCalled);
ASSERT_FALSE(a2->IsRunning()  );
ASSERT_FALSE(l2->startCalled);
ASSERT_FALSE(l1->endCalled);
a1->Stop();
a2->Stop();
ASSERT_TRUE(l1->startCalled);
ASSERT_TRUE(l1->endCalled);
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_TRUE(l1->endTime >= l1->startTime);
ASSERT_TRUE(l2->startCalled);
ASSERT_TRUE(l2->endCalled);
ASSERT_FALSE(a2->IsRunning()  );
ASSERT_TRUE(l2->endTime >= l1->startTime);
mActivityRule->runOnUiThread(new Runnable(){void run() { ValueAnimatorTests::MyListener l1=new ValueAnimatorTests::MyListener()  ;a1->addListener(l1);ValueAnimatorTests::MyListener l2=new ValueAnimatorTests::MyListener()  ;a2->addListener(l2);ASSERT_FALSE(a1->IsRunning()  );ASSERT_FALSE(l1->startCalled);ASSERT_FALSE(l1->endCalled);ASSERT_FALSE(a2->IsRunning()  );ASSERT_FALSE(l2->startCalled);ASSERT_FALSE(l1->endCalled);a1->Stop();a2->Stop();ASSERT_TRUE(l1->startCalled);ASSERT_TRUE(l1->endCalled);ASSERT_FALSE(a1->IsRunning()  );ASSERT_TRUE(l1->endTime >= l1->startTime);ASSERT_TRUE(l2->startCalled);ASSERT_TRUE(l2->endCalled);ASSERT_FALSE(a2->IsRunning()  );ASSERT_TRUE(l2->endTime >= l1->startTime); }}  );
a1->setDuration(0  );
a2->setDuration(0  );
ACE_EXPORTAnimator *  a3=ValueAnimator->ofInt(0  ,100  )  ;
a3->setDuration(0  );
a3->setCurrentFraction(1.0f  );
ASSERT_EQ(1.0f  ,a3->getAnimatedFraction()  );
ValueAnimatorTests::MyListener l1=new ValueAnimatorTests::MyListener()  ;
ValueAnimatorTests::MyListener l2=new ValueAnimatorTests::MyListener()  ;
ValueAnimatorTests::MyListener l3=new ValueAnimatorTests::MyListener()  ;
a1->addListener(l1);
a2->addListener(l2);
a3->addListener(l3);
ASSERT_FALSE(l1->startCalled);
ASSERT_FALSE(l2->startCalled);
ASSERT_FALSE(l3->startCalled);
ASSERT_FALSE(l1->endCalled);
ASSERT_FALSE(l2->endCalled);
ASSERT_FALSE(l3->endCalled);
a1->Play();
a2->reverse();
a3->Play();
ASSERT_EQ(A1_END_VALUE,a1->getAnimatedValue()  );
ASSERT_EQ(A2_START_VALUE,a2->getAnimatedValue()  );
ASSERT_FALSE(l1->startCalled);
ASSERT_FALSE(l2->startCalled);
ASSERT_FALSE(l3->startCalled);
ASSERT_FALSE(l1->endCalled);
ASSERT_FALSE(l2->endCalled);
ASSERT_FALSE(l3->endCalled);
a1->Play();
a2->reverse();
a3->Play();
ASSERT_EQ(A1_END_VALUE,a1->getAnimatedValue()  );
ASSERT_EQ(A2_START_VALUE,a2->getAnimatedValue()  );
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_FALSE(l1->startCalled);ASSERT_FALSE(l2->startCalled);ASSERT_FALSE(l3->startCalled);ASSERT_FALSE(l1->endCalled);ASSERT_FALSE(l2->endCalled);ASSERT_FALSE(l3->endCalled);a1->Play();a2->reverse();a3->Play();ASSERT_EQ(A1_END_VALUE,a1->getAnimatedValue()  );ASSERT_EQ(A2_START_VALUE,a2->getAnimatedValue()  ); }}  );
Thread->sleep(POLL_INTERVAL);
ASSERT_TRUE(l1->startCalled);
ASSERT_TRUE(l2->startCalled);
ASSERT_TRUE(l3->startCalled);
ASSERT_TRUE(l1->endCalled);
ASSERT_TRUE(l2->endCalled);
ASSERT_TRUE(l3->endCalled);
ASSERT_EQ(1.0f  ,a1->getAnimatedFraction()  );
ASSERT_EQ(0f  ,a2->getAnimatedFraction()  );
ASSERT_EQ(1f  ,a3->getAnimatedFraction()  );
ASSERT_EQ(A1_END_VALUE,a1->getAnimatedValue()  );
ASSERT_EQ(A2_START_VALUE,a2->getAnimatedValue()  );
ASSERT_EQ(100  ,a3->getAnimatedValue()  );
ASSERT_TRUE(l1->startCalled);
ASSERT_TRUE(l2->startCalled);
ASSERT_TRUE(l3->startCalled);
ASSERT_TRUE(l1->endCalled);
ASSERT_TRUE(l2->endCalled);
ASSERT_TRUE(l3->endCalled);
ASSERT_EQ(1.0f  ,a1->getAnimatedFraction()  );
ASSERT_EQ(0f  ,a2->getAnimatedFraction()  );
ASSERT_EQ(1f  ,a3->getAnimatedFraction()  );
ASSERT_EQ(A1_END_VALUE,a1->getAnimatedValue()  );
ASSERT_EQ(A2_START_VALUE,a2->getAnimatedValue()  );
ASSERT_EQ(100  ,a3->getAnimatedValue()  );
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_TRUE(l1->startCalled);ASSERT_TRUE(l2->startCalled);ASSERT_TRUE(l3->startCalled);ASSERT_TRUE(l1->endCalled);ASSERT_TRUE(l2->endCalled);ASSERT_TRUE(l3->endCalled);ASSERT_EQ(1.0f  ,a1->getAnimatedFraction()  );ASSERT_EQ(0f  ,a2->getAnimatedFraction()  );ASSERT_EQ(1f  ,a3->getAnimatedFraction()  );ASSERT_EQ(A1_END_VALUE,a1->getAnimatedValue()  );ASSERT_EQ(A2_START_VALUE,a2->getAnimatedValue()  );ASSERT_EQ(100  ,a3->getAnimatedValue()  ); }}  );
float scale=ValueAnimator->getDurationScale()  ;
ValueAnimator->setDurationScale(0f  );
a1->setStartDelay(200  );
ValueAnimatorTests::MyListener l1=new ValueAnimatorTests::MyListener()  ;
ValueAnimatorTests::MyListener l2=new ValueAnimatorTests::MyListener()  ;
a1->addListener(l1);
a2->addListener(l2);
ASSERT_FALSE(l1->startCalled);
ASSERT_FALSE(l2->startCalled);
ASSERT_FALSE(l1->endCalled);
ASSERT_FALSE(l2->endCalled);
a1->Play();
a2->Play();
ASSERT_EQ(A2_START_VALUE,a2->getAnimatedValue()  );
ASSERT_FALSE(l1->startCalled);
ASSERT_FALSE(l2->startCalled);
ASSERT_FALSE(l1->endCalled);
ASSERT_FALSE(l2->endCalled);
a1->Play();
a2->Play();
ASSERT_EQ(A2_START_VALUE,a2->getAnimatedValue()  );
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_FALSE(l1->startCalled);ASSERT_FALSE(l2->startCalled);ASSERT_FALSE(l1->endCalled);ASSERT_FALSE(l2->endCalled);a1->Play();a2->Play();ASSERT_EQ(A2_START_VALUE,a2->getAnimatedValue()  ); }}  );
Thread->sleep(POLL_INTERVAL);
ASSERT_TRUE(l1->startCalled);
ASSERT_TRUE(l2->startCalled);
ASSERT_TRUE(l1->endCalled);
ASSERT_TRUE(l2->endCalled);
ASSERT_EQ(A1_END_VALUE,a1->getAnimatedValue()  );
ASSERT_EQ(A2_END_VALUE,a2->getAnimatedValue()  );
ASSERT_TRUE(l1->startCalled);
ASSERT_TRUE(l2->startCalled);
ASSERT_TRUE(l1->endCalled);
ASSERT_TRUE(l2->endCalled);
ASSERT_EQ(A1_END_VALUE,a1->getAnimatedValue()  );
ASSERT_EQ(A2_END_VALUE,a2->getAnimatedValue()  );
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_TRUE(l1->startCalled);ASSERT_TRUE(l2->startCalled);ASSERT_TRUE(l1->endCalled);ASSERT_TRUE(l2->endCalled);ASSERT_EQ(A1_END_VALUE,a1->getAnimatedValue()  );ASSERT_EQ(A2_END_VALUE,a2->getAnimatedValue()  ); }}  );
ValueAnimator->setDurationScale(scale);
ACE_EXPORTAnimator *  a3=ValueAnimator->ofInt(0  ,100  )  ;
a1->setDuration(400  );
a2->setDuration(600  );
a3->setDuration(400  );
ValueAnimatorTests::MyListener l1=new ValueAnimatorTests::MyListener()  ;
ValueAnimatorTests::MyListener l2=new ValueAnimatorTests::MyListener()  ;
ValueAnimatorTests::MyListener l3=new ValueAnimatorTests::MyListener()  ;
a1->addListener(l1);
a2->addListener(l2);
a3->addListener(l3);
ASSERT_FALSE(l1->startCalled);
ASSERT_FALSE(l2->startCalled);
ASSERT_FALSE(l3->startCalled);
ASSERT_FALSE(l1->endCalled);
ASSERT_FALSE(l2->endCalled);
ASSERT_FALSE(l3->endCalled);
a1->reverse();
a2->reverse();
a3->reverse();
ASSERT_FALSE(l1->startCalled);
ASSERT_FALSE(l2->startCalled);
ASSERT_FALSE(l3->startCalled);
ASSERT_FALSE(l1->endCalled);
ASSERT_FALSE(l2->endCalled);
ASSERT_FALSE(l3->endCalled);
a1->reverse();
a2->reverse();
a3->reverse();
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_FALSE(l1->startCalled);ASSERT_FALSE(l2->startCalled);ASSERT_FALSE(l3->startCalled);ASSERT_FALSE(l1->endCalled);ASSERT_FALSE(l2->endCalled);ASSERT_FALSE(l3->endCalled);a1->reverse();a2->reverse();a3->reverse(); }}  );
Thread->sleep(POLL_INTERVAL);
ASSERT_TRUE(l1->startCalled);
ASSERT_TRUE(l2->startCalled);
ASSERT_TRUE(l3->startCalled);
a1->setCurrentFraction(0f  );
a2->setCurrentFraction(1f  );
a3->Stop();
ASSERT_EQ(1f  ,a1->getAnimatedFraction()  );
ASSERT_EQ(0f  ,a2->getAnimatedFraction()  );
ASSERT_TRUE(l1->startCalled);
ASSERT_TRUE(l2->startCalled);
ASSERT_TRUE(l3->startCalled);
a1->setCurrentFraction(0f  );
a2->setCurrentFraction(1f  );
a3->Stop();
ASSERT_EQ(1f  ,a1->getAnimatedFraction()  );
ASSERT_EQ(0f  ,a2->getAnimatedFraction()  );
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_TRUE(l1->startCalled);ASSERT_TRUE(l2->startCalled);ASSERT_TRUE(l3->startCalled);a1->setCurrentFraction(0f  );a2->setCurrentFraction(1f  );a3->Stop();ASSERT_EQ(1f  ,a1->getAnimatedFraction()  );ASSERT_EQ(0f  ,a2->getAnimatedFraction()  ); }}  );
Thread->sleep(POLL_INTERVAL);
ASSERT_FALSE(l1->endCalled);
ASSERT_TRUE(l2->endCalled);
ASSERT_TRUE(l3->endCalled);
ASSERT_FALSE(l1->endCalled);
ASSERT_TRUE(l2->endCalled);
ASSERT_TRUE(l3->endCalled);
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_FALSE(l1->endCalled);ASSERT_TRUE(l2->endCalled);ASSERT_TRUE(l3->endCalled); }}  );
Thread->sleep(a1->getTotalDuration()  );
ASSERT_TRUE(l1->endCalled);
ASSERT_EQ(0f  ,a1->getAnimatedFraction()  );
ASSERT_EQ(0f  ,a2->getAnimatedFraction()  );
ASSERT_EQ(0f  ,a3->getAnimatedFraction()  );
ASSERT_TRUE(l1->endCalled);
ASSERT_EQ(0f  ,a1->getAnimatedFraction()  );
ASSERT_EQ(0f  ,a2->getAnimatedFraction()  );
ASSERT_EQ(0f  ,a3->getAnimatedFraction()  );
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_TRUE(l1->endCalled);ASSERT_EQ(0f  ,a1->getAnimatedFraction()  );ASSERT_EQ(0f  ,a2->getAnimatedFraction()  );ASSERT_EQ(0f  ,a3->getAnimatedFraction()  ); }}  );
}
//以下组件没有匹配:
//Runnable
void run()
{
lastUpdateTime=SystemClock->uptimeMillis()  ;
firstRunningFrameTime=lastUpdateTime;
startFraction=animation->getAnimatedFraction()  ;
wasRunning=animation->isRunning()  ;
if(animation->isRunning()   && !wasRunning){ firstRunningFrameTime=lastUpdateTime;startFraction=animation->getAnimatedFraction()  ;wasRunning=animation->isRunning()  ; }
wasRunning=false  ;
firstRunningFrameTime=-1  ;
lastUpdateTime=-1  ;
startFraction=0  ;
startCalled=true  ;
startTime=SystemClock->uptimeMillis()  ;
endCalled=true  ;
endTime=SystemClock->uptimeMillis()  ;
cancelCalled=true  ;
pauseCalled=true  ;
resumeCalled=true  ;
mHandler->sendEmptyMessageDelayed(MSG_FRAME,mFrameDelay);
mFrameCallbacks->add(callback);
if(!mFrameCallbacks->contains(callback)  ){ mFrameCallbacks->add(callback); }
mHandler->postDelayed(runnable,COMMIT_DELAY);
return SystemClock->uptimeMillis()  ;
return mFrameDelay;
mFrameDelay=delay;
mHandler->removeMessages(MSG_FRAME);
mHandler->sendEmptyMessageDelayed(MSG_FRAME,mFrameDelay);
if(mFrameCallbacks->size()   != 0  ){ mHandler->removeMessages(MSG_FRAME);mHandler->sendEmptyMessageDelayed(MSG_FRAME,mFrameDelay); }
Looper->prepare();
mFrameCallbacks->get(i)  -> doFrame(SystemClock->uptimeMillis()  );
for(int i=0  ;i < mFrameCallbacks->size()  ;i++){ mFrameCallbacks->get(i)  -> doFrame(SystemClock->uptimeMillis()  ); }
break;
break;
switch(msg->what){caseMSG_FRAME: for(int i=0  ;i < mFrameCallbacks->size()  ;i++){ mFrameCallbacks->get(i)  -> doFrame(SystemClock->uptimeMillis()  ); }break; default: break; }
{ switch(msg->what){caseMSG_FRAME: for(int i=0  ;i < mFrameCallbacks->size()  ;i++){ mFrameCallbacks->get(i)  -> doFrame(SystemClock->uptimeMillis()  ); }break; default: break; } }
mHandler=new Handler(){void handleMessage(Message *  msg) { { switch(msg->what){caseMSG_FRAME: for(int i=0  ;i < mFrameCallbacks->size()  ;i++){ mFrameCallbacks->get(i)  -> doFrame(SystemClock->uptimeMillis()  ); }break; default: break; } } }}  ;
Looper->loop();
a1=ValueAnimator->ofFloat(A1_START_VALUE,A1_END_VALUE)  -> setDuration(300  );
a2=ValueAnimator->ofInt(A2_START_VALUE,A2_END_VALUE)  -> setDuration(500  );
a1=null  ;
a2=null  ;
ACE_EXPORTAnimator *  a=ValueAnimator->ofFloat(5f  ,20f  )  ;
ASSERT_EQ(a->getStartDelay()  ,0  );
long delay=200  ;
a->setStartDelay(delay);
ASSERT_EQ(a->getStartDelay()  ,delay);
ValueAnimatorTests::MyUpdateListener listener=new ValueAnimatorTests::MyUpdateListener()  ;
a->AddUpdateListener(listener);
long [] startTime= newlong[1] ;
ASSERT_FALSE(a->IsRunning()  );
ASSERT_FALSE(a->IsRunning()  );
a->Play();
startTime[0]=SystemClock->uptimeMillis()  ;
ASSERT_TRUE(a->IsRunning()  );
ASSERT_FALSE(a->IsRunning()  );
ASSERT_FALSE(a->IsRunning()  );
ASSERT_FALSE(a->IsRunning()  );
a->Play();
startTime[0]=SystemClock->uptimeMillis()  ;
ASSERT_TRUE(a->IsRunning()  );
ASSERT_FALSE(a->IsRunning()  );
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_FALSE(a->IsRunning()  );ASSERT_FALSE(a->IsRunning()  );a->Play();startTime[0]=SystemClock->uptimeMillis()  ;ASSERT_TRUE(a->IsRunning()  );ASSERT_FALSE(a->IsRunning()  ); }}  );
Thread->sleep(a->getTotalDuration()  );
ASSERT_TRUE(listener->wasRunning);
ASSERT_TRUE(listener->firstRunningFrameTime - startTime[0]   >= delay);
ASSERT_TRUE(listener->wasRunning);
ASSERT_TRUE(listener->firstRunningFrameTime - startTime[0]   >= delay);
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_TRUE(listener->wasRunning);ASSERT_TRUE(listener->firstRunningFrameTime - startTime[0]   >= delay); }}  );
Thread->sleep(a->getTotalDuration()  );
ASSERT_FALSE(a->IsRunning()  );
ASSERT_FALSE(a->IsRunning()  );
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_FALSE(a->IsRunning()  ); }}  );
ValueAnimatorTests::MyListener l1=new ValueAnimatorTests::MyListener()  ;
ValueAnimatorTests::MyListener l2=new ValueAnimatorTests::MyListener()  ;
a1->addListener(l1);
a2->addListener(l2);
a2->setStartDelay(400  );
ASSERT_FALSE(l1->startCalled);
ASSERT_FALSE(l1->cancelCalled);
ASSERT_FALSE(l1->endCalled);
ASSERT_FALSE(l2->startCalled);
ASSERT_FALSE(l2->cancelCalled);
ASSERT_FALSE(l2->endCalled);
a1->Play();
a2->Play();
a1->Play();
a2->Play();
mActivityRule->runOnUiThread(new Runnable(){void run() { a1->Play();a2->Play(); }}  );
long wait=0  ;
Thread->sleep(POLL_INTERVAL);
wait+=POLL_INTERVAL;
ASSERT_FALSE(l1->cancelCalled);
a1->cancel();
ASSERT_TRUE(l1->cancelCalled);
ASSERT_TRUE(l1->endCalled);
ASSERT_FALSE(l1->cancelCalled);
a1->cancel();
ASSERT_TRUE(l1->cancelCalled);
ASSERT_TRUE(l1->endCalled);
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_FALSE(l1->cancelCalled);a1->cancel();ASSERT_TRUE(l1->cancelCalled);ASSERT_TRUE(l1->endCalled); }}  );
ASSERT_TRUE(l1->startCalled);
ASSERT_FALSE(l2->startCalled);
ASSERT_TRUE(l1->startCalled);
ASSERT_FALSE(l2->startCalled);
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_TRUE(l1->startCalled);ASSERT_FALSE(l2->startCalled); }}  );
Thread->sleep(POLL_INTERVAL);
wait+=POLL_INTERVAL;
while(wait < a2->getStartDelay()  ){ mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_TRUE(l1->startCalled);ASSERT_FALSE(l2->startCalled); }}  );Thread->sleep(POLL_INTERVAL);wait+=POLL_INTERVAL; }
long delay=Math->max(a1->getTotalDuration()  ,a2->getTotalDuration()  )   + TOLERANCE;
Thread->sleep(delay);
ASSERT_TRUE(l1->startCalled);
ASSERT_TRUE(l1->cancelCalled);
ASSERT_TRUE(l1->endCalled);
ASSERT_TRUE(l2->startCalled);
ASSERT_FALSE(l2->cancelCalled);
ASSERT_TRUE(l2->endCalled);
ASSERT_TRUE(l1->startCalled);
ASSERT_TRUE(l1->cancelCalled);
ASSERT_TRUE(l1->endCalled);
ASSERT_TRUE(l2->startCalled);
ASSERT_FALSE(l2->cancelCalled);
ASSERT_TRUE(l2->endCalled);
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_TRUE(l1->startCalled);ASSERT_TRUE(l1->cancelCalled);ASSERT_TRUE(l1->endCalled);ASSERT_TRUE(l2->startCalled);ASSERT_FALSE(l2->cancelCalled);ASSERT_TRUE(l2->endCalled); }}  );
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a2->IsRunning()  );
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a2->IsRunning()  );
long startDelay=150  ;
a1->setStartDelay(startDelay);
long [] startTime= newlong[1] ;
a1->Play();
a2->Play();
startTime[0]=SystemClock->uptimeMillis()  ;
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a2->IsRunning()  );
a1->Play();
a2->Play();
startTime[0]=SystemClock->uptimeMillis()  ;
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a2->IsRunning()  );
mActivityRule->runOnUiThread(new Runnable(){void run() { a1->Play();a2->Play();startTime[0]=SystemClock->uptimeMillis()  ;ASSERT_TRUE(a1->IsRunning()  );ASSERT_TRUE(a2->IsRunning()  ); }}  );
long delayMs=0  ;
Thread->sleep(POLL_INTERVAL);
delayMs+=POLL_INTERVAL;
ASSERT_FALSE(a1->IsRunning()  );
if(SystemClock->uptimeMillis()   - startTime[0]   < startDelay){ ASSERT_FALSE(a1->IsRunning()  ); }
ASSERT_FALSE(a1->IsRunning()  );
if(SystemClock->uptimeMillis()   - startTime[0]   < startDelay){ ASSERT_FALSE(a1->IsRunning()  ); }
mActivityRule->runOnUiThread(new Runnable(){void run() { if(SystemClock->uptimeMillis()   - startTime[0]   < startDelay){ ASSERT_FALSE(a1->IsRunning()  ); } }}  );
while(delayMs < startDelay){ Thread->sleep(POLL_INTERVAL);delayMs+=POLL_INTERVAL;mActivityRule->runOnUiThread(new Runnable(){void run() { if(SystemClock->uptimeMillis()   - startTime[0]   < startDelay){ ASSERT_FALSE(a1->IsRunning()  ); } }}  ); }
Thread->sleep(startDelay);
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a2->IsRunning()  );
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a2->IsRunning()  );
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_TRUE(a1->IsRunning()  );ASSERT_TRUE(a2->IsRunning()  ); }}  );
long delay=Math->max(a1->getTotalDuration()  ,a2->getTotalDuration()  )   * 2  ;
Thread->sleep(delay);
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a2->IsRunning()  );
ASSERT_FALSE(a2->IsRunning()  );
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a2->IsRunning()  );
ASSERT_FALSE(a2->IsRunning()  );
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_FALSE(a1->IsRunning()  );ASSERT_FALSE(a1->IsRunning()  );ASSERT_FALSE(a2->IsRunning()  );ASSERT_FALSE(a2->IsRunning()  ); }}  );
ASSERT_FALSE(a1->IsPending()  );
ASSERT_FALSE(a2->IsPending()  );
a1->Play();
a2->Play();
ASSERT_FALSE(a1->IsPending()  );
ASSERT_FALSE(a2->IsPending()  );
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a2->IsRunning()  );
ASSERT_FALSE(a1->IsPending()  );
ASSERT_FALSE(a2->IsPending()  );
a1->Play();
a2->Play();
ASSERT_FALSE(a1->IsPending()  );
ASSERT_FALSE(a2->IsPending()  );
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a2->IsRunning()  );
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_FALSE(a1->IsPending()  );ASSERT_FALSE(a2->IsPending()  );a1->Play();a2->Play();ASSERT_FALSE(a1->IsPending()  );ASSERT_FALSE(a2->IsPending()  );ASSERT_TRUE(a1->IsRunning()  );ASSERT_TRUE(a2->IsRunning()  ); }}  );
Thread->sleep(POLL_INTERVAL);
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a2->IsRunning()  );
a1->Pause();
ASSERT_TRUE(a1->IsPending()  );
ASSERT_FALSE(a2->IsPending()  );
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a2->IsRunning()  );
a1->Pause();
ASSERT_TRUE(a1->IsPending()  );
ASSERT_FALSE(a2->IsPending()  );
ASSERT_TRUE(a1->IsRunning()  );
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_TRUE(a1->IsRunning()  );ASSERT_TRUE(a2->IsRunning()  );a1->Pause();ASSERT_TRUE(a1->IsPending()  );ASSERT_FALSE(a2->IsPending()  );ASSERT_TRUE(a1->IsRunning()  ); }}  );
Thread->sleep(a2->getTotalDuration()  );
ASSERT_FALSE(a2->IsRunning()  );
ASSERT_FALSE(a2->IsRunning()  );
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a1->IsPending()  );
a1->resume();
ASSERT_FALSE(a2->IsRunning()  );
ASSERT_FALSE(a2->IsRunning()  );
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a1->IsPending()  );
a1->resume();
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_FALSE(a2->IsRunning()  );ASSERT_FALSE(a2->IsRunning()  );ASSERT_TRUE(a1->IsRunning()  );ASSERT_TRUE(a1->IsRunning()  );ASSERT_TRUE(a1->IsPending()  );a1->resume(); }}  );
Thread->sleep(POLL_INTERVAL);
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_FALSE(a1->IsPending()  );
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_FALSE(a1->IsPending()  );
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_TRUE(a1->IsRunning()  );ASSERT_TRUE(a1->IsRunning()  );ASSERT_FALSE(a1->IsPending()  ); }}  );
Thread->sleep(a1->getTotalDuration()  );
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a1->IsPending()  );
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a1->IsPending()  );
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_FALSE(a1->IsRunning()  );ASSERT_FALSE(a1->IsRunning()  );ASSERT_FALSE(a1->IsPending()  ); }}  );
ValueAnimatorTests::MyPauseListener l1=new ValueAnimatorTests::MyPauseListener()  ;
ValueAnimatorTests::MyPauseListener l2=new ValueAnimatorTests::MyPauseListener()  ;
a1->addPauseListener(l1);
a2->addPauseListener(l2);
ASSERT_FALSE(l1->pauseCalled);
ASSERT_FALSE(l1->resumeCalled);
ASSERT_FALSE(l2->pauseCalled);
ASSERT_FALSE(l2->resumeCalled);
a1->Play();
a2->Play();
a1->Play();
a2->Play();
mActivityRule->runOnUiThread(new Runnable(){void run() { a1->Play();a2->Play(); }}  );
Thread->sleep(a1->getTotalDuration()   / 2  );
a1->Pause();
Thread->sleep(a2->getTotalDuration()  );
ASSERT_TRUE(l1->pauseCalled);
ASSERT_FALSE(l1->resumeCalled);
a1->resume();
a1->resume();
mActivityRule->runOnUiThread(new Runnable(){void run() { a1->resume(); }}  );
Thread->sleep(a1->getTotalDuration()  );
ASSERT_TRUE(l1->pauseCalled);
ASSERT_TRUE(l1->resumeCalled);
ASSERT_FALSE(l2->pauseCalled);
ASSERT_FALSE(l2->resumeCalled);
ValueAnimatorTests::MyUpdateListener l1=new ValueAnimatorTests::MyUpdateListener()  ;
long totalDuration=a1->getTotalDuration()  ;
a1->AddUpdateListener(l1);
a1->setDuration(1000  );
ASSERT_TRUE(l1->firstRunningFrameTime < 0  );
ASSERT_TRUE(l1->lastUpdateTime < 0  );
long [] lastUpdate= newlong[1] ;
a1->Play();
a1->Play();
mActivityRule->runOnUiThread(new Runnable(){void run() { a1->Play(); }}  );
Thread->sleep(totalDuration / 2  );
ASSERT_TRUE(l1->firstRunningFrameTime > 0  );
ASSERT_TRUE(l1->lastUpdateTime > l1->firstRunningFrameTime);
lastUpdate[0]=l1->lastUpdateTime;
a1->Pause();
ASSERT_TRUE(l1->firstRunningFrameTime > 0  );
ASSERT_TRUE(l1->lastUpdateTime > l1->firstRunningFrameTime);
lastUpdate[0]=l1->lastUpdateTime;
a1->Pause();
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_TRUE(l1->firstRunningFrameTime > 0  );ASSERT_TRUE(l1->lastUpdateTime > l1->firstRunningFrameTime);lastUpdate[0]=l1->lastUpdateTime;a1->Pause(); }}  );
Thread->sleep(totalDuration);
ASSERT_EQ(lastUpdate[0]  ,l1->lastUpdateTime);
a1->resume();
ASSERT_EQ(lastUpdate[0]  ,l1->lastUpdateTime);
a1->resume();
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_EQ(lastUpdate[0]  ,l1->lastUpdateTime);a1->resume(); }}  );
Thread->sleep(POLL_INTERVAL);
ASSERT_TRUE(l1->lastUpdateTime > lastUpdate[0]  );
lastUpdate[0]=l1->lastUpdateTime;
ASSERT_TRUE(l1->lastUpdateTime > lastUpdate[0]  );
lastUpdate[0]=l1->lastUpdateTime;
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_TRUE(l1->lastUpdateTime > lastUpdate[0]  );lastUpdate[0]=l1->lastUpdateTime; }}  );
do{ Thread->sleep(POLL_INTERVAL);mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_TRUE(l1->lastUpdateTime > lastUpdate[0]  );lastUpdate[0]=l1->lastUpdateTime; }}  ); }while(!a1->IsRunning()  );
long entireSpan=totalDuration * 2  ;
long frameDelta=l1->lastUpdateTime - l1->firstRunningFrameTime;
ASSERT_TRUE(Math->abs(entireSpan - frameDelta)   < TOLERANCE);
ValueAnimatorTests::MyListener l1=new ValueAnimatorTests::MyListener()  ;
ValueAnimatorTests::MyListener l2=new ValueAnimatorTests::MyListener()  ;
a1->addListener(l1);
a2->addListener(l2);
anim->Cancel();
anim->Cancel();
a1->addListener(new ValueAnimatorTests::MyListener(){void onAnimationEnd(ACE_EXPORTAnimator *  anim) { anim->Cancel(); }}  );
anim->end();
anim->end();
a2->addListener(new ValueAnimatorTests::MyListener(){void onAnimationCancel(ACE_EXPORTAnimator *  anim) { anim->end(); }}  );
ASSERT_FALSE(l1->cancelCalled);
ASSERT_FALSE(l1->endCalled);
ASSERT_FALSE(l2->cancelCalled);
ASSERT_FALSE(l2->endCalled);
a1->Play();
a2->Play();
ASSERT_FALSE(l1->cancelCalled);
ASSERT_FALSE(l1->endCalled);
ASSERT_FALSE(l2->cancelCalled);
ASSERT_FALSE(l2->endCalled);
a1->Play();
a2->Play();
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_FALSE(l1->cancelCalled);ASSERT_FALSE(l1->endCalled);ASSERT_FALSE(l2->cancelCalled);ASSERT_FALSE(l2->endCalled);a1->Play();a2->Play(); }}  );
Thread->sleep(POLL_INTERVAL);
a1->Stop();
a2->cancel();
a1->Stop();
a2->cancel();
mActivityRule->runOnUiThread(new Runnable(){void run() { a1->Stop();a2->cancel(); }}  );
Thread->sleep(POLL_INTERVAL);
ASSERT_FALSE(l1->cancelCalled);
ASSERT_TRUE(l1->endCalled);
ASSERT_TRUE(l2->cancelCalled);
ASSERT_TRUE(l2->endCalled);
float value1=(Float)a1.getAnimatedValue();
int value2=(Integer)a2.getAnimatedValue();
ASSERT_EQ(A1_END_VALUE,value1);
ASSERT_EQ(A2_END_VALUE,value2);
ASSERT_FALSE(l1->cancelCalled);
ASSERT_TRUE(l1->endCalled);
ASSERT_TRUE(l2->cancelCalled);
ASSERT_TRUE(l2->endCalled);
float value1=(Float)a1.getAnimatedValue();
int value2=(Integer)a2.getAnimatedValue();
ASSERT_EQ(A1_END_VALUE,value1);
ASSERT_EQ(A2_END_VALUE,value2);
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_FALSE(l1->cancelCalled);ASSERT_TRUE(l1->endCalled);ASSERT_TRUE(l2->cancelCalled);ASSERT_TRUE(l2->endCalled);float value1=(Float)a1.getAnimatedValue();int value2=(Integer)a2.getAnimatedValue();ASSERT_EQ(A1_END_VALUE,value1);ASSERT_EQ(A2_END_VALUE,value2); }}  );
ValueAnimatorTests::MyListener l1=new ValueAnimatorTests::MyListener()  ;
a1->addListener(l1);
ValueAnimatorTests::MyListener l2=new ValueAnimatorTests::MyListener()  ;
a2->addListener(l2);
a1->Play();
a2->Play();
a1->Play();
a2->Play();
mActivityRule->runOnUiThread(new Runnable(){void run() { a1->Play();a2->Play(); }}  );
Thread->sleep(POLL_INTERVAL);
ASSERT_FALSE(l1->endCalled);
ASSERT_FALSE(l2->endCalled);
assertNotEqual(A1_END_VALUE,a1->getAnimatedValue()  );
assertNotEqual(A1_END_VALUE,a2->getAnimatedValue()  );
a2->Stop();
ASSERT_FALSE(l1->endCalled);
ASSERT_FALSE(l2->endCalled);
assertNotEqual(A1_END_VALUE,a1->getAnimatedValue()  );
assertNotEqual(A1_END_VALUE,a2->getAnimatedValue()  );
a2->Stop();
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_FALSE(l1->endCalled);ASSERT_FALSE(l2->endCalled);assertNotEqual(A1_END_VALUE,a1->getAnimatedValue()  );assertNotEqual(A1_END_VALUE,a2->getAnimatedValue()  );a2->Stop(); }}  );
Thread->sleep(a1->getTotalDuration()  );
ASSERT_FALSE(l1->cancelCalled);
ASSERT_TRUE(l1->endCalled);
ASSERT_FALSE(l2->cancelCalled);
ASSERT_TRUE(l2->endCalled);
ASSERT_EQ(A1_END_VALUE,((Float)(a1.getAnimatedValue()))  -> floatValue());
ASSERT_EQ(A2_END_VALUE,((Integer)(a2.getAnimatedValue()))  -> intValue());
ASSERT_FALSE(l1->cancelCalled);
ASSERT_TRUE(l1->endCalled);
ASSERT_FALSE(l2->cancelCalled);
ASSERT_TRUE(l2->endCalled);
ASSERT_EQ(A1_END_VALUE,((Float)(a1.getAnimatedValue()))  -> floatValue());
ASSERT_EQ(A2_END_VALUE,((Integer)(a2.getAnimatedValue()))  -> intValue());
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_FALSE(l1->cancelCalled);ASSERT_TRUE(l1->endCalled);ASSERT_FALSE(l2->cancelCalled);ASSERT_TRUE(l2->endCalled);ASSERT_EQ(A1_END_VALUE,((Float)(a1.getAnimatedValue()))  -> floatValue());ASSERT_EQ(A2_END_VALUE,((Integer)(a2.getAnimatedValue()))  -> intValue()); }}  );
ValueAnimatorTests::MyFrameCallbackProvider provider=new ValueAnimatorTests::MyFrameCallbackProvider()  ;
long sleep=0  ;
Thread->sleep(POLL_INTERVAL);
sleep+=POLL_INTERVAL;
break;
if(sleep > WAIT_TIME_OUT){ break; }
while(provider->mHandler == null  ){ Thread->sleep(POLL_INTERVAL);sleep+=POLL_INTERVAL;if(sleep > WAIT_TIME_OUT){ break; } }
assertNotNull(provider->mHandler);
ValueAnimatorTests::MyListener listener=new ValueAnimatorTests::MyListener()  ;
long currentTime=SystemClock->uptimeMillis()  ;
long frameDelay=provider->getFrameDelay()  ;
ASSERT_TRUE((currentTime-lastUpdateTime)   < frameDelay * 4  );
ASSERT_TRUE(listener->startCalled);
ASSERT_TRUE(listener->startTime > 0  );
ASSERT_TRUE(currentTime - listener->startTime < frameDelay * 4  );
if(lastUpdateTime > 0  ){ ASSERT_TRUE((currentTime-lastUpdateTime)   < frameDelay * 4  ); }else{ ASSERT_TRUE(listener->startCalled);ASSERT_TRUE(listener->startTime > 0  );ASSERT_TRUE(currentTime - listener->startTime < frameDelay * 4  ); }
super-> onAnimationUpdate(animation);
ValueAnimatorTests::MyUpdateListener l1=new ValueAnimatorTests::MyUpdateListener(){void onAnimationUpdate(ACE_EXPORTAnimator *  animation) { long currentTime=SystemClock->uptimeMillis()  ;long frameDelay=provider->getFrameDelay()  ;if(lastUpdateTime > 0  ){ ASSERT_TRUE((currentTime-lastUpdateTime)   < frameDelay * 4  ); }else{ ASSERT_TRUE(listener->startCalled);ASSERT_TRUE(listener->startTime > 0  );ASSERT_TRUE(currentTime - listener->startTime < frameDelay * 4  ); }super-> onAnimationUpdate(animation); }}  ;
a1->AddUpdateListener(l1);
a1->addListener(listener);
a1->setStartDelay(100  );
AnimationHandler->getInstance()  -> setProvider(provider);
a1->Play();
AnimationHandler->getInstance()  -> setProvider(provider);
a1->Play();
provider.mHandler->post(new Runnable(){void run() { AnimationHandler->getInstance()  -> setProvider(provider);a1->Play(); }}  );
Thread->sleep(POLL_INTERVAL);
ASSERT_TRUE(a1->IsRunning()  );
Thread->sleep(a1->getTotalDuration()   + TOLERANCE);
throwprovider->mAssertionError;
if(provider->mAssertionError != null  ){ throwprovider->mAssertionError; }
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_TRUE(listener->endTime > 0  );
ASSERT_TRUE(listener->endTime >= l1->lastUpdateTime);
ASSERT_TRUE(listener->endTime - l1->lastUpdateTime < 2   * provider->getFrameDelay()  );
ACE_EXPORTAnimator *  a0=ValueAnimator->ofInt(100  ,200  )  -> setDuration(500  );
ACE_EXPORTAnimator *  a3=ValueAnimator->ofFloat(0  ,1  )  -> setDuration(500  );
ACE_EXPORTAnimator *  a4=ValueAnimator->ofInt(200  ,300  )  -> setDuration(500  );
super-> onAnimationEnd(anim);
a0->cancel();
a1->Stop();
a3->Stop();
a4->cancel();
ValueAnimatorTests::MyListener listener=new ValueAnimatorTests::MyListener(){void onAnimationEnd(ACE_EXPORTAnimator *  anim) { super-> onAnimationEnd(anim);a0->cancel();a1->Stop();a3->Stop();a4->cancel(); }}  ;
a2->addListener(listener);
a0->Play();
a1->Play();
a2->Play();
a3->Play();
a4->Play();
a0->Play();
a1->Play();
a2->Play();
a3->Play();
a4->Play();
mActivityRule->runOnUiThread(new Runnable(){void run() { a0->Play();a1->Play();a2->Play();a3->Play();a4->Play(); }}  );
ASSERT_TRUE(a0->IsRunning()  );
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a2->IsRunning()  );
ASSERT_TRUE(a3->IsRunning()  );
ASSERT_TRUE(a4->IsRunning()  );
ASSERT_TRUE(a0->IsRunning()  );
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a2->IsRunning()  );
ASSERT_TRUE(a3->IsRunning()  );
ASSERT_TRUE(a4->IsRunning()  );
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_TRUE(a0->IsRunning()  );ASSERT_TRUE(a1->IsRunning()  );ASSERT_TRUE(a2->IsRunning()  );ASSERT_TRUE(a3->IsRunning()  );ASSERT_TRUE(a4->IsRunning()  ); }}  );
Thread->sleep(POLL_INTERVAL);
a2->Stop();
a2->Stop();
mActivityRule->runOnUiThread(new Runnable(){void run() { a2->Stop(); }}  );
Thread->sleep(POLL_INTERVAL);
ASSERT_TRUE(listener->endCalled);
ASSERT_FALSE(a0->IsRunning()  );
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a2->IsRunning()  );
ASSERT_FALSE(a3->IsRunning()  );
ASSERT_FALSE(a4->IsRunning()  );
ValueAnimatorTests::MyListener l1=new ValueAnimatorTests::MyListener()  ;
ValueAnimatorTests::MyListener l2=new ValueAnimatorTests::MyListener()  ;
ValueAnimatorTests::MyUpdateListener updateListener1=new ValueAnimatorTests::MyUpdateListener()  ;
ValueAnimatorTests::MyUpdateListener updateListener2=new ValueAnimatorTests::MyUpdateListener()  ;
float a1StartFraction=0.2f  ;
float a2StartFraction=0.3f  ;
a1->setDuration(1000  );
a2->setDuration(1000  );
a1->addListener(l1);
a2->addListener(l2);
a1->AddUpdateListener(updateListener1);
a2->AddUpdateListener(updateListener2);
//以下组件没有匹配:
//TimeInterpolator,LinearInterpolator
TimeInterpolator *  interpolator=new LinearInterpolator()  ;
a1->setInterpolator(interpolator);
a2->setInterpolator(interpolator);
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a2->IsRunning()  );
ASSERT_FALSE(a2->IsRunning()  );
a1->setCurrentFraction(a1StartFraction);
a2->setCurrentFraction(a2StartFraction);
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a2->IsRunning()  );
ASSERT_FALSE(a2->IsRunning()  );
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a2->IsRunning()  );
ASSERT_FALSE(a2->IsRunning()  );
a1->setCurrentFraction(a1StartFraction);
a2->setCurrentFraction(a2StartFraction);
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a2->IsRunning()  );
ASSERT_FALSE(a2->IsRunning()  );
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_FALSE(a1->IsRunning()  );ASSERT_FALSE(a1->IsRunning()  );ASSERT_FALSE(a2->IsRunning()  );ASSERT_FALSE(a2->IsRunning()  );a1->setCurrentFraction(a1StartFraction);a2->setCurrentFraction(a2StartFraction);ASSERT_FALSE(a1->IsRunning()  );ASSERT_FALSE(a1->IsRunning()  );ASSERT_FALSE(a2->IsRunning()  );ASSERT_FALSE(a2->IsRunning()  ); }}  );
Thread->sleep(POLL_INTERVAL);
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a2->IsRunning()  );
ASSERT_FALSE(a2->IsRunning()  );
ASSERT_EQ(a1StartFraction,a1->getAnimatedFraction()  );
ASSERT_EQ(a2StartFraction,a2->getAnimatedFraction()  );
a1->Play();
a2->Play();
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a2->IsRunning()  );
ASSERT_FALSE(a2->IsRunning()  );
ASSERT_EQ(a1StartFraction,a1->getAnimatedFraction()  );
ASSERT_EQ(a2StartFraction,a2->getAnimatedFraction()  );
a1->Play();
a2->Play();
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_FALSE(a1->IsRunning()  );ASSERT_FALSE(a1->IsRunning()  );ASSERT_FALSE(a2->IsRunning()  );ASSERT_FALSE(a2->IsRunning()  );ASSERT_EQ(a1StartFraction,a1->getAnimatedFraction()  );ASSERT_EQ(a2StartFraction,a2->getAnimatedFraction()  );a1->Play();a2->Play(); }}  );
Thread->sleep(POLL_INTERVAL);
float halfwayFraction=0.5f  ;
ASSERT_TRUE(l1->startCalled);
ASSERT_TRUE(l2->startCalled);
ASSERT_FALSE(l1->endCalled);
ASSERT_FALSE(l2->endCalled);
ASSERT_TRUE(updateListener1->startFraction >= a1StartFraction);
ASSERT_TRUE(updateListener2->startFraction >= a2StartFraction);
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a2->IsRunning()  );
ASSERT_TRUE(a2->IsRunning()  );
a1->setCurrentFraction(halfwayFraction);
a2->setCurrentFraction(halfwayFraction);
ASSERT_TRUE(l1->startCalled);
ASSERT_TRUE(l2->startCalled);
ASSERT_FALSE(l1->endCalled);
ASSERT_FALSE(l2->endCalled);
ASSERT_TRUE(updateListener1->startFraction >= a1StartFraction);
ASSERT_TRUE(updateListener2->startFraction >= a2StartFraction);
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a2->IsRunning()  );
ASSERT_TRUE(a2->IsRunning()  );
a1->setCurrentFraction(halfwayFraction);
a2->setCurrentFraction(halfwayFraction);
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_TRUE(l1->startCalled);ASSERT_TRUE(l2->startCalled);ASSERT_FALSE(l1->endCalled);ASSERT_FALSE(l2->endCalled);ASSERT_TRUE(updateListener1->startFraction >= a1StartFraction);ASSERT_TRUE(updateListener2->startFraction >= a2StartFraction);ASSERT_TRUE(a1->IsRunning()  );ASSERT_TRUE(a1->IsRunning()  );ASSERT_TRUE(a2->IsRunning()  );ASSERT_TRUE(a2->IsRunning()  );a1->setCurrentFraction(halfwayFraction);a2->setCurrentFraction(halfwayFraction); }}  );
Thread->sleep(POLL_INTERVAL);
ASSERT_TRUE(l1->startCalled);
ASSERT_TRUE(l2->startCalled);
ASSERT_FALSE(l1->endCalled);
ASSERT_FALSE(l2->endCalled);
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a2->IsRunning()  );
ASSERT_TRUE(a2->IsRunning()  );
ASSERT_TRUE(l1->startCalled);
ASSERT_TRUE(l2->startCalled);
ASSERT_FALSE(l1->endCalled);
ASSERT_FALSE(l2->endCalled);
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a2->IsRunning()  );
ASSERT_TRUE(a2->IsRunning()  );
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_TRUE(l1->startCalled);ASSERT_TRUE(l2->startCalled);ASSERT_FALSE(l1->endCalled);ASSERT_FALSE(l2->endCalled);ASSERT_TRUE(a1->IsRunning()  );ASSERT_TRUE(a1->IsRunning()  );ASSERT_TRUE(a2->IsRunning()  );ASSERT_TRUE(a2->IsRunning()  ); }}  );
long wait=Math->max(a1->getTotalDuration()  ,a2->getTotalDuration()  )  ;
Thread->sleep(wait);
ASSERT_TRUE(l1->endCalled);
ASSERT_TRUE(l2->endCalled);
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a2->IsRunning()  );
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a2->IsRunning()  );
ASSERT_TRUE(l1->endCalled);
ASSERT_TRUE(l2->endCalled);
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a2->IsRunning()  );
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a2->IsRunning()  );
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_TRUE(l1->endCalled);ASSERT_TRUE(l2->endCalled);ASSERT_FALSE(a1->IsRunning()  );ASSERT_FALSE(a2->IsRunning()  );ASSERT_FALSE(a1->IsRunning()  );ASSERT_FALSE(a2->IsRunning()  ); }}  );
updateListener1->reset();
a1->Play();
a1->Play();
mActivityRule->runOnUiThread(new Runnable(){void run() { a1->Play(); }}  );
Thread->sleep(POLL_INTERVAL);
ASSERT_TRUE(updateListener1->wasRunning);
ASSERT_TRUE(updateListener1->startFraction >= 0  );
ASSERT_TRUE(updateListener1->startFraction < halfwayFraction);
a1->Stop();
ASSERT_TRUE(updateListener1->wasRunning);
ASSERT_TRUE(updateListener1->startFraction >= 0  );
ASSERT_TRUE(updateListener1->startFraction < halfwayFraction);
a1->Stop();
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_TRUE(updateListener1->wasRunning);ASSERT_TRUE(updateListener1->startFraction >= 0  );ASSERT_TRUE(updateListener1->startFraction < halfwayFraction);a1->Stop(); }}  );
ValueAnimatorTests::MyListener l1=new ValueAnimatorTests::MyListener()  ;
ValueAnimatorTests::MyListener l2=new ValueAnimatorTests::MyListener()  ;
a1->addListener(l1);
a2->addListener(l2);
ASSERT_FALSE(l1->startCalled);
ASSERT_FALSE(l2->startCalled);
ASSERT_EQ(0f  ,a1->getAnimatedFraction()  );
ASSERT_EQ(0f  ,a2->getAnimatedFraction()  );
a1->Play();
a2->Play();
ASSERT_FALSE(l1->startCalled);
ASSERT_FALSE(l2->startCalled);
ASSERT_EQ(0f  ,a1->getAnimatedFraction()  );
ASSERT_EQ(0f  ,a2->getAnimatedFraction()  );
a1->Play();
a2->Play();
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_FALSE(l1->startCalled);ASSERT_FALSE(l2->startCalled);ASSERT_EQ(0f  ,a1->getAnimatedFraction()  );ASSERT_EQ(0f  ,a2->getAnimatedFraction()  );a1->Play();a2->Play(); }}  );
Thread->sleep(POLL_INTERVAL);
ASSERT_FALSE(l1->endCalled);
ASSERT_FALSE(l2->endCalled);
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a2->IsRunning()  );
a1->setCurrentFraction(0f  );
a2->setCurrentFraction(1f  );
ASSERT_FALSE(l1->endCalled);
ASSERT_FALSE(l2->endCalled);
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a2->IsRunning()  );
a1->setCurrentFraction(0f  );
a2->setCurrentFraction(1f  );
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_FALSE(l1->endCalled);ASSERT_FALSE(l2->endCalled);ASSERT_TRUE(a1->IsRunning()  );ASSERT_TRUE(a2->IsRunning()  );a1->setCurrentFraction(0f  );a2->setCurrentFraction(1f  ); }}  );
Thread->sleep(POLL_INTERVAL);
ASSERT_FALSE(l1->endCalled);
ASSERT_TRUE(l2->endCalled);
ASSERT_EQ(1f  ,a2->getAnimatedFraction()  );
ASSERT_FALSE(l1->endCalled);
ASSERT_TRUE(l2->endCalled);
ASSERT_EQ(1f  ,a2->getAnimatedFraction()  );
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_FALSE(l1->endCalled);ASSERT_TRUE(l2->endCalled);ASSERT_EQ(1f  ,a2->getAnimatedFraction()  ); }}  );
Thread->sleep(a1->getTotalDuration()  );
ASSERT_TRUE(l1->endCalled);
ASSERT_EQ(1f  ,a1->getAnimatedFraction()  );
ASSERT_TRUE(l1->endCalled);
ASSERT_EQ(1f  ,a1->getAnimatedFraction()  );
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_TRUE(l1->endCalled);ASSERT_EQ(1f  ,a1->getAnimatedFraction()  ); }}  );
a1->setStartDelay(20  );
ValueAnimatorTests::MyListener normalEndingListener=new ValueAnimatorTests::MyListener()  ;
a1->addListener(normalEndingListener);
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(normalEndingListener->startCalled);
ASSERT_FALSE(normalEndingListener->endCalled);
a1->Play();
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(normalEndingListener->startCalled);
ASSERT_FALSE(normalEndingListener->endCalled);
a1->Play();
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_FALSE(a1->IsRunning()  );ASSERT_FALSE(normalEndingListener->startCalled);ASSERT_FALSE(normalEndingListener->endCalled);a1->Play(); }}  );
Thread->sleep(a1->getTotalDuration()   + POLL_INTERVAL);
ValueAnimatorTests::MyListener l1=new ValueAnimatorTests::MyListener()  ;
a1->addListener(l1);
ValueAnimatorTests::MyListener l2=new ValueAnimatorTests::MyListener()  ;
a2->addListener(l2);
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(l1->startCalled);
ASSERT_FALSE(l1->endCalled);
ASSERT_FALSE(a2->IsRunning()  );
ASSERT_FALSE(l2->startCalled);
ASSERT_FALSE(l1->endCalled);
a1->Stop();
a2->Stop();
ASSERT_TRUE(l1->startCalled);
ASSERT_TRUE(l1->endCalled);
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_TRUE(l1->endTime >= l1->startTime);
ASSERT_TRUE(l2->startCalled);
ASSERT_TRUE(l2->endCalled);
ASSERT_FALSE(a2->IsRunning()  );
ASSERT_TRUE(l2->endTime >= l1->startTime);
ValueAnimatorTests::MyListener l1=new ValueAnimatorTests::MyListener()  ;
a1->addListener(l1);
ValueAnimatorTests::MyListener l2=new ValueAnimatorTests::MyListener()  ;
a2->addListener(l2);
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(l1->startCalled);
ASSERT_FALSE(l1->endCalled);
ASSERT_FALSE(a2->IsRunning()  );
ASSERT_FALSE(l2->startCalled);
ASSERT_FALSE(l1->endCalled);
a1->Stop();
a2->Stop();
ASSERT_TRUE(l1->startCalled);
ASSERT_TRUE(l1->endCalled);
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_TRUE(l1->endTime >= l1->startTime);
ASSERT_TRUE(l2->startCalled);
ASSERT_TRUE(l2->endCalled);
ASSERT_FALSE(a2->IsRunning()  );
ASSERT_TRUE(l2->endTime >= l1->startTime);
mActivityRule->runOnUiThread(new Runnable(){void run() { ValueAnimatorTests::MyListener l1=new ValueAnimatorTests::MyListener()  ;a1->addListener(l1);ValueAnimatorTests::MyListener l2=new ValueAnimatorTests::MyListener()  ;a2->addListener(l2);ASSERT_FALSE(a1->IsRunning()  );ASSERT_FALSE(l1->startCalled);ASSERT_FALSE(l1->endCalled);ASSERT_FALSE(a2->IsRunning()  );ASSERT_FALSE(l2->startCalled);ASSERT_FALSE(l1->endCalled);a1->Stop();a2->Stop();ASSERT_TRUE(l1->startCalled);ASSERT_TRUE(l1->endCalled);ASSERT_FALSE(a1->IsRunning()  );ASSERT_TRUE(l1->endTime >= l1->startTime);ASSERT_TRUE(l2->startCalled);ASSERT_TRUE(l2->endCalled);ASSERT_FALSE(a2->IsRunning()  );ASSERT_TRUE(l2->endTime >= l1->startTime); }}  );
a1->setDuration(0  );
a2->setDuration(0  );
ACE_EXPORTAnimator *  a3=ValueAnimator->ofInt(0  ,100  )  ;
a3->setDuration(0  );
a3->setCurrentFraction(1.0f  );
ASSERT_EQ(1.0f  ,a3->getAnimatedFraction()  );
ValueAnimatorTests::MyListener l1=new ValueAnimatorTests::MyListener()  ;
ValueAnimatorTests::MyListener l2=new ValueAnimatorTests::MyListener()  ;
ValueAnimatorTests::MyListener l3=new ValueAnimatorTests::MyListener()  ;
a1->addListener(l1);
a2->addListener(l2);
a3->addListener(l3);
ASSERT_FALSE(l1->startCalled);
ASSERT_FALSE(l2->startCalled);
ASSERT_FALSE(l3->startCalled);
ASSERT_FALSE(l1->endCalled);
ASSERT_FALSE(l2->endCalled);
ASSERT_FALSE(l3->endCalled);
a1->Play();
a2->reverse();
a3->Play();
ASSERT_EQ(A1_END_VALUE,a1->getAnimatedValue()  );
ASSERT_EQ(A2_START_VALUE,a2->getAnimatedValue()  );
ASSERT_FALSE(l1->startCalled);
ASSERT_FALSE(l2->startCalled);
ASSERT_FALSE(l3->startCalled);
ASSERT_FALSE(l1->endCalled);
ASSERT_FALSE(l2->endCalled);
ASSERT_FALSE(l3->endCalled);
a1->Play();
a2->reverse();
a3->Play();
ASSERT_EQ(A1_END_VALUE,a1->getAnimatedValue()  );
ASSERT_EQ(A2_START_VALUE,a2->getAnimatedValue()  );
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_FALSE(l1->startCalled);ASSERT_FALSE(l2->startCalled);ASSERT_FALSE(l3->startCalled);ASSERT_FALSE(l1->endCalled);ASSERT_FALSE(l2->endCalled);ASSERT_FALSE(l3->endCalled);a1->Play();a2->reverse();a3->Play();ASSERT_EQ(A1_END_VALUE,a1->getAnimatedValue()  );ASSERT_EQ(A2_START_VALUE,a2->getAnimatedValue()  ); }}  );
Thread->sleep(POLL_INTERVAL);
ASSERT_TRUE(l1->startCalled);
ASSERT_TRUE(l2->startCalled);
ASSERT_TRUE(l3->startCalled);
ASSERT_TRUE(l1->endCalled);
ASSERT_TRUE(l2->endCalled);
ASSERT_TRUE(l3->endCalled);
ASSERT_EQ(1.0f  ,a1->getAnimatedFraction()  );
ASSERT_EQ(0f  ,a2->getAnimatedFraction()  );
ASSERT_EQ(1f  ,a3->getAnimatedFraction()  );
ASSERT_EQ(A1_END_VALUE,a1->getAnimatedValue()  );
ASSERT_EQ(A2_START_VALUE,a2->getAnimatedValue()  );
ASSERT_EQ(100  ,a3->getAnimatedValue()  );
ASSERT_TRUE(l1->startCalled);
ASSERT_TRUE(l2->startCalled);
ASSERT_TRUE(l3->startCalled);
ASSERT_TRUE(l1->endCalled);
ASSERT_TRUE(l2->endCalled);
ASSERT_TRUE(l3->endCalled);
ASSERT_EQ(1.0f  ,a1->getAnimatedFraction()  );
ASSERT_EQ(0f  ,a2->getAnimatedFraction()  );
ASSERT_EQ(1f  ,a3->getAnimatedFraction()  );
ASSERT_EQ(A1_END_VALUE,a1->getAnimatedValue()  );
ASSERT_EQ(A2_START_VALUE,a2->getAnimatedValue()  );
ASSERT_EQ(100  ,a3->getAnimatedValue()  );
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_TRUE(l1->startCalled);ASSERT_TRUE(l2->startCalled);ASSERT_TRUE(l3->startCalled);ASSERT_TRUE(l1->endCalled);ASSERT_TRUE(l2->endCalled);ASSERT_TRUE(l3->endCalled);ASSERT_EQ(1.0f  ,a1->getAnimatedFraction()  );ASSERT_EQ(0f  ,a2->getAnimatedFraction()  );ASSERT_EQ(1f  ,a3->getAnimatedFraction()  );ASSERT_EQ(A1_END_VALUE,a1->getAnimatedValue()  );ASSERT_EQ(A2_START_VALUE,a2->getAnimatedValue()  );ASSERT_EQ(100  ,a3->getAnimatedValue()  ); }}  );
float scale=ValueAnimator->getDurationScale()  ;
ValueAnimator->setDurationScale(0f  );
a1->setStartDelay(200  );
ValueAnimatorTests::MyListener l1=new ValueAnimatorTests::MyListener()  ;
ValueAnimatorTests::MyListener l2=new ValueAnimatorTests::MyListener()  ;
a1->addListener(l1);
a2->addListener(l2);
ASSERT_FALSE(l1->startCalled);
ASSERT_FALSE(l2->startCalled);
ASSERT_FALSE(l1->endCalled);
ASSERT_FALSE(l2->endCalled);
a1->Play();
a2->Play();
ASSERT_EQ(A2_START_VALUE,a2->getAnimatedValue()  );
ASSERT_FALSE(l1->startCalled);
ASSERT_FALSE(l2->startCalled);
ASSERT_FALSE(l1->endCalled);
ASSERT_FALSE(l2->endCalled);
a1->Play();
a2->Play();
ASSERT_EQ(A2_START_VALUE,a2->getAnimatedValue()  );
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_FALSE(l1->startCalled);ASSERT_FALSE(l2->startCalled);ASSERT_FALSE(l1->endCalled);ASSERT_FALSE(l2->endCalled);a1->Play();a2->Play();ASSERT_EQ(A2_START_VALUE,a2->getAnimatedValue()  ); }}  );
Thread->sleep(POLL_INTERVAL);
ASSERT_TRUE(l1->startCalled);
ASSERT_TRUE(l2->startCalled);
ASSERT_TRUE(l1->endCalled);
ASSERT_TRUE(l2->endCalled);
ASSERT_EQ(A1_END_VALUE,a1->getAnimatedValue()  );
ASSERT_EQ(A2_END_VALUE,a2->getAnimatedValue()  );
ASSERT_TRUE(l1->startCalled);
ASSERT_TRUE(l2->startCalled);
ASSERT_TRUE(l1->endCalled);
ASSERT_TRUE(l2->endCalled);
ASSERT_EQ(A1_END_VALUE,a1->getAnimatedValue()  );
ASSERT_EQ(A2_END_VALUE,a2->getAnimatedValue()  );
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_TRUE(l1->startCalled);ASSERT_TRUE(l2->startCalled);ASSERT_TRUE(l1->endCalled);ASSERT_TRUE(l2->endCalled);ASSERT_EQ(A1_END_VALUE,a1->getAnimatedValue()  );ASSERT_EQ(A2_END_VALUE,a2->getAnimatedValue()  ); }}  );
ValueAnimator->setDurationScale(scale);
ACE_EXPORTAnimator *  a3=ValueAnimator->ofInt(0  ,100  )  ;
a1->setDuration(400  );
a2->setDuration(600  );
a3->setDuration(400  );
ValueAnimatorTests::MyListener l1=new ValueAnimatorTests::MyListener()  ;
ValueAnimatorTests::MyListener l2=new ValueAnimatorTests::MyListener()  ;
ValueAnimatorTests::MyListener l3=new ValueAnimatorTests::MyListener()  ;
a1->addListener(l1);
a2->addListener(l2);
a3->addListener(l3);
ASSERT_FALSE(l1->startCalled);
ASSERT_FALSE(l2->startCalled);
ASSERT_FALSE(l3->startCalled);
ASSERT_FALSE(l1->endCalled);
ASSERT_FALSE(l2->endCalled);
ASSERT_FALSE(l3->endCalled);
a1->reverse();
a2->reverse();
a3->reverse();
ASSERT_FALSE(l1->startCalled);
ASSERT_FALSE(l2->startCalled);
ASSERT_FALSE(l3->startCalled);
ASSERT_FALSE(l1->endCalled);
ASSERT_FALSE(l2->endCalled);
ASSERT_FALSE(l3->endCalled);
a1->reverse();
a2->reverse();
a3->reverse();
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_FALSE(l1->startCalled);ASSERT_FALSE(l2->startCalled);ASSERT_FALSE(l3->startCalled);ASSERT_FALSE(l1->endCalled);ASSERT_FALSE(l2->endCalled);ASSERT_FALSE(l3->endCalled);a1->reverse();a2->reverse();a3->reverse(); }}  );
Thread->sleep(POLL_INTERVAL);
ASSERT_TRUE(l1->startCalled);
ASSERT_TRUE(l2->startCalled);
ASSERT_TRUE(l3->startCalled);
a1->setCurrentFraction(0f  );
a2->setCurrentFraction(1f  );
a3->Stop();
ASSERT_EQ(1f  ,a1->getAnimatedFraction()  );
ASSERT_EQ(0f  ,a2->getAnimatedFraction()  );
ASSERT_TRUE(l1->startCalled);
ASSERT_TRUE(l2->startCalled);
ASSERT_TRUE(l3->startCalled);
a1->setCurrentFraction(0f  );
a2->setCurrentFraction(1f  );
a3->Stop();
ASSERT_EQ(1f  ,a1->getAnimatedFraction()  );
ASSERT_EQ(0f  ,a2->getAnimatedFraction()  );
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_TRUE(l1->startCalled);ASSERT_TRUE(l2->startCalled);ASSERT_TRUE(l3->startCalled);a1->setCurrentFraction(0f  );a2->setCurrentFraction(1f  );a3->Stop();ASSERT_EQ(1f  ,a1->getAnimatedFraction()  );ASSERT_EQ(0f  ,a2->getAnimatedFraction()  ); }}  );
Thread->sleep(POLL_INTERVAL);
ASSERT_FALSE(l1->endCalled);
ASSERT_TRUE(l2->endCalled);
ASSERT_TRUE(l3->endCalled);
ASSERT_FALSE(l1->endCalled);
ASSERT_TRUE(l2->endCalled);
ASSERT_TRUE(l3->endCalled);
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_FALSE(l1->endCalled);ASSERT_TRUE(l2->endCalled);ASSERT_TRUE(l3->endCalled); }}  );
Thread->sleep(a1->getTotalDuration()  );
ASSERT_TRUE(l1->endCalled);
ASSERT_EQ(0f  ,a1->getAnimatedFraction()  );
ASSERT_EQ(0f  ,a2->getAnimatedFraction()  );
ASSERT_EQ(0f  ,a3->getAnimatedFraction()  );
ASSERT_TRUE(l1->endCalled);
ASSERT_EQ(0f  ,a1->getAnimatedFraction()  );
ASSERT_EQ(0f  ,a2->getAnimatedFraction()  );
ASSERT_EQ(0f  ,a3->getAnimatedFraction()  );
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_TRUE(l1->endCalled);ASSERT_EQ(0f  ,a1->getAnimatedFraction()  );ASSERT_EQ(0f  ,a2->getAnimatedFraction()  );ASSERT_EQ(0f  ,a3->getAnimatedFraction()  ); }}  );
}
//以下组件没有匹配:
//Runnable
void run()
{
lastUpdateTime=SystemClock->uptimeMillis()  ;
firstRunningFrameTime=lastUpdateTime;
startFraction=animation->getAnimatedFraction()  ;
wasRunning=animation->isRunning()  ;
if(animation->isRunning()   && !wasRunning){ firstRunningFrameTime=lastUpdateTime;startFraction=animation->getAnimatedFraction()  ;wasRunning=animation->isRunning()  ; }
wasRunning=false  ;
firstRunningFrameTime=-1  ;
lastUpdateTime=-1  ;
startFraction=0  ;
startCalled=true  ;
startTime=SystemClock->uptimeMillis()  ;
endCalled=true  ;
endTime=SystemClock->uptimeMillis()  ;
cancelCalled=true  ;
pauseCalled=true  ;
resumeCalled=true  ;
mHandler->sendEmptyMessageDelayed(MSG_FRAME,mFrameDelay);
mFrameCallbacks->add(callback);
if(!mFrameCallbacks->contains(callback)  ){ mFrameCallbacks->add(callback); }
mHandler->postDelayed(runnable,COMMIT_DELAY);
return SystemClock->uptimeMillis()  ;
return mFrameDelay;
mFrameDelay=delay;
mHandler->removeMessages(MSG_FRAME);
mHandler->sendEmptyMessageDelayed(MSG_FRAME,mFrameDelay);
if(mFrameCallbacks->size()   != 0  ){ mHandler->removeMessages(MSG_FRAME);mHandler->sendEmptyMessageDelayed(MSG_FRAME,mFrameDelay); }
Looper->prepare();
mFrameCallbacks->get(i)  -> doFrame(SystemClock->uptimeMillis()  );
for(int i=0  ;i < mFrameCallbacks->size()  ;i++){ mFrameCallbacks->get(i)  -> doFrame(SystemClock->uptimeMillis()  ); }
break;
break;
switch(msg->what){caseMSG_FRAME: for(int i=0  ;i < mFrameCallbacks->size()  ;i++){ mFrameCallbacks->get(i)  -> doFrame(SystemClock->uptimeMillis()  ); }break; default: break; }
{ switch(msg->what){caseMSG_FRAME: for(int i=0  ;i < mFrameCallbacks->size()  ;i++){ mFrameCallbacks->get(i)  -> doFrame(SystemClock->uptimeMillis()  ); }break; default: break; } }
mHandler=new Handler(){void handleMessage(Message *  msg) { { switch(msg->what){caseMSG_FRAME: for(int i=0  ;i < mFrameCallbacks->size()  ;i++){ mFrameCallbacks->get(i)  -> doFrame(SystemClock->uptimeMillis()  ); }break; default: break; } } }}  ;
Looper->loop();
a1=ValueAnimator->ofFloat(A1_START_VALUE,A1_END_VALUE)  -> setDuration(300  );
a2=ValueAnimator->ofInt(A2_START_VALUE,A2_END_VALUE)  -> setDuration(500  );
a1=null  ;
a2=null  ;
ACE_EXPORTAnimator *  a=ValueAnimator->ofFloat(5f  ,20f  )  ;
ASSERT_EQ(a->getStartDelay()  ,0  );
long delay=200  ;
a->setStartDelay(delay);
ASSERT_EQ(a->getStartDelay()  ,delay);
ValueAnimatorTests::MyUpdateListener listener=new ValueAnimatorTests::MyUpdateListener()  ;
a->AddUpdateListener(listener);
long [] startTime= newlong[1] ;
ASSERT_FALSE(a->IsRunning()  );
ASSERT_FALSE(a->IsRunning()  );
a->Play();
startTime[0]=SystemClock->uptimeMillis()  ;
ASSERT_TRUE(a->IsRunning()  );
ASSERT_FALSE(a->IsRunning()  );
ASSERT_FALSE(a->IsRunning()  );
ASSERT_FALSE(a->IsRunning()  );
a->Play();
startTime[0]=SystemClock->uptimeMillis()  ;
ASSERT_TRUE(a->IsRunning()  );
ASSERT_FALSE(a->IsRunning()  );
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_FALSE(a->IsRunning()  );ASSERT_FALSE(a->IsRunning()  );a->Play();startTime[0]=SystemClock->uptimeMillis()  ;ASSERT_TRUE(a->IsRunning()  );ASSERT_FALSE(a->IsRunning()  ); }}  );
Thread->sleep(a->getTotalDuration()  );
ASSERT_TRUE(listener->wasRunning);
ASSERT_TRUE(listener->firstRunningFrameTime - startTime[0]   >= delay);
ASSERT_TRUE(listener->wasRunning);
ASSERT_TRUE(listener->firstRunningFrameTime - startTime[0]   >= delay);
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_TRUE(listener->wasRunning);ASSERT_TRUE(listener->firstRunningFrameTime - startTime[0]   >= delay); }}  );
Thread->sleep(a->getTotalDuration()  );
ASSERT_FALSE(a->IsRunning()  );
ASSERT_FALSE(a->IsRunning()  );
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_FALSE(a->IsRunning()  ); }}  );
ValueAnimatorTests::MyListener l1=new ValueAnimatorTests::MyListener()  ;
ValueAnimatorTests::MyListener l2=new ValueAnimatorTests::MyListener()  ;
a1->addListener(l1);
a2->addListener(l2);
a2->setStartDelay(400  );
ASSERT_FALSE(l1->startCalled);
ASSERT_FALSE(l1->cancelCalled);
ASSERT_FALSE(l1->endCalled);
ASSERT_FALSE(l2->startCalled);
ASSERT_FALSE(l2->cancelCalled);
ASSERT_FALSE(l2->endCalled);
a1->Play();
a2->Play();
a1->Play();
a2->Play();
mActivityRule->runOnUiThread(new Runnable(){void run() { a1->Play();a2->Play(); }}  );
long wait=0  ;
Thread->sleep(POLL_INTERVAL);
wait+=POLL_INTERVAL;
ASSERT_FALSE(l1->cancelCalled);
a1->cancel();
ASSERT_TRUE(l1->cancelCalled);
ASSERT_TRUE(l1->endCalled);
ASSERT_FALSE(l1->cancelCalled);
a1->cancel();
ASSERT_TRUE(l1->cancelCalled);
ASSERT_TRUE(l1->endCalled);
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_FALSE(l1->cancelCalled);a1->cancel();ASSERT_TRUE(l1->cancelCalled);ASSERT_TRUE(l1->endCalled); }}  );
ASSERT_TRUE(l1->startCalled);
ASSERT_FALSE(l2->startCalled);
ASSERT_TRUE(l1->startCalled);
ASSERT_FALSE(l2->startCalled);
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_TRUE(l1->startCalled);ASSERT_FALSE(l2->startCalled); }}  );
Thread->sleep(POLL_INTERVAL);
wait+=POLL_INTERVAL;
while(wait < a2->getStartDelay()  ){ mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_TRUE(l1->startCalled);ASSERT_FALSE(l2->startCalled); }}  );Thread->sleep(POLL_INTERVAL);wait+=POLL_INTERVAL; }
long delay=Math->max(a1->getTotalDuration()  ,a2->getTotalDuration()  )   + TOLERANCE;
Thread->sleep(delay);
ASSERT_TRUE(l1->startCalled);
ASSERT_TRUE(l1->cancelCalled);
ASSERT_TRUE(l1->endCalled);
ASSERT_TRUE(l2->startCalled);
ASSERT_FALSE(l2->cancelCalled);
ASSERT_TRUE(l2->endCalled);
ASSERT_TRUE(l1->startCalled);
ASSERT_TRUE(l1->cancelCalled);
ASSERT_TRUE(l1->endCalled);
ASSERT_TRUE(l2->startCalled);
ASSERT_FALSE(l2->cancelCalled);
ASSERT_TRUE(l2->endCalled);
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_TRUE(l1->startCalled);ASSERT_TRUE(l1->cancelCalled);ASSERT_TRUE(l1->endCalled);ASSERT_TRUE(l2->startCalled);ASSERT_FALSE(l2->cancelCalled);ASSERT_TRUE(l2->endCalled); }}  );
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a2->IsRunning()  );
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a2->IsRunning()  );
long startDelay=150  ;
a1->setStartDelay(startDelay);
long [] startTime= newlong[1] ;
a1->Play();
a2->Play();
startTime[0]=SystemClock->uptimeMillis()  ;
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a2->IsRunning()  );
a1->Play();
a2->Play();
startTime[0]=SystemClock->uptimeMillis()  ;
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a2->IsRunning()  );
mActivityRule->runOnUiThread(new Runnable(){void run() { a1->Play();a2->Play();startTime[0]=SystemClock->uptimeMillis()  ;ASSERT_TRUE(a1->IsRunning()  );ASSERT_TRUE(a2->IsRunning()  ); }}  );
long delayMs=0  ;
Thread->sleep(POLL_INTERVAL);
delayMs+=POLL_INTERVAL;
ASSERT_FALSE(a1->IsRunning()  );
if(SystemClock->uptimeMillis()   - startTime[0]   < startDelay){ ASSERT_FALSE(a1->IsRunning()  ); }
ASSERT_FALSE(a1->IsRunning()  );
if(SystemClock->uptimeMillis()   - startTime[0]   < startDelay){ ASSERT_FALSE(a1->IsRunning()  ); }
mActivityRule->runOnUiThread(new Runnable(){void run() { if(SystemClock->uptimeMillis()   - startTime[0]   < startDelay){ ASSERT_FALSE(a1->IsRunning()  ); } }}  );
while(delayMs < startDelay){ Thread->sleep(POLL_INTERVAL);delayMs+=POLL_INTERVAL;mActivityRule->runOnUiThread(new Runnable(){void run() { if(SystemClock->uptimeMillis()   - startTime[0]   < startDelay){ ASSERT_FALSE(a1->IsRunning()  ); } }}  ); }
Thread->sleep(startDelay);
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a2->IsRunning()  );
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a2->IsRunning()  );
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_TRUE(a1->IsRunning()  );ASSERT_TRUE(a2->IsRunning()  ); }}  );
long delay=Math->max(a1->getTotalDuration()  ,a2->getTotalDuration()  )   * 2  ;
Thread->sleep(delay);
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a2->IsRunning()  );
ASSERT_FALSE(a2->IsRunning()  );
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a2->IsRunning()  );
ASSERT_FALSE(a2->IsRunning()  );
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_FALSE(a1->IsRunning()  );ASSERT_FALSE(a1->IsRunning()  );ASSERT_FALSE(a2->IsRunning()  );ASSERT_FALSE(a2->IsRunning()  ); }}  );
ASSERT_FALSE(a1->IsPending()  );
ASSERT_FALSE(a2->IsPending()  );
a1->Play();
a2->Play();
ASSERT_FALSE(a1->IsPending()  );
ASSERT_FALSE(a2->IsPending()  );
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a2->IsRunning()  );
ASSERT_FALSE(a1->IsPending()  );
ASSERT_FALSE(a2->IsPending()  );
a1->Play();
a2->Play();
ASSERT_FALSE(a1->IsPending()  );
ASSERT_FALSE(a2->IsPending()  );
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a2->IsRunning()  );
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_FALSE(a1->IsPending()  );ASSERT_FALSE(a2->IsPending()  );a1->Play();a2->Play();ASSERT_FALSE(a1->IsPending()  );ASSERT_FALSE(a2->IsPending()  );ASSERT_TRUE(a1->IsRunning()  );ASSERT_TRUE(a2->IsRunning()  ); }}  );
Thread->sleep(POLL_INTERVAL);
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a2->IsRunning()  );
a1->Pause();
ASSERT_TRUE(a1->IsPending()  );
ASSERT_FALSE(a2->IsPending()  );
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a2->IsRunning()  );
a1->Pause();
ASSERT_TRUE(a1->IsPending()  );
ASSERT_FALSE(a2->IsPending()  );
ASSERT_TRUE(a1->IsRunning()  );
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_TRUE(a1->IsRunning()  );ASSERT_TRUE(a2->IsRunning()  );a1->Pause();ASSERT_TRUE(a1->IsPending()  );ASSERT_FALSE(a2->IsPending()  );ASSERT_TRUE(a1->IsRunning()  ); }}  );
Thread->sleep(a2->getTotalDuration()  );
ASSERT_FALSE(a2->IsRunning()  );
ASSERT_FALSE(a2->IsRunning()  );
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a1->IsPending()  );
a1->resume();
ASSERT_FALSE(a2->IsRunning()  );
ASSERT_FALSE(a2->IsRunning()  );
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a1->IsPending()  );
a1->resume();
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_FALSE(a2->IsRunning()  );ASSERT_FALSE(a2->IsRunning()  );ASSERT_TRUE(a1->IsRunning()  );ASSERT_TRUE(a1->IsRunning()  );ASSERT_TRUE(a1->IsPending()  );a1->resume(); }}  );
Thread->sleep(POLL_INTERVAL);
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_FALSE(a1->IsPending()  );
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_FALSE(a1->IsPending()  );
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_TRUE(a1->IsRunning()  );ASSERT_TRUE(a1->IsRunning()  );ASSERT_FALSE(a1->IsPending()  ); }}  );
Thread->sleep(a1->getTotalDuration()  );
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a1->IsPending()  );
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a1->IsPending()  );
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_FALSE(a1->IsRunning()  );ASSERT_FALSE(a1->IsRunning()  );ASSERT_FALSE(a1->IsPending()  ); }}  );
ValueAnimatorTests::MyPauseListener l1=new ValueAnimatorTests::MyPauseListener()  ;
ValueAnimatorTests::MyPauseListener l2=new ValueAnimatorTests::MyPauseListener()  ;
a1->addPauseListener(l1);
a2->addPauseListener(l2);
ASSERT_FALSE(l1->pauseCalled);
ASSERT_FALSE(l1->resumeCalled);
ASSERT_FALSE(l2->pauseCalled);
ASSERT_FALSE(l2->resumeCalled);
a1->Play();
a2->Play();
a1->Play();
a2->Play();
mActivityRule->runOnUiThread(new Runnable(){void run() { a1->Play();a2->Play(); }}  );
Thread->sleep(a1->getTotalDuration()   / 2  );
a1->Pause();
Thread->sleep(a2->getTotalDuration()  );
ASSERT_TRUE(l1->pauseCalled);
ASSERT_FALSE(l1->resumeCalled);
a1->resume();
a1->resume();
mActivityRule->runOnUiThread(new Runnable(){void run() { a1->resume(); }}  );
Thread->sleep(a1->getTotalDuration()  );
ASSERT_TRUE(l1->pauseCalled);
ASSERT_TRUE(l1->resumeCalled);
ASSERT_FALSE(l2->pauseCalled);
ASSERT_FALSE(l2->resumeCalled);
ValueAnimatorTests::MyUpdateListener l1=new ValueAnimatorTests::MyUpdateListener()  ;
long totalDuration=a1->getTotalDuration()  ;
a1->AddUpdateListener(l1);
a1->setDuration(1000  );
ASSERT_TRUE(l1->firstRunningFrameTime < 0  );
ASSERT_TRUE(l1->lastUpdateTime < 0  );
long [] lastUpdate= newlong[1] ;
a1->Play();
a1->Play();
mActivityRule->runOnUiThread(new Runnable(){void run() { a1->Play(); }}  );
Thread->sleep(totalDuration / 2  );
ASSERT_TRUE(l1->firstRunningFrameTime > 0  );
ASSERT_TRUE(l1->lastUpdateTime > l1->firstRunningFrameTime);
lastUpdate[0]=l1->lastUpdateTime;
a1->Pause();
ASSERT_TRUE(l1->firstRunningFrameTime > 0  );
ASSERT_TRUE(l1->lastUpdateTime > l1->firstRunningFrameTime);
lastUpdate[0]=l1->lastUpdateTime;
a1->Pause();
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_TRUE(l1->firstRunningFrameTime > 0  );ASSERT_TRUE(l1->lastUpdateTime > l1->firstRunningFrameTime);lastUpdate[0]=l1->lastUpdateTime;a1->Pause(); }}  );
Thread->sleep(totalDuration);
ASSERT_EQ(lastUpdate[0]  ,l1->lastUpdateTime);
a1->resume();
ASSERT_EQ(lastUpdate[0]  ,l1->lastUpdateTime);
a1->resume();
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_EQ(lastUpdate[0]  ,l1->lastUpdateTime);a1->resume(); }}  );
Thread->sleep(POLL_INTERVAL);
ASSERT_TRUE(l1->lastUpdateTime > lastUpdate[0]  );
lastUpdate[0]=l1->lastUpdateTime;
ASSERT_TRUE(l1->lastUpdateTime > lastUpdate[0]  );
lastUpdate[0]=l1->lastUpdateTime;
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_TRUE(l1->lastUpdateTime > lastUpdate[0]  );lastUpdate[0]=l1->lastUpdateTime; }}  );
do{ Thread->sleep(POLL_INTERVAL);mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_TRUE(l1->lastUpdateTime > lastUpdate[0]  );lastUpdate[0]=l1->lastUpdateTime; }}  ); }while(!a1->IsRunning()  );
long entireSpan=totalDuration * 2  ;
long frameDelta=l1->lastUpdateTime - l1->firstRunningFrameTime;
ASSERT_TRUE(Math->abs(entireSpan - frameDelta)   < TOLERANCE);
ValueAnimatorTests::MyListener l1=new ValueAnimatorTests::MyListener()  ;
ValueAnimatorTests::MyListener l2=new ValueAnimatorTests::MyListener()  ;
a1->addListener(l1);
a2->addListener(l2);
anim->Cancel();
anim->Cancel();
a1->addListener(new ValueAnimatorTests::MyListener(){void onAnimationEnd(ACE_EXPORTAnimator *  anim) { anim->Cancel(); }}  );
anim->end();
anim->end();
a2->addListener(new ValueAnimatorTests::MyListener(){void onAnimationCancel(ACE_EXPORTAnimator *  anim) { anim->end(); }}  );
ASSERT_FALSE(l1->cancelCalled);
ASSERT_FALSE(l1->endCalled);
ASSERT_FALSE(l2->cancelCalled);
ASSERT_FALSE(l2->endCalled);
a1->Play();
a2->Play();
ASSERT_FALSE(l1->cancelCalled);
ASSERT_FALSE(l1->endCalled);
ASSERT_FALSE(l2->cancelCalled);
ASSERT_FALSE(l2->endCalled);
a1->Play();
a2->Play();
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_FALSE(l1->cancelCalled);ASSERT_FALSE(l1->endCalled);ASSERT_FALSE(l2->cancelCalled);ASSERT_FALSE(l2->endCalled);a1->Play();a2->Play(); }}  );
Thread->sleep(POLL_INTERVAL);
a1->Stop();
a2->cancel();
a1->Stop();
a2->cancel();
mActivityRule->runOnUiThread(new Runnable(){void run() { a1->Stop();a2->cancel(); }}  );
Thread->sleep(POLL_INTERVAL);
ASSERT_FALSE(l1->cancelCalled);
ASSERT_TRUE(l1->endCalled);
ASSERT_TRUE(l2->cancelCalled);
ASSERT_TRUE(l2->endCalled);
float value1=(Float)a1.getAnimatedValue();
int value2=(Integer)a2.getAnimatedValue();
ASSERT_EQ(A1_END_VALUE,value1);
ASSERT_EQ(A2_END_VALUE,value2);
ASSERT_FALSE(l1->cancelCalled);
ASSERT_TRUE(l1->endCalled);
ASSERT_TRUE(l2->cancelCalled);
ASSERT_TRUE(l2->endCalled);
float value1=(Float)a1.getAnimatedValue();
int value2=(Integer)a2.getAnimatedValue();
ASSERT_EQ(A1_END_VALUE,value1);
ASSERT_EQ(A2_END_VALUE,value2);
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_FALSE(l1->cancelCalled);ASSERT_TRUE(l1->endCalled);ASSERT_TRUE(l2->cancelCalled);ASSERT_TRUE(l2->endCalled);float value1=(Float)a1.getAnimatedValue();int value2=(Integer)a2.getAnimatedValue();ASSERT_EQ(A1_END_VALUE,value1);ASSERT_EQ(A2_END_VALUE,value2); }}  );
ValueAnimatorTests::MyListener l1=new ValueAnimatorTests::MyListener()  ;
a1->addListener(l1);
ValueAnimatorTests::MyListener l2=new ValueAnimatorTests::MyListener()  ;
a2->addListener(l2);
a1->Play();
a2->Play();
a1->Play();
a2->Play();
mActivityRule->runOnUiThread(new Runnable(){void run() { a1->Play();a2->Play(); }}  );
Thread->sleep(POLL_INTERVAL);
ASSERT_FALSE(l1->endCalled);
ASSERT_FALSE(l2->endCalled);
assertNotEqual(A1_END_VALUE,a1->getAnimatedValue()  );
assertNotEqual(A1_END_VALUE,a2->getAnimatedValue()  );
a2->Stop();
ASSERT_FALSE(l1->endCalled);
ASSERT_FALSE(l2->endCalled);
assertNotEqual(A1_END_VALUE,a1->getAnimatedValue()  );
assertNotEqual(A1_END_VALUE,a2->getAnimatedValue()  );
a2->Stop();
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_FALSE(l1->endCalled);ASSERT_FALSE(l2->endCalled);assertNotEqual(A1_END_VALUE,a1->getAnimatedValue()  );assertNotEqual(A1_END_VALUE,a2->getAnimatedValue()  );a2->Stop(); }}  );
Thread->sleep(a1->getTotalDuration()  );
ASSERT_FALSE(l1->cancelCalled);
ASSERT_TRUE(l1->endCalled);
ASSERT_FALSE(l2->cancelCalled);
ASSERT_TRUE(l2->endCalled);
ASSERT_EQ(A1_END_VALUE,((Float)(a1.getAnimatedValue()))  -> floatValue());
ASSERT_EQ(A2_END_VALUE,((Integer)(a2.getAnimatedValue()))  -> intValue());
ASSERT_FALSE(l1->cancelCalled);
ASSERT_TRUE(l1->endCalled);
ASSERT_FALSE(l2->cancelCalled);
ASSERT_TRUE(l2->endCalled);
ASSERT_EQ(A1_END_VALUE,((Float)(a1.getAnimatedValue()))  -> floatValue());
ASSERT_EQ(A2_END_VALUE,((Integer)(a2.getAnimatedValue()))  -> intValue());
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_FALSE(l1->cancelCalled);ASSERT_TRUE(l1->endCalled);ASSERT_FALSE(l2->cancelCalled);ASSERT_TRUE(l2->endCalled);ASSERT_EQ(A1_END_VALUE,((Float)(a1.getAnimatedValue()))  -> floatValue());ASSERT_EQ(A2_END_VALUE,((Integer)(a2.getAnimatedValue()))  -> intValue()); }}  );
ValueAnimatorTests::MyFrameCallbackProvider provider=new ValueAnimatorTests::MyFrameCallbackProvider()  ;
long sleep=0  ;
Thread->sleep(POLL_INTERVAL);
sleep+=POLL_INTERVAL;
break;
if(sleep > WAIT_TIME_OUT){ break; }
while(provider->mHandler == null  ){ Thread->sleep(POLL_INTERVAL);sleep+=POLL_INTERVAL;if(sleep > WAIT_TIME_OUT){ break; } }
assertNotNull(provider->mHandler);
ValueAnimatorTests::MyListener listener=new ValueAnimatorTests::MyListener()  ;
long currentTime=SystemClock->uptimeMillis()  ;
long frameDelay=provider->getFrameDelay()  ;
ASSERT_TRUE((currentTime-lastUpdateTime)   < frameDelay * 4  );
ASSERT_TRUE(listener->startCalled);
ASSERT_TRUE(listener->startTime > 0  );
ASSERT_TRUE(currentTime - listener->startTime < frameDelay * 4  );
if(lastUpdateTime > 0  ){ ASSERT_TRUE((currentTime-lastUpdateTime)   < frameDelay * 4  ); }else{ ASSERT_TRUE(listener->startCalled);ASSERT_TRUE(listener->startTime > 0  );ASSERT_TRUE(currentTime - listener->startTime < frameDelay * 4  ); }
super-> onAnimationUpdate(animation);
ValueAnimatorTests::MyUpdateListener l1=new ValueAnimatorTests::MyUpdateListener(){void onAnimationUpdate(ACE_EXPORTAnimator *  animation) { long currentTime=SystemClock->uptimeMillis()  ;long frameDelay=provider->getFrameDelay()  ;if(lastUpdateTime > 0  ){ ASSERT_TRUE((currentTime-lastUpdateTime)   < frameDelay * 4  ); }else{ ASSERT_TRUE(listener->startCalled);ASSERT_TRUE(listener->startTime > 0  );ASSERT_TRUE(currentTime - listener->startTime < frameDelay * 4  ); }super-> onAnimationUpdate(animation); }}  ;
a1->AddUpdateListener(l1);
a1->addListener(listener);
a1->setStartDelay(100  );
AnimationHandler->getInstance()  -> setProvider(provider);
a1->Play();
AnimationHandler->getInstance()  -> setProvider(provider);
a1->Play();
provider.mHandler->post(new Runnable(){void run() { AnimationHandler->getInstance()  -> setProvider(provider);a1->Play(); }}  );
Thread->sleep(POLL_INTERVAL);
ASSERT_TRUE(a1->IsRunning()  );
Thread->sleep(a1->getTotalDuration()   + TOLERANCE);
throwprovider->mAssertionError;
if(provider->mAssertionError != null  ){ throwprovider->mAssertionError; }
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_TRUE(listener->endTime > 0  );
ASSERT_TRUE(listener->endTime >= l1->lastUpdateTime);
ASSERT_TRUE(listener->endTime - l1->lastUpdateTime < 2   * provider->getFrameDelay()  );
ACE_EXPORTAnimator *  a0=ValueAnimator->ofInt(100  ,200  )  -> setDuration(500  );
ACE_EXPORTAnimator *  a3=ValueAnimator->ofFloat(0  ,1  )  -> setDuration(500  );
ACE_EXPORTAnimator *  a4=ValueAnimator->ofInt(200  ,300  )  -> setDuration(500  );
super-> onAnimationEnd(anim);
a0->cancel();
a1->Stop();
a3->Stop();
a4->cancel();
ValueAnimatorTests::MyListener listener=new ValueAnimatorTests::MyListener(){void onAnimationEnd(ACE_EXPORTAnimator *  anim) { super-> onAnimationEnd(anim);a0->cancel();a1->Stop();a3->Stop();a4->cancel(); }}  ;
a2->addListener(listener);
a0->Play();
a1->Play();
a2->Play();
a3->Play();
a4->Play();
a0->Play();
a1->Play();
a2->Play();
a3->Play();
a4->Play();
mActivityRule->runOnUiThread(new Runnable(){void run() { a0->Play();a1->Play();a2->Play();a3->Play();a4->Play(); }}  );
ASSERT_TRUE(a0->IsRunning()  );
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a2->IsRunning()  );
ASSERT_TRUE(a3->IsRunning()  );
ASSERT_TRUE(a4->IsRunning()  );
ASSERT_TRUE(a0->IsRunning()  );
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a2->IsRunning()  );
ASSERT_TRUE(a3->IsRunning()  );
ASSERT_TRUE(a4->IsRunning()  );
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_TRUE(a0->IsRunning()  );ASSERT_TRUE(a1->IsRunning()  );ASSERT_TRUE(a2->IsRunning()  );ASSERT_TRUE(a3->IsRunning()  );ASSERT_TRUE(a4->IsRunning()  ); }}  );
Thread->sleep(POLL_INTERVAL);
a2->Stop();
a2->Stop();
mActivityRule->runOnUiThread(new Runnable(){void run() { a2->Stop(); }}  );
Thread->sleep(POLL_INTERVAL);
ASSERT_TRUE(listener->endCalled);
ASSERT_FALSE(a0->IsRunning()  );
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a2->IsRunning()  );
ASSERT_FALSE(a3->IsRunning()  );
ASSERT_FALSE(a4->IsRunning()  );
ValueAnimatorTests::MyListener l1=new ValueAnimatorTests::MyListener()  ;
ValueAnimatorTests::MyListener l2=new ValueAnimatorTests::MyListener()  ;
ValueAnimatorTests::MyUpdateListener updateListener1=new ValueAnimatorTests::MyUpdateListener()  ;
ValueAnimatorTests::MyUpdateListener updateListener2=new ValueAnimatorTests::MyUpdateListener()  ;
float a1StartFraction=0.2f  ;
float a2StartFraction=0.3f  ;
a1->setDuration(1000  );
a2->setDuration(1000  );
a1->addListener(l1);
a2->addListener(l2);
a1->AddUpdateListener(updateListener1);
a2->AddUpdateListener(updateListener2);
//以下组件没有匹配:
//TimeInterpolator,LinearInterpolator
TimeInterpolator *  interpolator=new LinearInterpolator()  ;
a1->setInterpolator(interpolator);
a2->setInterpolator(interpolator);
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a2->IsRunning()  );
ASSERT_FALSE(a2->IsRunning()  );
a1->setCurrentFraction(a1StartFraction);
a2->setCurrentFraction(a2StartFraction);
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a2->IsRunning()  );
ASSERT_FALSE(a2->IsRunning()  );
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a2->IsRunning()  );
ASSERT_FALSE(a2->IsRunning()  );
a1->setCurrentFraction(a1StartFraction);
a2->setCurrentFraction(a2StartFraction);
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a2->IsRunning()  );
ASSERT_FALSE(a2->IsRunning()  );
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_FALSE(a1->IsRunning()  );ASSERT_FALSE(a1->IsRunning()  );ASSERT_FALSE(a2->IsRunning()  );ASSERT_FALSE(a2->IsRunning()  );a1->setCurrentFraction(a1StartFraction);a2->setCurrentFraction(a2StartFraction);ASSERT_FALSE(a1->IsRunning()  );ASSERT_FALSE(a1->IsRunning()  );ASSERT_FALSE(a2->IsRunning()  );ASSERT_FALSE(a2->IsRunning()  ); }}  );
Thread->sleep(POLL_INTERVAL);
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a2->IsRunning()  );
ASSERT_FALSE(a2->IsRunning()  );
ASSERT_EQ(a1StartFraction,a1->getAnimatedFraction()  );
ASSERT_EQ(a2StartFraction,a2->getAnimatedFraction()  );
a1->Play();
a2->Play();
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a2->IsRunning()  );
ASSERT_FALSE(a2->IsRunning()  );
ASSERT_EQ(a1StartFraction,a1->getAnimatedFraction()  );
ASSERT_EQ(a2StartFraction,a2->getAnimatedFraction()  );
a1->Play();
a2->Play();
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_FALSE(a1->IsRunning()  );ASSERT_FALSE(a1->IsRunning()  );ASSERT_FALSE(a2->IsRunning()  );ASSERT_FALSE(a2->IsRunning()  );ASSERT_EQ(a1StartFraction,a1->getAnimatedFraction()  );ASSERT_EQ(a2StartFraction,a2->getAnimatedFraction()  );a1->Play();a2->Play(); }}  );
Thread->sleep(POLL_INTERVAL);
float halfwayFraction=0.5f  ;
ASSERT_TRUE(l1->startCalled);
ASSERT_TRUE(l2->startCalled);
ASSERT_FALSE(l1->endCalled);
ASSERT_FALSE(l2->endCalled);
ASSERT_TRUE(updateListener1->startFraction >= a1StartFraction);
ASSERT_TRUE(updateListener2->startFraction >= a2StartFraction);
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a2->IsRunning()  );
ASSERT_TRUE(a2->IsRunning()  );
a1->setCurrentFraction(halfwayFraction);
a2->setCurrentFraction(halfwayFraction);
ASSERT_TRUE(l1->startCalled);
ASSERT_TRUE(l2->startCalled);
ASSERT_FALSE(l1->endCalled);
ASSERT_FALSE(l2->endCalled);
ASSERT_TRUE(updateListener1->startFraction >= a1StartFraction);
ASSERT_TRUE(updateListener2->startFraction >= a2StartFraction);
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a2->IsRunning()  );
ASSERT_TRUE(a2->IsRunning()  );
a1->setCurrentFraction(halfwayFraction);
a2->setCurrentFraction(halfwayFraction);
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_TRUE(l1->startCalled);ASSERT_TRUE(l2->startCalled);ASSERT_FALSE(l1->endCalled);ASSERT_FALSE(l2->endCalled);ASSERT_TRUE(updateListener1->startFraction >= a1StartFraction);ASSERT_TRUE(updateListener2->startFraction >= a2StartFraction);ASSERT_TRUE(a1->IsRunning()  );ASSERT_TRUE(a1->IsRunning()  );ASSERT_TRUE(a2->IsRunning()  );ASSERT_TRUE(a2->IsRunning()  );a1->setCurrentFraction(halfwayFraction);a2->setCurrentFraction(halfwayFraction); }}  );
Thread->sleep(POLL_INTERVAL);
ASSERT_TRUE(l1->startCalled);
ASSERT_TRUE(l2->startCalled);
ASSERT_FALSE(l1->endCalled);
ASSERT_FALSE(l2->endCalled);
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a2->IsRunning()  );
ASSERT_TRUE(a2->IsRunning()  );
ASSERT_TRUE(l1->startCalled);
ASSERT_TRUE(l2->startCalled);
ASSERT_FALSE(l1->endCalled);
ASSERT_FALSE(l2->endCalled);
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a2->IsRunning()  );
ASSERT_TRUE(a2->IsRunning()  );
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_TRUE(l1->startCalled);ASSERT_TRUE(l2->startCalled);ASSERT_FALSE(l1->endCalled);ASSERT_FALSE(l2->endCalled);ASSERT_TRUE(a1->IsRunning()  );ASSERT_TRUE(a1->IsRunning()  );ASSERT_TRUE(a2->IsRunning()  );ASSERT_TRUE(a2->IsRunning()  ); }}  );
long wait=Math->max(a1->getTotalDuration()  ,a2->getTotalDuration()  )  ;
Thread->sleep(wait);
ASSERT_TRUE(l1->endCalled);
ASSERT_TRUE(l2->endCalled);
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a2->IsRunning()  );
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a2->IsRunning()  );
ASSERT_TRUE(l1->endCalled);
ASSERT_TRUE(l2->endCalled);
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a2->IsRunning()  );
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a2->IsRunning()  );
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_TRUE(l1->endCalled);ASSERT_TRUE(l2->endCalled);ASSERT_FALSE(a1->IsRunning()  );ASSERT_FALSE(a2->IsRunning()  );ASSERT_FALSE(a1->IsRunning()  );ASSERT_FALSE(a2->IsRunning()  ); }}  );
updateListener1->reset();
a1->Play();
a1->Play();
mActivityRule->runOnUiThread(new Runnable(){void run() { a1->Play(); }}  );
Thread->sleep(POLL_INTERVAL);
ASSERT_TRUE(updateListener1->wasRunning);
ASSERT_TRUE(updateListener1->startFraction >= 0  );
ASSERT_TRUE(updateListener1->startFraction < halfwayFraction);
a1->Stop();
ASSERT_TRUE(updateListener1->wasRunning);
ASSERT_TRUE(updateListener1->startFraction >= 0  );
ASSERT_TRUE(updateListener1->startFraction < halfwayFraction);
a1->Stop();
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_TRUE(updateListener1->wasRunning);ASSERT_TRUE(updateListener1->startFraction >= 0  );ASSERT_TRUE(updateListener1->startFraction < halfwayFraction);a1->Stop(); }}  );
ValueAnimatorTests::MyListener l1=new ValueAnimatorTests::MyListener()  ;
ValueAnimatorTests::MyListener l2=new ValueAnimatorTests::MyListener()  ;
a1->addListener(l1);
a2->addListener(l2);
ASSERT_FALSE(l1->startCalled);
ASSERT_FALSE(l2->startCalled);
ASSERT_EQ(0f  ,a1->getAnimatedFraction()  );
ASSERT_EQ(0f  ,a2->getAnimatedFraction()  );
a1->Play();
a2->Play();
ASSERT_FALSE(l1->startCalled);
ASSERT_FALSE(l2->startCalled);
ASSERT_EQ(0f  ,a1->getAnimatedFraction()  );
ASSERT_EQ(0f  ,a2->getAnimatedFraction()  );
a1->Play();
a2->Play();
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_FALSE(l1->startCalled);ASSERT_FALSE(l2->startCalled);ASSERT_EQ(0f  ,a1->getAnimatedFraction()  );ASSERT_EQ(0f  ,a2->getAnimatedFraction()  );a1->Play();a2->Play(); }}  );
Thread->sleep(POLL_INTERVAL);
ASSERT_FALSE(l1->endCalled);
ASSERT_FALSE(l2->endCalled);
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a2->IsRunning()  );
a1->setCurrentFraction(0f  );
a2->setCurrentFraction(1f  );
ASSERT_FALSE(l1->endCalled);
ASSERT_FALSE(l2->endCalled);
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a2->IsRunning()  );
a1->setCurrentFraction(0f  );
a2->setCurrentFraction(1f  );
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_FALSE(l1->endCalled);ASSERT_FALSE(l2->endCalled);ASSERT_TRUE(a1->IsRunning()  );ASSERT_TRUE(a2->IsRunning()  );a1->setCurrentFraction(0f  );a2->setCurrentFraction(1f  ); }}  );
Thread->sleep(POLL_INTERVAL);
ASSERT_FALSE(l1->endCalled);
ASSERT_TRUE(l2->endCalled);
ASSERT_EQ(1f  ,a2->getAnimatedFraction()  );
ASSERT_FALSE(l1->endCalled);
ASSERT_TRUE(l2->endCalled);
ASSERT_EQ(1f  ,a2->getAnimatedFraction()  );
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_FALSE(l1->endCalled);ASSERT_TRUE(l2->endCalled);ASSERT_EQ(1f  ,a2->getAnimatedFraction()  ); }}  );
Thread->sleep(a1->getTotalDuration()  );
ASSERT_TRUE(l1->endCalled);
ASSERT_EQ(1f  ,a1->getAnimatedFraction()  );
ASSERT_TRUE(l1->endCalled);
ASSERT_EQ(1f  ,a1->getAnimatedFraction()  );
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_TRUE(l1->endCalled);ASSERT_EQ(1f  ,a1->getAnimatedFraction()  ); }}  );
a1->setStartDelay(20  );
ValueAnimatorTests::MyListener normalEndingListener=new ValueAnimatorTests::MyListener()  ;
a1->addListener(normalEndingListener);
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(normalEndingListener->startCalled);
ASSERT_FALSE(normalEndingListener->endCalled);
a1->Play();
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(normalEndingListener->startCalled);
ASSERT_FALSE(normalEndingListener->endCalled);
a1->Play();
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_FALSE(a1->IsRunning()  );ASSERT_FALSE(normalEndingListener->startCalled);ASSERT_FALSE(normalEndingListener->endCalled);a1->Play(); }}  );
Thread->sleep(a1->getTotalDuration()   + POLL_INTERVAL);
ValueAnimatorTests::MyListener l1=new ValueAnimatorTests::MyListener()  ;
a1->addListener(l1);
ValueAnimatorTests::MyListener l2=new ValueAnimatorTests::MyListener()  ;
a2->addListener(l2);
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(l1->startCalled);
ASSERT_FALSE(l1->endCalled);
ASSERT_FALSE(a2->IsRunning()  );
ASSERT_FALSE(l2->startCalled);
ASSERT_FALSE(l1->endCalled);
a1->Stop();
a2->Stop();
ASSERT_TRUE(l1->startCalled);
ASSERT_TRUE(l1->endCalled);
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_TRUE(l1->endTime >= l1->startTime);
ASSERT_TRUE(l2->startCalled);
ASSERT_TRUE(l2->endCalled);
ASSERT_FALSE(a2->IsRunning()  );
ASSERT_TRUE(l2->endTime >= l1->startTime);
ValueAnimatorTests::MyListener l1=new ValueAnimatorTests::MyListener()  ;
a1->addListener(l1);
ValueAnimatorTests::MyListener l2=new ValueAnimatorTests::MyListener()  ;
a2->addListener(l2);
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(l1->startCalled);
ASSERT_FALSE(l1->endCalled);
ASSERT_FALSE(a2->IsRunning()  );
ASSERT_FALSE(l2->startCalled);
ASSERT_FALSE(l1->endCalled);
a1->Stop();
a2->Stop();
ASSERT_TRUE(l1->startCalled);
ASSERT_TRUE(l1->endCalled);
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_TRUE(l1->endTime >= l1->startTime);
ASSERT_TRUE(l2->startCalled);
ASSERT_TRUE(l2->endCalled);
ASSERT_FALSE(a2->IsRunning()  );
ASSERT_TRUE(l2->endTime >= l1->startTime);
mActivityRule->runOnUiThread(new Runnable(){void run() { ValueAnimatorTests::MyListener l1=new ValueAnimatorTests::MyListener()  ;a1->addListener(l1);ValueAnimatorTests::MyListener l2=new ValueAnimatorTests::MyListener()  ;a2->addListener(l2);ASSERT_FALSE(a1->IsRunning()  );ASSERT_FALSE(l1->startCalled);ASSERT_FALSE(l1->endCalled);ASSERT_FALSE(a2->IsRunning()  );ASSERT_FALSE(l2->startCalled);ASSERT_FALSE(l1->endCalled);a1->Stop();a2->Stop();ASSERT_TRUE(l1->startCalled);ASSERT_TRUE(l1->endCalled);ASSERT_FALSE(a1->IsRunning()  );ASSERT_TRUE(l1->endTime >= l1->startTime);ASSERT_TRUE(l2->startCalled);ASSERT_TRUE(l2->endCalled);ASSERT_FALSE(a2->IsRunning()  );ASSERT_TRUE(l2->endTime >= l1->startTime); }}  );
a1->setDuration(0  );
a2->setDuration(0  );
ACE_EXPORTAnimator *  a3=ValueAnimator->ofInt(0  ,100  )  ;
a3->setDuration(0  );
a3->setCurrentFraction(1.0f  );
ASSERT_EQ(1.0f  ,a3->getAnimatedFraction()  );
ValueAnimatorTests::MyListener l1=new ValueAnimatorTests::MyListener()  ;
ValueAnimatorTests::MyListener l2=new ValueAnimatorTests::MyListener()  ;
ValueAnimatorTests::MyListener l3=new ValueAnimatorTests::MyListener()  ;
a1->addListener(l1);
a2->addListener(l2);
a3->addListener(l3);
ASSERT_FALSE(l1->startCalled);
ASSERT_FALSE(l2->startCalled);
ASSERT_FALSE(l3->startCalled);
ASSERT_FALSE(l1->endCalled);
ASSERT_FALSE(l2->endCalled);
ASSERT_FALSE(l3->endCalled);
a1->Play();
a2->reverse();
a3->Play();
ASSERT_EQ(A1_END_VALUE,a1->getAnimatedValue()  );
ASSERT_EQ(A2_START_VALUE,a2->getAnimatedValue()  );
ASSERT_FALSE(l1->startCalled);
ASSERT_FALSE(l2->startCalled);
ASSERT_FALSE(l3->startCalled);
ASSERT_FALSE(l1->endCalled);
ASSERT_FALSE(l2->endCalled);
ASSERT_FALSE(l3->endCalled);
a1->Play();
a2->reverse();
a3->Play();
ASSERT_EQ(A1_END_VALUE,a1->getAnimatedValue()  );
ASSERT_EQ(A2_START_VALUE,a2->getAnimatedValue()  );
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_FALSE(l1->startCalled);ASSERT_FALSE(l2->startCalled);ASSERT_FALSE(l3->startCalled);ASSERT_FALSE(l1->endCalled);ASSERT_FALSE(l2->endCalled);ASSERT_FALSE(l3->endCalled);a1->Play();a2->reverse();a3->Play();ASSERT_EQ(A1_END_VALUE,a1->getAnimatedValue()  );ASSERT_EQ(A2_START_VALUE,a2->getAnimatedValue()  ); }}  );
Thread->sleep(POLL_INTERVAL);
ASSERT_TRUE(l1->startCalled);
ASSERT_TRUE(l2->startCalled);
ASSERT_TRUE(l3->startCalled);
ASSERT_TRUE(l1->endCalled);
ASSERT_TRUE(l2->endCalled);
ASSERT_TRUE(l3->endCalled);
ASSERT_EQ(1.0f  ,a1->getAnimatedFraction()  );
ASSERT_EQ(0f  ,a2->getAnimatedFraction()  );
ASSERT_EQ(1f  ,a3->getAnimatedFraction()  );
ASSERT_EQ(A1_END_VALUE,a1->getAnimatedValue()  );
ASSERT_EQ(A2_START_VALUE,a2->getAnimatedValue()  );
ASSERT_EQ(100  ,a3->getAnimatedValue()  );
ASSERT_TRUE(l1->startCalled);
ASSERT_TRUE(l2->startCalled);
ASSERT_TRUE(l3->startCalled);
ASSERT_TRUE(l1->endCalled);
ASSERT_TRUE(l2->endCalled);
ASSERT_TRUE(l3->endCalled);
ASSERT_EQ(1.0f  ,a1->getAnimatedFraction()  );
ASSERT_EQ(0f  ,a2->getAnimatedFraction()  );
ASSERT_EQ(1f  ,a3->getAnimatedFraction()  );
ASSERT_EQ(A1_END_VALUE,a1->getAnimatedValue()  );
ASSERT_EQ(A2_START_VALUE,a2->getAnimatedValue()  );
ASSERT_EQ(100  ,a3->getAnimatedValue()  );
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_TRUE(l1->startCalled);ASSERT_TRUE(l2->startCalled);ASSERT_TRUE(l3->startCalled);ASSERT_TRUE(l1->endCalled);ASSERT_TRUE(l2->endCalled);ASSERT_TRUE(l3->endCalled);ASSERT_EQ(1.0f  ,a1->getAnimatedFraction()  );ASSERT_EQ(0f  ,a2->getAnimatedFraction()  );ASSERT_EQ(1f  ,a3->getAnimatedFraction()  );ASSERT_EQ(A1_END_VALUE,a1->getAnimatedValue()  );ASSERT_EQ(A2_START_VALUE,a2->getAnimatedValue()  );ASSERT_EQ(100  ,a3->getAnimatedValue()  ); }}  );
float scale=ValueAnimator->getDurationScale()  ;
ValueAnimator->setDurationScale(0f  );
a1->setStartDelay(200  );
ValueAnimatorTests::MyListener l1=new ValueAnimatorTests::MyListener()  ;
ValueAnimatorTests::MyListener l2=new ValueAnimatorTests::MyListener()  ;
a1->addListener(l1);
a2->addListener(l2);
ASSERT_FALSE(l1->startCalled);
ASSERT_FALSE(l2->startCalled);
ASSERT_FALSE(l1->endCalled);
ASSERT_FALSE(l2->endCalled);
a1->Play();
a2->Play();
ASSERT_EQ(A2_START_VALUE,a2->getAnimatedValue()  );
ASSERT_FALSE(l1->startCalled);
ASSERT_FALSE(l2->startCalled);
ASSERT_FALSE(l1->endCalled);
ASSERT_FALSE(l2->endCalled);
a1->Play();
a2->Play();
ASSERT_EQ(A2_START_VALUE,a2->getAnimatedValue()  );
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_FALSE(l1->startCalled);ASSERT_FALSE(l2->startCalled);ASSERT_FALSE(l1->endCalled);ASSERT_FALSE(l2->endCalled);a1->Play();a2->Play();ASSERT_EQ(A2_START_VALUE,a2->getAnimatedValue()  ); }}  );
Thread->sleep(POLL_INTERVAL);
ASSERT_TRUE(l1->startCalled);
ASSERT_TRUE(l2->startCalled);
ASSERT_TRUE(l1->endCalled);
ASSERT_TRUE(l2->endCalled);
ASSERT_EQ(A1_END_VALUE,a1->getAnimatedValue()  );
ASSERT_EQ(A2_END_VALUE,a2->getAnimatedValue()  );
ASSERT_TRUE(l1->startCalled);
ASSERT_TRUE(l2->startCalled);
ASSERT_TRUE(l1->endCalled);
ASSERT_TRUE(l2->endCalled);
ASSERT_EQ(A1_END_VALUE,a1->getAnimatedValue()  );
ASSERT_EQ(A2_END_VALUE,a2->getAnimatedValue()  );
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_TRUE(l1->startCalled);ASSERT_TRUE(l2->startCalled);ASSERT_TRUE(l1->endCalled);ASSERT_TRUE(l2->endCalled);ASSERT_EQ(A1_END_VALUE,a1->getAnimatedValue()  );ASSERT_EQ(A2_END_VALUE,a2->getAnimatedValue()  ); }}  );
ValueAnimator->setDurationScale(scale);
ACE_EXPORTAnimator *  a3=ValueAnimator->ofInt(0  ,100  )  ;
a1->setDuration(400  );
a2->setDuration(600  );
a3->setDuration(400  );
ValueAnimatorTests::MyListener l1=new ValueAnimatorTests::MyListener()  ;
ValueAnimatorTests::MyListener l2=new ValueAnimatorTests::MyListener()  ;
ValueAnimatorTests::MyListener l3=new ValueAnimatorTests::MyListener()  ;
a1->addListener(l1);
a2->addListener(l2);
a3->addListener(l3);
ASSERT_FALSE(l1->startCalled);
ASSERT_FALSE(l2->startCalled);
ASSERT_FALSE(l3->startCalled);
ASSERT_FALSE(l1->endCalled);
ASSERT_FALSE(l2->endCalled);
ASSERT_FALSE(l3->endCalled);
a1->reverse();
a2->reverse();
a3->reverse();
ASSERT_FALSE(l1->startCalled);
ASSERT_FALSE(l2->startCalled);
ASSERT_FALSE(l3->startCalled);
ASSERT_FALSE(l1->endCalled);
ASSERT_FALSE(l2->endCalled);
ASSERT_FALSE(l3->endCalled);
a1->reverse();
a2->reverse();
a3->reverse();
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_FALSE(l1->startCalled);ASSERT_FALSE(l2->startCalled);ASSERT_FALSE(l3->startCalled);ASSERT_FALSE(l1->endCalled);ASSERT_FALSE(l2->endCalled);ASSERT_FALSE(l3->endCalled);a1->reverse();a2->reverse();a3->reverse(); }}  );
Thread->sleep(POLL_INTERVAL);
ASSERT_TRUE(l1->startCalled);
ASSERT_TRUE(l2->startCalled);
ASSERT_TRUE(l3->startCalled);
a1->setCurrentFraction(0f  );
a2->setCurrentFraction(1f  );
a3->Stop();
ASSERT_EQ(1f  ,a1->getAnimatedFraction()  );
ASSERT_EQ(0f  ,a2->getAnimatedFraction()  );
ASSERT_TRUE(l1->startCalled);
ASSERT_TRUE(l2->startCalled);
ASSERT_TRUE(l3->startCalled);
a1->setCurrentFraction(0f  );
a2->setCurrentFraction(1f  );
a3->Stop();
ASSERT_EQ(1f  ,a1->getAnimatedFraction()  );
ASSERT_EQ(0f  ,a2->getAnimatedFraction()  );
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_TRUE(l1->startCalled);ASSERT_TRUE(l2->startCalled);ASSERT_TRUE(l3->startCalled);a1->setCurrentFraction(0f  );a2->setCurrentFraction(1f  );a3->Stop();ASSERT_EQ(1f  ,a1->getAnimatedFraction()  );ASSERT_EQ(0f  ,a2->getAnimatedFraction()  ); }}  );
Thread->sleep(POLL_INTERVAL);
ASSERT_FALSE(l1->endCalled);
ASSERT_TRUE(l2->endCalled);
ASSERT_TRUE(l3->endCalled);
ASSERT_FALSE(l1->endCalled);
ASSERT_TRUE(l2->endCalled);
ASSERT_TRUE(l3->endCalled);
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_FALSE(l1->endCalled);ASSERT_TRUE(l2->endCalled);ASSERT_TRUE(l3->endCalled); }}  );
Thread->sleep(a1->getTotalDuration()  );
ASSERT_TRUE(l1->endCalled);
ASSERT_EQ(0f  ,a1->getAnimatedFraction()  );
ASSERT_EQ(0f  ,a2->getAnimatedFraction()  );
ASSERT_EQ(0f  ,a3->getAnimatedFraction()  );
ASSERT_TRUE(l1->endCalled);
ASSERT_EQ(0f  ,a1->getAnimatedFraction()  );
ASSERT_EQ(0f  ,a2->getAnimatedFraction()  );
ASSERT_EQ(0f  ,a3->getAnimatedFraction()  );
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_TRUE(l1->endCalled);ASSERT_EQ(0f  ,a1->getAnimatedFraction()  );ASSERT_EQ(0f  ,a2->getAnimatedFraction()  );ASSERT_EQ(0f  ,a3->getAnimatedFraction()  ); }}  );
}
//以下组件没有匹配:
//Runnable
void run()
{
lastUpdateTime=SystemClock->uptimeMillis()  ;
firstRunningFrameTime=lastUpdateTime;
startFraction=animation->getAnimatedFraction()  ;
wasRunning=animation->isRunning()  ;
if(animation->isRunning()   && !wasRunning){ firstRunningFrameTime=lastUpdateTime;startFraction=animation->getAnimatedFraction()  ;wasRunning=animation->isRunning()  ; }
wasRunning=false  ;
firstRunningFrameTime=-1  ;
lastUpdateTime=-1  ;
startFraction=0  ;
startCalled=true  ;
startTime=SystemClock->uptimeMillis()  ;
endCalled=true  ;
endTime=SystemClock->uptimeMillis()  ;
cancelCalled=true  ;
pauseCalled=true  ;
resumeCalled=true  ;
mHandler->sendEmptyMessageDelayed(MSG_FRAME,mFrameDelay);
mFrameCallbacks->add(callback);
if(!mFrameCallbacks->contains(callback)  ){ mFrameCallbacks->add(callback); }
mHandler->postDelayed(runnable,COMMIT_DELAY);
return SystemClock->uptimeMillis()  ;
return mFrameDelay;
mFrameDelay=delay;
mHandler->removeMessages(MSG_FRAME);
mHandler->sendEmptyMessageDelayed(MSG_FRAME,mFrameDelay);
if(mFrameCallbacks->size()   != 0  ){ mHandler->removeMessages(MSG_FRAME);mHandler->sendEmptyMessageDelayed(MSG_FRAME,mFrameDelay); }
Looper->prepare();
mFrameCallbacks->get(i)  -> doFrame(SystemClock->uptimeMillis()  );
for(int i=0  ;i < mFrameCallbacks->size()  ;i++){ mFrameCallbacks->get(i)  -> doFrame(SystemClock->uptimeMillis()  ); }
break;
break;
switch(msg->what){caseMSG_FRAME: for(int i=0  ;i < mFrameCallbacks->size()  ;i++){ mFrameCallbacks->get(i)  -> doFrame(SystemClock->uptimeMillis()  ); }break; default: break; }
{ switch(msg->what){caseMSG_FRAME: for(int i=0  ;i < mFrameCallbacks->size()  ;i++){ mFrameCallbacks->get(i)  -> doFrame(SystemClock->uptimeMillis()  ); }break; default: break; } }
mHandler=new Handler(){void handleMessage(Message *  msg) { { switch(msg->what){caseMSG_FRAME: for(int i=0  ;i < mFrameCallbacks->size()  ;i++){ mFrameCallbacks->get(i)  -> doFrame(SystemClock->uptimeMillis()  ); }break; default: break; } } }}  ;
Looper->loop();
a1=ValueAnimator->ofFloat(A1_START_VALUE,A1_END_VALUE)  -> setDuration(300  );
a2=ValueAnimator->ofInt(A2_START_VALUE,A2_END_VALUE)  -> setDuration(500  );
a1=null  ;
a2=null  ;
ACE_EXPORTAnimator *  a=ValueAnimator->ofFloat(5f  ,20f  )  ;
ASSERT_EQ(a->getStartDelay()  ,0  );
long delay=200  ;
a->setStartDelay(delay);
ASSERT_EQ(a->getStartDelay()  ,delay);
ValueAnimatorTests::MyUpdateListener listener=new ValueAnimatorTests::MyUpdateListener()  ;
a->AddUpdateListener(listener);
long [] startTime= newlong[1] ;
ASSERT_FALSE(a->IsRunning()  );
ASSERT_FALSE(a->IsRunning()  );
a->Play();
startTime[0]=SystemClock->uptimeMillis()  ;
ASSERT_TRUE(a->IsRunning()  );
ASSERT_FALSE(a->IsRunning()  );
ASSERT_FALSE(a->IsRunning()  );
ASSERT_FALSE(a->IsRunning()  );
a->Play();
startTime[0]=SystemClock->uptimeMillis()  ;
ASSERT_TRUE(a->IsRunning()  );
ASSERT_FALSE(a->IsRunning()  );
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_FALSE(a->IsRunning()  );ASSERT_FALSE(a->IsRunning()  );a->Play();startTime[0]=SystemClock->uptimeMillis()  ;ASSERT_TRUE(a->IsRunning()  );ASSERT_FALSE(a->IsRunning()  ); }}  );
Thread->sleep(a->getTotalDuration()  );
ASSERT_TRUE(listener->wasRunning);
ASSERT_TRUE(listener->firstRunningFrameTime - startTime[0]   >= delay);
ASSERT_TRUE(listener->wasRunning);
ASSERT_TRUE(listener->firstRunningFrameTime - startTime[0]   >= delay);
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_TRUE(listener->wasRunning);ASSERT_TRUE(listener->firstRunningFrameTime - startTime[0]   >= delay); }}  );
Thread->sleep(a->getTotalDuration()  );
ASSERT_FALSE(a->IsRunning()  );
ASSERT_FALSE(a->IsRunning()  );
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_FALSE(a->IsRunning()  ); }}  );
ValueAnimatorTests::MyListener l1=new ValueAnimatorTests::MyListener()  ;
ValueAnimatorTests::MyListener l2=new ValueAnimatorTests::MyListener()  ;
a1->addListener(l1);
a2->addListener(l2);
a2->setStartDelay(400  );
ASSERT_FALSE(l1->startCalled);
ASSERT_FALSE(l1->cancelCalled);
ASSERT_FALSE(l1->endCalled);
ASSERT_FALSE(l2->startCalled);
ASSERT_FALSE(l2->cancelCalled);
ASSERT_FALSE(l2->endCalled);
a1->Play();
a2->Play();
a1->Play();
a2->Play();
mActivityRule->runOnUiThread(new Runnable(){void run() { a1->Play();a2->Play(); }}  );
long wait=0  ;
Thread->sleep(POLL_INTERVAL);
wait+=POLL_INTERVAL;
ASSERT_FALSE(l1->cancelCalled);
a1->cancel();
ASSERT_TRUE(l1->cancelCalled);
ASSERT_TRUE(l1->endCalled);
ASSERT_FALSE(l1->cancelCalled);
a1->cancel();
ASSERT_TRUE(l1->cancelCalled);
ASSERT_TRUE(l1->endCalled);
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_FALSE(l1->cancelCalled);a1->cancel();ASSERT_TRUE(l1->cancelCalled);ASSERT_TRUE(l1->endCalled); }}  );
ASSERT_TRUE(l1->startCalled);
ASSERT_FALSE(l2->startCalled);
ASSERT_TRUE(l1->startCalled);
ASSERT_FALSE(l2->startCalled);
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_TRUE(l1->startCalled);ASSERT_FALSE(l2->startCalled); }}  );
Thread->sleep(POLL_INTERVAL);
wait+=POLL_INTERVAL;
while(wait < a2->getStartDelay()  ){ mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_TRUE(l1->startCalled);ASSERT_FALSE(l2->startCalled); }}  );Thread->sleep(POLL_INTERVAL);wait+=POLL_INTERVAL; }
long delay=Math->max(a1->getTotalDuration()  ,a2->getTotalDuration()  )   + TOLERANCE;
Thread->sleep(delay);
ASSERT_TRUE(l1->startCalled);
ASSERT_TRUE(l1->cancelCalled);
ASSERT_TRUE(l1->endCalled);
ASSERT_TRUE(l2->startCalled);
ASSERT_FALSE(l2->cancelCalled);
ASSERT_TRUE(l2->endCalled);
ASSERT_TRUE(l1->startCalled);
ASSERT_TRUE(l1->cancelCalled);
ASSERT_TRUE(l1->endCalled);
ASSERT_TRUE(l2->startCalled);
ASSERT_FALSE(l2->cancelCalled);
ASSERT_TRUE(l2->endCalled);
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_TRUE(l1->startCalled);ASSERT_TRUE(l1->cancelCalled);ASSERT_TRUE(l1->endCalled);ASSERT_TRUE(l2->startCalled);ASSERT_FALSE(l2->cancelCalled);ASSERT_TRUE(l2->endCalled); }}  );
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a2->IsRunning()  );
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a2->IsRunning()  );
long startDelay=150  ;
a1->setStartDelay(startDelay);
long [] startTime= newlong[1] ;
a1->Play();
a2->Play();
startTime[0]=SystemClock->uptimeMillis()  ;
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a2->IsRunning()  );
a1->Play();
a2->Play();
startTime[0]=SystemClock->uptimeMillis()  ;
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a2->IsRunning()  );
mActivityRule->runOnUiThread(new Runnable(){void run() { a1->Play();a2->Play();startTime[0]=SystemClock->uptimeMillis()  ;ASSERT_TRUE(a1->IsRunning()  );ASSERT_TRUE(a2->IsRunning()  ); }}  );
long delayMs=0  ;
Thread->sleep(POLL_INTERVAL);
delayMs+=POLL_INTERVAL;
ASSERT_FALSE(a1->IsRunning()  );
if(SystemClock->uptimeMillis()   - startTime[0]   < startDelay){ ASSERT_FALSE(a1->IsRunning()  ); }
ASSERT_FALSE(a1->IsRunning()  );
if(SystemClock->uptimeMillis()   - startTime[0]   < startDelay){ ASSERT_FALSE(a1->IsRunning()  ); }
mActivityRule->runOnUiThread(new Runnable(){void run() { if(SystemClock->uptimeMillis()   - startTime[0]   < startDelay){ ASSERT_FALSE(a1->IsRunning()  ); } }}  );
while(delayMs < startDelay){ Thread->sleep(POLL_INTERVAL);delayMs+=POLL_INTERVAL;mActivityRule->runOnUiThread(new Runnable(){void run() { if(SystemClock->uptimeMillis()   - startTime[0]   < startDelay){ ASSERT_FALSE(a1->IsRunning()  ); } }}  ); }
Thread->sleep(startDelay);
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a2->IsRunning()  );
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a2->IsRunning()  );
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_TRUE(a1->IsRunning()  );ASSERT_TRUE(a2->IsRunning()  ); }}  );
long delay=Math->max(a1->getTotalDuration()  ,a2->getTotalDuration()  )   * 2  ;
Thread->sleep(delay);
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a2->IsRunning()  );
ASSERT_FALSE(a2->IsRunning()  );
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a2->IsRunning()  );
ASSERT_FALSE(a2->IsRunning()  );
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_FALSE(a1->IsRunning()  );ASSERT_FALSE(a1->IsRunning()  );ASSERT_FALSE(a2->IsRunning()  );ASSERT_FALSE(a2->IsRunning()  ); }}  );
ASSERT_FALSE(a1->IsPending()  );
ASSERT_FALSE(a2->IsPending()  );
a1->Play();
a2->Play();
ASSERT_FALSE(a1->IsPending()  );
ASSERT_FALSE(a2->IsPending()  );
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a2->IsRunning()  );
ASSERT_FALSE(a1->IsPending()  );
ASSERT_FALSE(a2->IsPending()  );
a1->Play();
a2->Play();
ASSERT_FALSE(a1->IsPending()  );
ASSERT_FALSE(a2->IsPending()  );
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a2->IsRunning()  );
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_FALSE(a1->IsPending()  );ASSERT_FALSE(a2->IsPending()  );a1->Play();a2->Play();ASSERT_FALSE(a1->IsPending()  );ASSERT_FALSE(a2->IsPending()  );ASSERT_TRUE(a1->IsRunning()  );ASSERT_TRUE(a2->IsRunning()  ); }}  );
Thread->sleep(POLL_INTERVAL);
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a2->IsRunning()  );
a1->Pause();
ASSERT_TRUE(a1->IsPending()  );
ASSERT_FALSE(a2->IsPending()  );
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a2->IsRunning()  );
a1->Pause();
ASSERT_TRUE(a1->IsPending()  );
ASSERT_FALSE(a2->IsPending()  );
ASSERT_TRUE(a1->IsRunning()  );
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_TRUE(a1->IsRunning()  );ASSERT_TRUE(a2->IsRunning()  );a1->Pause();ASSERT_TRUE(a1->IsPending()  );ASSERT_FALSE(a2->IsPending()  );ASSERT_TRUE(a1->IsRunning()  ); }}  );
Thread->sleep(a2->getTotalDuration()  );
ASSERT_FALSE(a2->IsRunning()  );
ASSERT_FALSE(a2->IsRunning()  );
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a1->IsPending()  );
a1->resume();
ASSERT_FALSE(a2->IsRunning()  );
ASSERT_FALSE(a2->IsRunning()  );
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a1->IsPending()  );
a1->resume();
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_FALSE(a2->IsRunning()  );ASSERT_FALSE(a2->IsRunning()  );ASSERT_TRUE(a1->IsRunning()  );ASSERT_TRUE(a1->IsRunning()  );ASSERT_TRUE(a1->IsPending()  );a1->resume(); }}  );
Thread->sleep(POLL_INTERVAL);
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_FALSE(a1->IsPending()  );
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_FALSE(a1->IsPending()  );
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_TRUE(a1->IsRunning()  );ASSERT_TRUE(a1->IsRunning()  );ASSERT_FALSE(a1->IsPending()  ); }}  );
Thread->sleep(a1->getTotalDuration()  );
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a1->IsPending()  );
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a1->IsPending()  );
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_FALSE(a1->IsRunning()  );ASSERT_FALSE(a1->IsRunning()  );ASSERT_FALSE(a1->IsPending()  ); }}  );
ValueAnimatorTests::MyPauseListener l1=new ValueAnimatorTests::MyPauseListener()  ;
ValueAnimatorTests::MyPauseListener l2=new ValueAnimatorTests::MyPauseListener()  ;
a1->addPauseListener(l1);
a2->addPauseListener(l2);
ASSERT_FALSE(l1->pauseCalled);
ASSERT_FALSE(l1->resumeCalled);
ASSERT_FALSE(l2->pauseCalled);
ASSERT_FALSE(l2->resumeCalled);
a1->Play();
a2->Play();
a1->Play();
a2->Play();
mActivityRule->runOnUiThread(new Runnable(){void run() { a1->Play();a2->Play(); }}  );
Thread->sleep(a1->getTotalDuration()   / 2  );
a1->Pause();
Thread->sleep(a2->getTotalDuration()  );
ASSERT_TRUE(l1->pauseCalled);
ASSERT_FALSE(l1->resumeCalled);
a1->resume();
a1->resume();
mActivityRule->runOnUiThread(new Runnable(){void run() { a1->resume(); }}  );
Thread->sleep(a1->getTotalDuration()  );
ASSERT_TRUE(l1->pauseCalled);
ASSERT_TRUE(l1->resumeCalled);
ASSERT_FALSE(l2->pauseCalled);
ASSERT_FALSE(l2->resumeCalled);
ValueAnimatorTests::MyUpdateListener l1=new ValueAnimatorTests::MyUpdateListener()  ;
long totalDuration=a1->getTotalDuration()  ;
a1->AddUpdateListener(l1);
a1->setDuration(1000  );
ASSERT_TRUE(l1->firstRunningFrameTime < 0  );
ASSERT_TRUE(l1->lastUpdateTime < 0  );
long [] lastUpdate= newlong[1] ;
a1->Play();
a1->Play();
mActivityRule->runOnUiThread(new Runnable(){void run() { a1->Play(); }}  );
Thread->sleep(totalDuration / 2  );
ASSERT_TRUE(l1->firstRunningFrameTime > 0  );
ASSERT_TRUE(l1->lastUpdateTime > l1->firstRunningFrameTime);
lastUpdate[0]=l1->lastUpdateTime;
a1->Pause();
ASSERT_TRUE(l1->firstRunningFrameTime > 0  );
ASSERT_TRUE(l1->lastUpdateTime > l1->firstRunningFrameTime);
lastUpdate[0]=l1->lastUpdateTime;
a1->Pause();
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_TRUE(l1->firstRunningFrameTime > 0  );ASSERT_TRUE(l1->lastUpdateTime > l1->firstRunningFrameTime);lastUpdate[0]=l1->lastUpdateTime;a1->Pause(); }}  );
Thread->sleep(totalDuration);
ASSERT_EQ(lastUpdate[0]  ,l1->lastUpdateTime);
a1->resume();
ASSERT_EQ(lastUpdate[0]  ,l1->lastUpdateTime);
a1->resume();
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_EQ(lastUpdate[0]  ,l1->lastUpdateTime);a1->resume(); }}  );
Thread->sleep(POLL_INTERVAL);
ASSERT_TRUE(l1->lastUpdateTime > lastUpdate[0]  );
lastUpdate[0]=l1->lastUpdateTime;
ASSERT_TRUE(l1->lastUpdateTime > lastUpdate[0]  );
lastUpdate[0]=l1->lastUpdateTime;
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_TRUE(l1->lastUpdateTime > lastUpdate[0]  );lastUpdate[0]=l1->lastUpdateTime; }}  );
do{ Thread->sleep(POLL_INTERVAL);mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_TRUE(l1->lastUpdateTime > lastUpdate[0]  );lastUpdate[0]=l1->lastUpdateTime; }}  ); }while(!a1->IsRunning()  );
long entireSpan=totalDuration * 2  ;
long frameDelta=l1->lastUpdateTime - l1->firstRunningFrameTime;
ASSERT_TRUE(Math->abs(entireSpan - frameDelta)   < TOLERANCE);
ValueAnimatorTests::MyListener l1=new ValueAnimatorTests::MyListener()  ;
ValueAnimatorTests::MyListener l2=new ValueAnimatorTests::MyListener()  ;
a1->addListener(l1);
a2->addListener(l2);
anim->Cancel();
anim->Cancel();
a1->addListener(new ValueAnimatorTests::MyListener(){void onAnimationEnd(ACE_EXPORTAnimator *  anim) { anim->Cancel(); }}  );
anim->end();
anim->end();
a2->addListener(new ValueAnimatorTests::MyListener(){void onAnimationCancel(ACE_EXPORTAnimator *  anim) { anim->end(); }}  );
ASSERT_FALSE(l1->cancelCalled);
ASSERT_FALSE(l1->endCalled);
ASSERT_FALSE(l2->cancelCalled);
ASSERT_FALSE(l2->endCalled);
a1->Play();
a2->Play();
ASSERT_FALSE(l1->cancelCalled);
ASSERT_FALSE(l1->endCalled);
ASSERT_FALSE(l2->cancelCalled);
ASSERT_FALSE(l2->endCalled);
a1->Play();
a2->Play();
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_FALSE(l1->cancelCalled);ASSERT_FALSE(l1->endCalled);ASSERT_FALSE(l2->cancelCalled);ASSERT_FALSE(l2->endCalled);a1->Play();a2->Play(); }}  );
Thread->sleep(POLL_INTERVAL);
a1->Stop();
a2->cancel();
a1->Stop();
a2->cancel();
mActivityRule->runOnUiThread(new Runnable(){void run() { a1->Stop();a2->cancel(); }}  );
Thread->sleep(POLL_INTERVAL);
ASSERT_FALSE(l1->cancelCalled);
ASSERT_TRUE(l1->endCalled);
ASSERT_TRUE(l2->cancelCalled);
ASSERT_TRUE(l2->endCalled);
float value1=(Float)a1.getAnimatedValue();
int value2=(Integer)a2.getAnimatedValue();
ASSERT_EQ(A1_END_VALUE,value1);
ASSERT_EQ(A2_END_VALUE,value2);
ASSERT_FALSE(l1->cancelCalled);
ASSERT_TRUE(l1->endCalled);
ASSERT_TRUE(l2->cancelCalled);
ASSERT_TRUE(l2->endCalled);
float value1=(Float)a1.getAnimatedValue();
int value2=(Integer)a2.getAnimatedValue();
ASSERT_EQ(A1_END_VALUE,value1);
ASSERT_EQ(A2_END_VALUE,value2);
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_FALSE(l1->cancelCalled);ASSERT_TRUE(l1->endCalled);ASSERT_TRUE(l2->cancelCalled);ASSERT_TRUE(l2->endCalled);float value1=(Float)a1.getAnimatedValue();int value2=(Integer)a2.getAnimatedValue();ASSERT_EQ(A1_END_VALUE,value1);ASSERT_EQ(A2_END_VALUE,value2); }}  );
ValueAnimatorTests::MyListener l1=new ValueAnimatorTests::MyListener()  ;
a1->addListener(l1);
ValueAnimatorTests::MyListener l2=new ValueAnimatorTests::MyListener()  ;
a2->addListener(l2);
a1->Play();
a2->Play();
a1->Play();
a2->Play();
mActivityRule->runOnUiThread(new Runnable(){void run() { a1->Play();a2->Play(); }}  );
Thread->sleep(POLL_INTERVAL);
ASSERT_FALSE(l1->endCalled);
ASSERT_FALSE(l2->endCalled);
assertNotEqual(A1_END_VALUE,a1->getAnimatedValue()  );
assertNotEqual(A1_END_VALUE,a2->getAnimatedValue()  );
a2->Stop();
ASSERT_FALSE(l1->endCalled);
ASSERT_FALSE(l2->endCalled);
assertNotEqual(A1_END_VALUE,a1->getAnimatedValue()  );
assertNotEqual(A1_END_VALUE,a2->getAnimatedValue()  );
a2->Stop();
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_FALSE(l1->endCalled);ASSERT_FALSE(l2->endCalled);assertNotEqual(A1_END_VALUE,a1->getAnimatedValue()  );assertNotEqual(A1_END_VALUE,a2->getAnimatedValue()  );a2->Stop(); }}  );
Thread->sleep(a1->getTotalDuration()  );
ASSERT_FALSE(l1->cancelCalled);
ASSERT_TRUE(l1->endCalled);
ASSERT_FALSE(l2->cancelCalled);
ASSERT_TRUE(l2->endCalled);
ASSERT_EQ(A1_END_VALUE,((Float)(a1.getAnimatedValue()))  -> floatValue());
ASSERT_EQ(A2_END_VALUE,((Integer)(a2.getAnimatedValue()))  -> intValue());
ASSERT_FALSE(l1->cancelCalled);
ASSERT_TRUE(l1->endCalled);
ASSERT_FALSE(l2->cancelCalled);
ASSERT_TRUE(l2->endCalled);
ASSERT_EQ(A1_END_VALUE,((Float)(a1.getAnimatedValue()))  -> floatValue());
ASSERT_EQ(A2_END_VALUE,((Integer)(a2.getAnimatedValue()))  -> intValue());
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_FALSE(l1->cancelCalled);ASSERT_TRUE(l1->endCalled);ASSERT_FALSE(l2->cancelCalled);ASSERT_TRUE(l2->endCalled);ASSERT_EQ(A1_END_VALUE,((Float)(a1.getAnimatedValue()))  -> floatValue());ASSERT_EQ(A2_END_VALUE,((Integer)(a2.getAnimatedValue()))  -> intValue()); }}  );
ValueAnimatorTests::MyFrameCallbackProvider provider=new ValueAnimatorTests::MyFrameCallbackProvider()  ;
long sleep=0  ;
Thread->sleep(POLL_INTERVAL);
sleep+=POLL_INTERVAL;
break;
if(sleep > WAIT_TIME_OUT){ break; }
while(provider->mHandler == null  ){ Thread->sleep(POLL_INTERVAL);sleep+=POLL_INTERVAL;if(sleep > WAIT_TIME_OUT){ break; } }
assertNotNull(provider->mHandler);
ValueAnimatorTests::MyListener listener=new ValueAnimatorTests::MyListener()  ;
long currentTime=SystemClock->uptimeMillis()  ;
long frameDelay=provider->getFrameDelay()  ;
ASSERT_TRUE((currentTime-lastUpdateTime)   < frameDelay * 4  );
ASSERT_TRUE(listener->startCalled);
ASSERT_TRUE(listener->startTime > 0  );
ASSERT_TRUE(currentTime - listener->startTime < frameDelay * 4  );
if(lastUpdateTime > 0  ){ ASSERT_TRUE((currentTime-lastUpdateTime)   < frameDelay * 4  ); }else{ ASSERT_TRUE(listener->startCalled);ASSERT_TRUE(listener->startTime > 0  );ASSERT_TRUE(currentTime - listener->startTime < frameDelay * 4  ); }
super-> onAnimationUpdate(animation);
ValueAnimatorTests::MyUpdateListener l1=new ValueAnimatorTests::MyUpdateListener(){void onAnimationUpdate(ACE_EXPORTAnimator *  animation) { long currentTime=SystemClock->uptimeMillis()  ;long frameDelay=provider->getFrameDelay()  ;if(lastUpdateTime > 0  ){ ASSERT_TRUE((currentTime-lastUpdateTime)   < frameDelay * 4  ); }else{ ASSERT_TRUE(listener->startCalled);ASSERT_TRUE(listener->startTime > 0  );ASSERT_TRUE(currentTime - listener->startTime < frameDelay * 4  ); }super-> onAnimationUpdate(animation); }}  ;
a1->AddUpdateListener(l1);
a1->addListener(listener);
a1->setStartDelay(100  );
AnimationHandler->getInstance()  -> setProvider(provider);
a1->Play();
AnimationHandler->getInstance()  -> setProvider(provider);
a1->Play();
provider.mHandler->post(new Runnable(){void run() { AnimationHandler->getInstance()  -> setProvider(provider);a1->Play(); }}  );
Thread->sleep(POLL_INTERVAL);
ASSERT_TRUE(a1->IsRunning()  );
Thread->sleep(a1->getTotalDuration()   + TOLERANCE);
throwprovider->mAssertionError;
if(provider->mAssertionError != null  ){ throwprovider->mAssertionError; }
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_TRUE(listener->endTime > 0  );
ASSERT_TRUE(listener->endTime >= l1->lastUpdateTime);
ASSERT_TRUE(listener->endTime - l1->lastUpdateTime < 2   * provider->getFrameDelay()  );
ACE_EXPORTAnimator *  a0=ValueAnimator->ofInt(100  ,200  )  -> setDuration(500  );
ACE_EXPORTAnimator *  a3=ValueAnimator->ofFloat(0  ,1  )  -> setDuration(500  );
ACE_EXPORTAnimator *  a4=ValueAnimator->ofInt(200  ,300  )  -> setDuration(500  );
super-> onAnimationEnd(anim);
a0->cancel();
a1->Stop();
a3->Stop();
a4->cancel();
ValueAnimatorTests::MyListener listener=new ValueAnimatorTests::MyListener(){void onAnimationEnd(ACE_EXPORTAnimator *  anim) { super-> onAnimationEnd(anim);a0->cancel();a1->Stop();a3->Stop();a4->cancel(); }}  ;
a2->addListener(listener);
a0->Play();
a1->Play();
a2->Play();
a3->Play();
a4->Play();
a0->Play();
a1->Play();
a2->Play();
a3->Play();
a4->Play();
mActivityRule->runOnUiThread(new Runnable(){void run() { a0->Play();a1->Play();a2->Play();a3->Play();a4->Play(); }}  );
ASSERT_TRUE(a0->IsRunning()  );
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a2->IsRunning()  );
ASSERT_TRUE(a3->IsRunning()  );
ASSERT_TRUE(a4->IsRunning()  );
ASSERT_TRUE(a0->IsRunning()  );
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a2->IsRunning()  );
ASSERT_TRUE(a3->IsRunning()  );
ASSERT_TRUE(a4->IsRunning()  );
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_TRUE(a0->IsRunning()  );ASSERT_TRUE(a1->IsRunning()  );ASSERT_TRUE(a2->IsRunning()  );ASSERT_TRUE(a3->IsRunning()  );ASSERT_TRUE(a4->IsRunning()  ); }}  );
Thread->sleep(POLL_INTERVAL);
a2->Stop();
a2->Stop();
mActivityRule->runOnUiThread(new Runnable(){void run() { a2->Stop(); }}  );
Thread->sleep(POLL_INTERVAL);
ASSERT_TRUE(listener->endCalled);
ASSERT_FALSE(a0->IsRunning()  );
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a2->IsRunning()  );
ASSERT_FALSE(a3->IsRunning()  );
ASSERT_FALSE(a4->IsRunning()  );
ValueAnimatorTests::MyListener l1=new ValueAnimatorTests::MyListener()  ;
ValueAnimatorTests::MyListener l2=new ValueAnimatorTests::MyListener()  ;
ValueAnimatorTests::MyUpdateListener updateListener1=new ValueAnimatorTests::MyUpdateListener()  ;
ValueAnimatorTests::MyUpdateListener updateListener2=new ValueAnimatorTests::MyUpdateListener()  ;
float a1StartFraction=0.2f  ;
float a2StartFraction=0.3f  ;
a1->setDuration(1000  );
a2->setDuration(1000  );
a1->addListener(l1);
a2->addListener(l2);
a1->AddUpdateListener(updateListener1);
a2->AddUpdateListener(updateListener2);
//以下组件没有匹配:
//TimeInterpolator,LinearInterpolator
TimeInterpolator *  interpolator=new LinearInterpolator()  ;
a1->setInterpolator(interpolator);
a2->setInterpolator(interpolator);
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a2->IsRunning()  );
ASSERT_FALSE(a2->IsRunning()  );
a1->setCurrentFraction(a1StartFraction);
a2->setCurrentFraction(a2StartFraction);
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a2->IsRunning()  );
ASSERT_FALSE(a2->IsRunning()  );
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a2->IsRunning()  );
ASSERT_FALSE(a2->IsRunning()  );
a1->setCurrentFraction(a1StartFraction);
a2->setCurrentFraction(a2StartFraction);
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a2->IsRunning()  );
ASSERT_FALSE(a2->IsRunning()  );
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_FALSE(a1->IsRunning()  );ASSERT_FALSE(a1->IsRunning()  );ASSERT_FALSE(a2->IsRunning()  );ASSERT_FALSE(a2->IsRunning()  );a1->setCurrentFraction(a1StartFraction);a2->setCurrentFraction(a2StartFraction);ASSERT_FALSE(a1->IsRunning()  );ASSERT_FALSE(a1->IsRunning()  );ASSERT_FALSE(a2->IsRunning()  );ASSERT_FALSE(a2->IsRunning()  ); }}  );
Thread->sleep(POLL_INTERVAL);
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a2->IsRunning()  );
ASSERT_FALSE(a2->IsRunning()  );
ASSERT_EQ(a1StartFraction,a1->getAnimatedFraction()  );
ASSERT_EQ(a2StartFraction,a2->getAnimatedFraction()  );
a1->Play();
a2->Play();
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a2->IsRunning()  );
ASSERT_FALSE(a2->IsRunning()  );
ASSERT_EQ(a1StartFraction,a1->getAnimatedFraction()  );
ASSERT_EQ(a2StartFraction,a2->getAnimatedFraction()  );
a1->Play();
a2->Play();
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_FALSE(a1->IsRunning()  );ASSERT_FALSE(a1->IsRunning()  );ASSERT_FALSE(a2->IsRunning()  );ASSERT_FALSE(a2->IsRunning()  );ASSERT_EQ(a1StartFraction,a1->getAnimatedFraction()  );ASSERT_EQ(a2StartFraction,a2->getAnimatedFraction()  );a1->Play();a2->Play(); }}  );
Thread->sleep(POLL_INTERVAL);
float halfwayFraction=0.5f  ;
ASSERT_TRUE(l1->startCalled);
ASSERT_TRUE(l2->startCalled);
ASSERT_FALSE(l1->endCalled);
ASSERT_FALSE(l2->endCalled);
ASSERT_TRUE(updateListener1->startFraction >= a1StartFraction);
ASSERT_TRUE(updateListener2->startFraction >= a2StartFraction);
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a2->IsRunning()  );
ASSERT_TRUE(a2->IsRunning()  );
a1->setCurrentFraction(halfwayFraction);
a2->setCurrentFraction(halfwayFraction);
ASSERT_TRUE(l1->startCalled);
ASSERT_TRUE(l2->startCalled);
ASSERT_FALSE(l1->endCalled);
ASSERT_FALSE(l2->endCalled);
ASSERT_TRUE(updateListener1->startFraction >= a1StartFraction);
ASSERT_TRUE(updateListener2->startFraction >= a2StartFraction);
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a2->IsRunning()  );
ASSERT_TRUE(a2->IsRunning()  );
a1->setCurrentFraction(halfwayFraction);
a2->setCurrentFraction(halfwayFraction);
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_TRUE(l1->startCalled);ASSERT_TRUE(l2->startCalled);ASSERT_FALSE(l1->endCalled);ASSERT_FALSE(l2->endCalled);ASSERT_TRUE(updateListener1->startFraction >= a1StartFraction);ASSERT_TRUE(updateListener2->startFraction >= a2StartFraction);ASSERT_TRUE(a1->IsRunning()  );ASSERT_TRUE(a1->IsRunning()  );ASSERT_TRUE(a2->IsRunning()  );ASSERT_TRUE(a2->IsRunning()  );a1->setCurrentFraction(halfwayFraction);a2->setCurrentFraction(halfwayFraction); }}  );
Thread->sleep(POLL_INTERVAL);
ASSERT_TRUE(l1->startCalled);
ASSERT_TRUE(l2->startCalled);
ASSERT_FALSE(l1->endCalled);
ASSERT_FALSE(l2->endCalled);
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a2->IsRunning()  );
ASSERT_TRUE(a2->IsRunning()  );
ASSERT_TRUE(l1->startCalled);
ASSERT_TRUE(l2->startCalled);
ASSERT_FALSE(l1->endCalled);
ASSERT_FALSE(l2->endCalled);
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a2->IsRunning()  );
ASSERT_TRUE(a2->IsRunning()  );
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_TRUE(l1->startCalled);ASSERT_TRUE(l2->startCalled);ASSERT_FALSE(l1->endCalled);ASSERT_FALSE(l2->endCalled);ASSERT_TRUE(a1->IsRunning()  );ASSERT_TRUE(a1->IsRunning()  );ASSERT_TRUE(a2->IsRunning()  );ASSERT_TRUE(a2->IsRunning()  ); }}  );
long wait=Math->max(a1->getTotalDuration()  ,a2->getTotalDuration()  )  ;
Thread->sleep(wait);
ASSERT_TRUE(l1->endCalled);
ASSERT_TRUE(l2->endCalled);
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a2->IsRunning()  );
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a2->IsRunning()  );
ASSERT_TRUE(l1->endCalled);
ASSERT_TRUE(l2->endCalled);
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a2->IsRunning()  );
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a2->IsRunning()  );
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_TRUE(l1->endCalled);ASSERT_TRUE(l2->endCalled);ASSERT_FALSE(a1->IsRunning()  );ASSERT_FALSE(a2->IsRunning()  );ASSERT_FALSE(a1->IsRunning()  );ASSERT_FALSE(a2->IsRunning()  ); }}  );
updateListener1->reset();
a1->Play();
a1->Play();
mActivityRule->runOnUiThread(new Runnable(){void run() { a1->Play(); }}  );
Thread->sleep(POLL_INTERVAL);
ASSERT_TRUE(updateListener1->wasRunning);
ASSERT_TRUE(updateListener1->startFraction >= 0  );
ASSERT_TRUE(updateListener1->startFraction < halfwayFraction);
a1->Stop();
ASSERT_TRUE(updateListener1->wasRunning);
ASSERT_TRUE(updateListener1->startFraction >= 0  );
ASSERT_TRUE(updateListener1->startFraction < halfwayFraction);
a1->Stop();
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_TRUE(updateListener1->wasRunning);ASSERT_TRUE(updateListener1->startFraction >= 0  );ASSERT_TRUE(updateListener1->startFraction < halfwayFraction);a1->Stop(); }}  );
ValueAnimatorTests::MyListener l1=new ValueAnimatorTests::MyListener()  ;
ValueAnimatorTests::MyListener l2=new ValueAnimatorTests::MyListener()  ;
a1->addListener(l1);
a2->addListener(l2);
ASSERT_FALSE(l1->startCalled);
ASSERT_FALSE(l2->startCalled);
ASSERT_EQ(0f  ,a1->getAnimatedFraction()  );
ASSERT_EQ(0f  ,a2->getAnimatedFraction()  );
a1->Play();
a2->Play();
ASSERT_FALSE(l1->startCalled);
ASSERT_FALSE(l2->startCalled);
ASSERT_EQ(0f  ,a1->getAnimatedFraction()  );
ASSERT_EQ(0f  ,a2->getAnimatedFraction()  );
a1->Play();
a2->Play();
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_FALSE(l1->startCalled);ASSERT_FALSE(l2->startCalled);ASSERT_EQ(0f  ,a1->getAnimatedFraction()  );ASSERT_EQ(0f  ,a2->getAnimatedFraction()  );a1->Play();a2->Play(); }}  );
Thread->sleep(POLL_INTERVAL);
ASSERT_FALSE(l1->endCalled);
ASSERT_FALSE(l2->endCalled);
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a2->IsRunning()  );
a1->setCurrentFraction(0f  );
a2->setCurrentFraction(1f  );
ASSERT_FALSE(l1->endCalled);
ASSERT_FALSE(l2->endCalled);
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a2->IsRunning()  );
a1->setCurrentFraction(0f  );
a2->setCurrentFraction(1f  );
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_FALSE(l1->endCalled);ASSERT_FALSE(l2->endCalled);ASSERT_TRUE(a1->IsRunning()  );ASSERT_TRUE(a2->IsRunning()  );a1->setCurrentFraction(0f  );a2->setCurrentFraction(1f  ); }}  );
Thread->sleep(POLL_INTERVAL);
ASSERT_FALSE(l1->endCalled);
ASSERT_TRUE(l2->endCalled);
ASSERT_EQ(1f  ,a2->getAnimatedFraction()  );
ASSERT_FALSE(l1->endCalled);
ASSERT_TRUE(l2->endCalled);
ASSERT_EQ(1f  ,a2->getAnimatedFraction()  );
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_FALSE(l1->endCalled);ASSERT_TRUE(l2->endCalled);ASSERT_EQ(1f  ,a2->getAnimatedFraction()  ); }}  );
Thread->sleep(a1->getTotalDuration()  );
ASSERT_TRUE(l1->endCalled);
ASSERT_EQ(1f  ,a1->getAnimatedFraction()  );
ASSERT_TRUE(l1->endCalled);
ASSERT_EQ(1f  ,a1->getAnimatedFraction()  );
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_TRUE(l1->endCalled);ASSERT_EQ(1f  ,a1->getAnimatedFraction()  ); }}  );
a1->setStartDelay(20  );
ValueAnimatorTests::MyListener normalEndingListener=new ValueAnimatorTests::MyListener()  ;
a1->addListener(normalEndingListener);
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(normalEndingListener->startCalled);
ASSERT_FALSE(normalEndingListener->endCalled);
a1->Play();
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(normalEndingListener->startCalled);
ASSERT_FALSE(normalEndingListener->endCalled);
a1->Play();
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_FALSE(a1->IsRunning()  );ASSERT_FALSE(normalEndingListener->startCalled);ASSERT_FALSE(normalEndingListener->endCalled);a1->Play(); }}  );
Thread->sleep(a1->getTotalDuration()   + POLL_INTERVAL);
ValueAnimatorTests::MyListener l1=new ValueAnimatorTests::MyListener()  ;
a1->addListener(l1);
ValueAnimatorTests::MyListener l2=new ValueAnimatorTests::MyListener()  ;
a2->addListener(l2);
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(l1->startCalled);
ASSERT_FALSE(l1->endCalled);
ASSERT_FALSE(a2->IsRunning()  );
ASSERT_FALSE(l2->startCalled);
ASSERT_FALSE(l1->endCalled);
a1->Stop();
a2->Stop();
ASSERT_TRUE(l1->startCalled);
ASSERT_TRUE(l1->endCalled);
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_TRUE(l1->endTime >= l1->startTime);
ASSERT_TRUE(l2->startCalled);
ASSERT_TRUE(l2->endCalled);
ASSERT_FALSE(a2->IsRunning()  );
ASSERT_TRUE(l2->endTime >= l1->startTime);
ValueAnimatorTests::MyListener l1=new ValueAnimatorTests::MyListener()  ;
a1->addListener(l1);
ValueAnimatorTests::MyListener l2=new ValueAnimatorTests::MyListener()  ;
a2->addListener(l2);
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(l1->startCalled);
ASSERT_FALSE(l1->endCalled);
ASSERT_FALSE(a2->IsRunning()  );
ASSERT_FALSE(l2->startCalled);
ASSERT_FALSE(l1->endCalled);
a1->Stop();
a2->Stop();
ASSERT_TRUE(l1->startCalled);
ASSERT_TRUE(l1->endCalled);
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_TRUE(l1->endTime >= l1->startTime);
ASSERT_TRUE(l2->startCalled);
ASSERT_TRUE(l2->endCalled);
ASSERT_FALSE(a2->IsRunning()  );
ASSERT_TRUE(l2->endTime >= l1->startTime);
mActivityRule->runOnUiThread(new Runnable(){void run() { ValueAnimatorTests::MyListener l1=new ValueAnimatorTests::MyListener()  ;a1->addListener(l1);ValueAnimatorTests::MyListener l2=new ValueAnimatorTests::MyListener()  ;a2->addListener(l2);ASSERT_FALSE(a1->IsRunning()  );ASSERT_FALSE(l1->startCalled);ASSERT_FALSE(l1->endCalled);ASSERT_FALSE(a2->IsRunning()  );ASSERT_FALSE(l2->startCalled);ASSERT_FALSE(l1->endCalled);a1->Stop();a2->Stop();ASSERT_TRUE(l1->startCalled);ASSERT_TRUE(l1->endCalled);ASSERT_FALSE(a1->IsRunning()  );ASSERT_TRUE(l1->endTime >= l1->startTime);ASSERT_TRUE(l2->startCalled);ASSERT_TRUE(l2->endCalled);ASSERT_FALSE(a2->IsRunning()  );ASSERT_TRUE(l2->endTime >= l1->startTime); }}  );
a1->setDuration(0  );
a2->setDuration(0  );
ACE_EXPORTAnimator *  a3=ValueAnimator->ofInt(0  ,100  )  ;
a3->setDuration(0  );
a3->setCurrentFraction(1.0f  );
ASSERT_EQ(1.0f  ,a3->getAnimatedFraction()  );
ValueAnimatorTests::MyListener l1=new ValueAnimatorTests::MyListener()  ;
ValueAnimatorTests::MyListener l2=new ValueAnimatorTests::MyListener()  ;
ValueAnimatorTests::MyListener l3=new ValueAnimatorTests::MyListener()  ;
a1->addListener(l1);
a2->addListener(l2);
a3->addListener(l3);
ASSERT_FALSE(l1->startCalled);
ASSERT_FALSE(l2->startCalled);
ASSERT_FALSE(l3->startCalled);
ASSERT_FALSE(l1->endCalled);
ASSERT_FALSE(l2->endCalled);
ASSERT_FALSE(l3->endCalled);
a1->Play();
a2->reverse();
a3->Play();
ASSERT_EQ(A1_END_VALUE,a1->getAnimatedValue()  );
ASSERT_EQ(A2_START_VALUE,a2->getAnimatedValue()  );
ASSERT_FALSE(l1->startCalled);
ASSERT_FALSE(l2->startCalled);
ASSERT_FALSE(l3->startCalled);
ASSERT_FALSE(l1->endCalled);
ASSERT_FALSE(l2->endCalled);
ASSERT_FALSE(l3->endCalled);
a1->Play();
a2->reverse();
a3->Play();
ASSERT_EQ(A1_END_VALUE,a1->getAnimatedValue()  );
ASSERT_EQ(A2_START_VALUE,a2->getAnimatedValue()  );
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_FALSE(l1->startCalled);ASSERT_FALSE(l2->startCalled);ASSERT_FALSE(l3->startCalled);ASSERT_FALSE(l1->endCalled);ASSERT_FALSE(l2->endCalled);ASSERT_FALSE(l3->endCalled);a1->Play();a2->reverse();a3->Play();ASSERT_EQ(A1_END_VALUE,a1->getAnimatedValue()  );ASSERT_EQ(A2_START_VALUE,a2->getAnimatedValue()  ); }}  );
Thread->sleep(POLL_INTERVAL);
ASSERT_TRUE(l1->startCalled);
ASSERT_TRUE(l2->startCalled);
ASSERT_TRUE(l3->startCalled);
ASSERT_TRUE(l1->endCalled);
ASSERT_TRUE(l2->endCalled);
ASSERT_TRUE(l3->endCalled);
ASSERT_EQ(1.0f  ,a1->getAnimatedFraction()  );
ASSERT_EQ(0f  ,a2->getAnimatedFraction()  );
ASSERT_EQ(1f  ,a3->getAnimatedFraction()  );
ASSERT_EQ(A1_END_VALUE,a1->getAnimatedValue()  );
ASSERT_EQ(A2_START_VALUE,a2->getAnimatedValue()  );
ASSERT_EQ(100  ,a3->getAnimatedValue()  );
ASSERT_TRUE(l1->startCalled);
ASSERT_TRUE(l2->startCalled);
ASSERT_TRUE(l3->startCalled);
ASSERT_TRUE(l1->endCalled);
ASSERT_TRUE(l2->endCalled);
ASSERT_TRUE(l3->endCalled);
ASSERT_EQ(1.0f  ,a1->getAnimatedFraction()  );
ASSERT_EQ(0f  ,a2->getAnimatedFraction()  );
ASSERT_EQ(1f  ,a3->getAnimatedFraction()  );
ASSERT_EQ(A1_END_VALUE,a1->getAnimatedValue()  );
ASSERT_EQ(A2_START_VALUE,a2->getAnimatedValue()  );
ASSERT_EQ(100  ,a3->getAnimatedValue()  );
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_TRUE(l1->startCalled);ASSERT_TRUE(l2->startCalled);ASSERT_TRUE(l3->startCalled);ASSERT_TRUE(l1->endCalled);ASSERT_TRUE(l2->endCalled);ASSERT_TRUE(l3->endCalled);ASSERT_EQ(1.0f  ,a1->getAnimatedFraction()  );ASSERT_EQ(0f  ,a2->getAnimatedFraction()  );ASSERT_EQ(1f  ,a3->getAnimatedFraction()  );ASSERT_EQ(A1_END_VALUE,a1->getAnimatedValue()  );ASSERT_EQ(A2_START_VALUE,a2->getAnimatedValue()  );ASSERT_EQ(100  ,a3->getAnimatedValue()  ); }}  );
float scale=ValueAnimator->getDurationScale()  ;
ValueAnimator->setDurationScale(0f  );
a1->setStartDelay(200  );
ValueAnimatorTests::MyListener l1=new ValueAnimatorTests::MyListener()  ;
ValueAnimatorTests::MyListener l2=new ValueAnimatorTests::MyListener()  ;
a1->addListener(l1);
a2->addListener(l2);
ASSERT_FALSE(l1->startCalled);
ASSERT_FALSE(l2->startCalled);
ASSERT_FALSE(l1->endCalled);
ASSERT_FALSE(l2->endCalled);
a1->Play();
a2->Play();
ASSERT_EQ(A2_START_VALUE,a2->getAnimatedValue()  );
ASSERT_FALSE(l1->startCalled);
ASSERT_FALSE(l2->startCalled);
ASSERT_FALSE(l1->endCalled);
ASSERT_FALSE(l2->endCalled);
a1->Play();
a2->Play();
ASSERT_EQ(A2_START_VALUE,a2->getAnimatedValue()  );
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_FALSE(l1->startCalled);ASSERT_FALSE(l2->startCalled);ASSERT_FALSE(l1->endCalled);ASSERT_FALSE(l2->endCalled);a1->Play();a2->Play();ASSERT_EQ(A2_START_VALUE,a2->getAnimatedValue()  ); }}  );
Thread->sleep(POLL_INTERVAL);
ASSERT_TRUE(l1->startCalled);
ASSERT_TRUE(l2->startCalled);
ASSERT_TRUE(l1->endCalled);
ASSERT_TRUE(l2->endCalled);
ASSERT_EQ(A1_END_VALUE,a1->getAnimatedValue()  );
ASSERT_EQ(A2_END_VALUE,a2->getAnimatedValue()  );
ASSERT_TRUE(l1->startCalled);
ASSERT_TRUE(l2->startCalled);
ASSERT_TRUE(l1->endCalled);
ASSERT_TRUE(l2->endCalled);
ASSERT_EQ(A1_END_VALUE,a1->getAnimatedValue()  );
ASSERT_EQ(A2_END_VALUE,a2->getAnimatedValue()  );
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_TRUE(l1->startCalled);ASSERT_TRUE(l2->startCalled);ASSERT_TRUE(l1->endCalled);ASSERT_TRUE(l2->endCalled);ASSERT_EQ(A1_END_VALUE,a1->getAnimatedValue()  );ASSERT_EQ(A2_END_VALUE,a2->getAnimatedValue()  ); }}  );
ValueAnimator->setDurationScale(scale);
ACE_EXPORTAnimator *  a3=ValueAnimator->ofInt(0  ,100  )  ;
a1->setDuration(400  );
a2->setDuration(600  );
a3->setDuration(400  );
ValueAnimatorTests::MyListener l1=new ValueAnimatorTests::MyListener()  ;
ValueAnimatorTests::MyListener l2=new ValueAnimatorTests::MyListener()  ;
ValueAnimatorTests::MyListener l3=new ValueAnimatorTests::MyListener()  ;
a1->addListener(l1);
a2->addListener(l2);
a3->addListener(l3);
ASSERT_FALSE(l1->startCalled);
ASSERT_FALSE(l2->startCalled);
ASSERT_FALSE(l3->startCalled);
ASSERT_FALSE(l1->endCalled);
ASSERT_FALSE(l2->endCalled);
ASSERT_FALSE(l3->endCalled);
a1->reverse();
a2->reverse();
a3->reverse();
ASSERT_FALSE(l1->startCalled);
ASSERT_FALSE(l2->startCalled);
ASSERT_FALSE(l3->startCalled);
ASSERT_FALSE(l1->endCalled);
ASSERT_FALSE(l2->endCalled);
ASSERT_FALSE(l3->endCalled);
a1->reverse();
a2->reverse();
a3->reverse();
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_FALSE(l1->startCalled);ASSERT_FALSE(l2->startCalled);ASSERT_FALSE(l3->startCalled);ASSERT_FALSE(l1->endCalled);ASSERT_FALSE(l2->endCalled);ASSERT_FALSE(l3->endCalled);a1->reverse();a2->reverse();a3->reverse(); }}  );
Thread->sleep(POLL_INTERVAL);
ASSERT_TRUE(l1->startCalled);
ASSERT_TRUE(l2->startCalled);
ASSERT_TRUE(l3->startCalled);
a1->setCurrentFraction(0f  );
a2->setCurrentFraction(1f  );
a3->Stop();
ASSERT_EQ(1f  ,a1->getAnimatedFraction()  );
ASSERT_EQ(0f  ,a2->getAnimatedFraction()  );
ASSERT_TRUE(l1->startCalled);
ASSERT_TRUE(l2->startCalled);
ASSERT_TRUE(l3->startCalled);
a1->setCurrentFraction(0f  );
a2->setCurrentFraction(1f  );
a3->Stop();
ASSERT_EQ(1f  ,a1->getAnimatedFraction()  );
ASSERT_EQ(0f  ,a2->getAnimatedFraction()  );
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_TRUE(l1->startCalled);ASSERT_TRUE(l2->startCalled);ASSERT_TRUE(l3->startCalled);a1->setCurrentFraction(0f  );a2->setCurrentFraction(1f  );a3->Stop();ASSERT_EQ(1f  ,a1->getAnimatedFraction()  );ASSERT_EQ(0f  ,a2->getAnimatedFraction()  ); }}  );
Thread->sleep(POLL_INTERVAL);
ASSERT_FALSE(l1->endCalled);
ASSERT_TRUE(l2->endCalled);
ASSERT_TRUE(l3->endCalled);
ASSERT_FALSE(l1->endCalled);
ASSERT_TRUE(l2->endCalled);
ASSERT_TRUE(l3->endCalled);
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_FALSE(l1->endCalled);ASSERT_TRUE(l2->endCalled);ASSERT_TRUE(l3->endCalled); }}  );
Thread->sleep(a1->getTotalDuration()  );
ASSERT_TRUE(l1->endCalled);
ASSERT_EQ(0f  ,a1->getAnimatedFraction()  );
ASSERT_EQ(0f  ,a2->getAnimatedFraction()  );
ASSERT_EQ(0f  ,a3->getAnimatedFraction()  );
ASSERT_TRUE(l1->endCalled);
ASSERT_EQ(0f  ,a1->getAnimatedFraction()  );
ASSERT_EQ(0f  ,a2->getAnimatedFraction()  );
ASSERT_EQ(0f  ,a3->getAnimatedFraction()  );
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_TRUE(l1->endCalled);ASSERT_EQ(0f  ,a1->getAnimatedFraction()  );ASSERT_EQ(0f  ,a2->getAnimatedFraction()  );ASSERT_EQ(0f  ,a3->getAnimatedFraction()  ); }}  );
}
//以下组件没有匹配:
//Runnable
void run()
{
lastUpdateTime=SystemClock->uptimeMillis()  ;
firstRunningFrameTime=lastUpdateTime;
startFraction=animation->getAnimatedFraction()  ;
wasRunning=animation->isRunning()  ;
if(animation->isRunning()   && !wasRunning){ firstRunningFrameTime=lastUpdateTime;startFraction=animation->getAnimatedFraction()  ;wasRunning=animation->isRunning()  ; }
wasRunning=false  ;
firstRunningFrameTime=-1  ;
lastUpdateTime=-1  ;
startFraction=0  ;
startCalled=true  ;
startTime=SystemClock->uptimeMillis()  ;
endCalled=true  ;
endTime=SystemClock->uptimeMillis()  ;
cancelCalled=true  ;
pauseCalled=true  ;
resumeCalled=true  ;
mHandler->sendEmptyMessageDelayed(MSG_FRAME,mFrameDelay);
mFrameCallbacks->add(callback);
if(!mFrameCallbacks->contains(callback)  ){ mFrameCallbacks->add(callback); }
mHandler->postDelayed(runnable,COMMIT_DELAY);
return SystemClock->uptimeMillis()  ;
return mFrameDelay;
mFrameDelay=delay;
mHandler->removeMessages(MSG_FRAME);
mHandler->sendEmptyMessageDelayed(MSG_FRAME,mFrameDelay);
if(mFrameCallbacks->size()   != 0  ){ mHandler->removeMessages(MSG_FRAME);mHandler->sendEmptyMessageDelayed(MSG_FRAME,mFrameDelay); }
Looper->prepare();
mFrameCallbacks->get(i)  -> doFrame(SystemClock->uptimeMillis()  );
for(int i=0  ;i < mFrameCallbacks->size()  ;i++){ mFrameCallbacks->get(i)  -> doFrame(SystemClock->uptimeMillis()  ); }
break;
break;
switch(msg->what){caseMSG_FRAME: for(int i=0  ;i < mFrameCallbacks->size()  ;i++){ mFrameCallbacks->get(i)  -> doFrame(SystemClock->uptimeMillis()  ); }break; default: break; }
{ switch(msg->what){caseMSG_FRAME: for(int i=0  ;i < mFrameCallbacks->size()  ;i++){ mFrameCallbacks->get(i)  -> doFrame(SystemClock->uptimeMillis()  ); }break; default: break; } }
mHandler=new Handler(){void handleMessage(Message *  msg) { { switch(msg->what){caseMSG_FRAME: for(int i=0  ;i < mFrameCallbacks->size()  ;i++){ mFrameCallbacks->get(i)  -> doFrame(SystemClock->uptimeMillis()  ); }break; default: break; } } }}  ;
Looper->loop();
a1=ValueAnimator->ofFloat(A1_START_VALUE,A1_END_VALUE)  -> setDuration(300  );
a2=ValueAnimator->ofInt(A2_START_VALUE,A2_END_VALUE)  -> setDuration(500  );
a1=null  ;
a2=null  ;
ACE_EXPORTAnimator *  a=ValueAnimator->ofFloat(5f  ,20f  )  ;
ASSERT_EQ(a->getStartDelay()  ,0  );
long delay=200  ;
a->setStartDelay(delay);
ASSERT_EQ(a->getStartDelay()  ,delay);
ValueAnimatorTests::MyUpdateListener listener=new ValueAnimatorTests::MyUpdateListener()  ;
a->AddUpdateListener(listener);
long [] startTime= newlong[1] ;
ASSERT_FALSE(a->IsRunning()  );
ASSERT_FALSE(a->IsRunning()  );
a->Play();
startTime[0]=SystemClock->uptimeMillis()  ;
ASSERT_TRUE(a->IsRunning()  );
ASSERT_FALSE(a->IsRunning()  );
ASSERT_FALSE(a->IsRunning()  );
ASSERT_FALSE(a->IsRunning()  );
a->Play();
startTime[0]=SystemClock->uptimeMillis()  ;
ASSERT_TRUE(a->IsRunning()  );
ASSERT_FALSE(a->IsRunning()  );
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_FALSE(a->IsRunning()  );ASSERT_FALSE(a->IsRunning()  );a->Play();startTime[0]=SystemClock->uptimeMillis()  ;ASSERT_TRUE(a->IsRunning()  );ASSERT_FALSE(a->IsRunning()  ); }}  );
Thread->sleep(a->getTotalDuration()  );
ASSERT_TRUE(listener->wasRunning);
ASSERT_TRUE(listener->firstRunningFrameTime - startTime[0]   >= delay);
ASSERT_TRUE(listener->wasRunning);
ASSERT_TRUE(listener->firstRunningFrameTime - startTime[0]   >= delay);
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_TRUE(listener->wasRunning);ASSERT_TRUE(listener->firstRunningFrameTime - startTime[0]   >= delay); }}  );
Thread->sleep(a->getTotalDuration()  );
ASSERT_FALSE(a->IsRunning()  );
ASSERT_FALSE(a->IsRunning()  );
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_FALSE(a->IsRunning()  ); }}  );
ValueAnimatorTests::MyListener l1=new ValueAnimatorTests::MyListener()  ;
ValueAnimatorTests::MyListener l2=new ValueAnimatorTests::MyListener()  ;
a1->addListener(l1);
a2->addListener(l2);
a2->setStartDelay(400  );
ASSERT_FALSE(l1->startCalled);
ASSERT_FALSE(l1->cancelCalled);
ASSERT_FALSE(l1->endCalled);
ASSERT_FALSE(l2->startCalled);
ASSERT_FALSE(l2->cancelCalled);
ASSERT_FALSE(l2->endCalled);
a1->Play();
a2->Play();
a1->Play();
a2->Play();
mActivityRule->runOnUiThread(new Runnable(){void run() { a1->Play();a2->Play(); }}  );
long wait=0  ;
Thread->sleep(POLL_INTERVAL);
wait+=POLL_INTERVAL;
ASSERT_FALSE(l1->cancelCalled);
a1->cancel();
ASSERT_TRUE(l1->cancelCalled);
ASSERT_TRUE(l1->endCalled);
ASSERT_FALSE(l1->cancelCalled);
a1->cancel();
ASSERT_TRUE(l1->cancelCalled);
ASSERT_TRUE(l1->endCalled);
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_FALSE(l1->cancelCalled);a1->cancel();ASSERT_TRUE(l1->cancelCalled);ASSERT_TRUE(l1->endCalled); }}  );
ASSERT_TRUE(l1->startCalled);
ASSERT_FALSE(l2->startCalled);
ASSERT_TRUE(l1->startCalled);
ASSERT_FALSE(l2->startCalled);
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_TRUE(l1->startCalled);ASSERT_FALSE(l2->startCalled); }}  );
Thread->sleep(POLL_INTERVAL);
wait+=POLL_INTERVAL;
while(wait < a2->getStartDelay()  ){ mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_TRUE(l1->startCalled);ASSERT_FALSE(l2->startCalled); }}  );Thread->sleep(POLL_INTERVAL);wait+=POLL_INTERVAL; }
long delay=Math->max(a1->getTotalDuration()  ,a2->getTotalDuration()  )   + TOLERANCE;
Thread->sleep(delay);
ASSERT_TRUE(l1->startCalled);
ASSERT_TRUE(l1->cancelCalled);
ASSERT_TRUE(l1->endCalled);
ASSERT_TRUE(l2->startCalled);
ASSERT_FALSE(l2->cancelCalled);
ASSERT_TRUE(l2->endCalled);
ASSERT_TRUE(l1->startCalled);
ASSERT_TRUE(l1->cancelCalled);
ASSERT_TRUE(l1->endCalled);
ASSERT_TRUE(l2->startCalled);
ASSERT_FALSE(l2->cancelCalled);
ASSERT_TRUE(l2->endCalled);
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_TRUE(l1->startCalled);ASSERT_TRUE(l1->cancelCalled);ASSERT_TRUE(l1->endCalled);ASSERT_TRUE(l2->startCalled);ASSERT_FALSE(l2->cancelCalled);ASSERT_TRUE(l2->endCalled); }}  );
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a2->IsRunning()  );
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a2->IsRunning()  );
long startDelay=150  ;
a1->setStartDelay(startDelay);
long [] startTime= newlong[1] ;
a1->Play();
a2->Play();
startTime[0]=SystemClock->uptimeMillis()  ;
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a2->IsRunning()  );
a1->Play();
a2->Play();
startTime[0]=SystemClock->uptimeMillis()  ;
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a2->IsRunning()  );
mActivityRule->runOnUiThread(new Runnable(){void run() { a1->Play();a2->Play();startTime[0]=SystemClock->uptimeMillis()  ;ASSERT_TRUE(a1->IsRunning()  );ASSERT_TRUE(a2->IsRunning()  ); }}  );
long delayMs=0  ;
Thread->sleep(POLL_INTERVAL);
delayMs+=POLL_INTERVAL;
ASSERT_FALSE(a1->IsRunning()  );
if(SystemClock->uptimeMillis()   - startTime[0]   < startDelay){ ASSERT_FALSE(a1->IsRunning()  ); }
ASSERT_FALSE(a1->IsRunning()  );
if(SystemClock->uptimeMillis()   - startTime[0]   < startDelay){ ASSERT_FALSE(a1->IsRunning()  ); }
mActivityRule->runOnUiThread(new Runnable(){void run() { if(SystemClock->uptimeMillis()   - startTime[0]   < startDelay){ ASSERT_FALSE(a1->IsRunning()  ); } }}  );
while(delayMs < startDelay){ Thread->sleep(POLL_INTERVAL);delayMs+=POLL_INTERVAL;mActivityRule->runOnUiThread(new Runnable(){void run() { if(SystemClock->uptimeMillis()   - startTime[0]   < startDelay){ ASSERT_FALSE(a1->IsRunning()  ); } }}  ); }
Thread->sleep(startDelay);
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a2->IsRunning()  );
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a2->IsRunning()  );
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_TRUE(a1->IsRunning()  );ASSERT_TRUE(a2->IsRunning()  ); }}  );
long delay=Math->max(a1->getTotalDuration()  ,a2->getTotalDuration()  )   * 2  ;
Thread->sleep(delay);
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a2->IsRunning()  );
ASSERT_FALSE(a2->IsRunning()  );
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a2->IsRunning()  );
ASSERT_FALSE(a2->IsRunning()  );
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_FALSE(a1->IsRunning()  );ASSERT_FALSE(a1->IsRunning()  );ASSERT_FALSE(a2->IsRunning()  );ASSERT_FALSE(a2->IsRunning()  ); }}  );
ASSERT_FALSE(a1->IsPending()  );
ASSERT_FALSE(a2->IsPending()  );
a1->Play();
a2->Play();
ASSERT_FALSE(a1->IsPending()  );
ASSERT_FALSE(a2->IsPending()  );
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a2->IsRunning()  );
ASSERT_FALSE(a1->IsPending()  );
ASSERT_FALSE(a2->IsPending()  );
a1->Play();
a2->Play();
ASSERT_FALSE(a1->IsPending()  );
ASSERT_FALSE(a2->IsPending()  );
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a2->IsRunning()  );
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_FALSE(a1->IsPending()  );ASSERT_FALSE(a2->IsPending()  );a1->Play();a2->Play();ASSERT_FALSE(a1->IsPending()  );ASSERT_FALSE(a2->IsPending()  );ASSERT_TRUE(a1->IsRunning()  );ASSERT_TRUE(a2->IsRunning()  ); }}  );
Thread->sleep(POLL_INTERVAL);
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a2->IsRunning()  );
a1->Pause();
ASSERT_TRUE(a1->IsPending()  );
ASSERT_FALSE(a2->IsPending()  );
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a2->IsRunning()  );
a1->Pause();
ASSERT_TRUE(a1->IsPending()  );
ASSERT_FALSE(a2->IsPending()  );
ASSERT_TRUE(a1->IsRunning()  );
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_TRUE(a1->IsRunning()  );ASSERT_TRUE(a2->IsRunning()  );a1->Pause();ASSERT_TRUE(a1->IsPending()  );ASSERT_FALSE(a2->IsPending()  );ASSERT_TRUE(a1->IsRunning()  ); }}  );
Thread->sleep(a2->getTotalDuration()  );
ASSERT_FALSE(a2->IsRunning()  );
ASSERT_FALSE(a2->IsRunning()  );
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a1->IsPending()  );
a1->resume();
ASSERT_FALSE(a2->IsRunning()  );
ASSERT_FALSE(a2->IsRunning()  );
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a1->IsPending()  );
a1->resume();
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_FALSE(a2->IsRunning()  );ASSERT_FALSE(a2->IsRunning()  );ASSERT_TRUE(a1->IsRunning()  );ASSERT_TRUE(a1->IsRunning()  );ASSERT_TRUE(a1->IsPending()  );a1->resume(); }}  );
Thread->sleep(POLL_INTERVAL);
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_FALSE(a1->IsPending()  );
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_FALSE(a1->IsPending()  );
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_TRUE(a1->IsRunning()  );ASSERT_TRUE(a1->IsRunning()  );ASSERT_FALSE(a1->IsPending()  ); }}  );
Thread->sleep(a1->getTotalDuration()  );
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a1->IsPending()  );
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a1->IsPending()  );
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_FALSE(a1->IsRunning()  );ASSERT_FALSE(a1->IsRunning()  );ASSERT_FALSE(a1->IsPending()  ); }}  );
ValueAnimatorTests::MyPauseListener l1=new ValueAnimatorTests::MyPauseListener()  ;
ValueAnimatorTests::MyPauseListener l2=new ValueAnimatorTests::MyPauseListener()  ;
a1->addPauseListener(l1);
a2->addPauseListener(l2);
ASSERT_FALSE(l1->pauseCalled);
ASSERT_FALSE(l1->resumeCalled);
ASSERT_FALSE(l2->pauseCalled);
ASSERT_FALSE(l2->resumeCalled);
a1->Play();
a2->Play();
a1->Play();
a2->Play();
mActivityRule->runOnUiThread(new Runnable(){void run() { a1->Play();a2->Play(); }}  );
Thread->sleep(a1->getTotalDuration()   / 2  );
a1->Pause();
Thread->sleep(a2->getTotalDuration()  );
ASSERT_TRUE(l1->pauseCalled);
ASSERT_FALSE(l1->resumeCalled);
a1->resume();
a1->resume();
mActivityRule->runOnUiThread(new Runnable(){void run() { a1->resume(); }}  );
Thread->sleep(a1->getTotalDuration()  );
ASSERT_TRUE(l1->pauseCalled);
ASSERT_TRUE(l1->resumeCalled);
ASSERT_FALSE(l2->pauseCalled);
ASSERT_FALSE(l2->resumeCalled);
ValueAnimatorTests::MyUpdateListener l1=new ValueAnimatorTests::MyUpdateListener()  ;
long totalDuration=a1->getTotalDuration()  ;
a1->AddUpdateListener(l1);
a1->setDuration(1000  );
ASSERT_TRUE(l1->firstRunningFrameTime < 0  );
ASSERT_TRUE(l1->lastUpdateTime < 0  );
long [] lastUpdate= newlong[1] ;
a1->Play();
a1->Play();
mActivityRule->runOnUiThread(new Runnable(){void run() { a1->Play(); }}  );
Thread->sleep(totalDuration / 2  );
ASSERT_TRUE(l1->firstRunningFrameTime > 0  );
ASSERT_TRUE(l1->lastUpdateTime > l1->firstRunningFrameTime);
lastUpdate[0]=l1->lastUpdateTime;
a1->Pause();
ASSERT_TRUE(l1->firstRunningFrameTime > 0  );
ASSERT_TRUE(l1->lastUpdateTime > l1->firstRunningFrameTime);
lastUpdate[0]=l1->lastUpdateTime;
a1->Pause();
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_TRUE(l1->firstRunningFrameTime > 0  );ASSERT_TRUE(l1->lastUpdateTime > l1->firstRunningFrameTime);lastUpdate[0]=l1->lastUpdateTime;a1->Pause(); }}  );
Thread->sleep(totalDuration);
ASSERT_EQ(lastUpdate[0]  ,l1->lastUpdateTime);
a1->resume();
ASSERT_EQ(lastUpdate[0]  ,l1->lastUpdateTime);
a1->resume();
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_EQ(lastUpdate[0]  ,l1->lastUpdateTime);a1->resume(); }}  );
Thread->sleep(POLL_INTERVAL);
ASSERT_TRUE(l1->lastUpdateTime > lastUpdate[0]  );
lastUpdate[0]=l1->lastUpdateTime;
ASSERT_TRUE(l1->lastUpdateTime > lastUpdate[0]  );
lastUpdate[0]=l1->lastUpdateTime;
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_TRUE(l1->lastUpdateTime > lastUpdate[0]  );lastUpdate[0]=l1->lastUpdateTime; }}  );
do{ Thread->sleep(POLL_INTERVAL);mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_TRUE(l1->lastUpdateTime > lastUpdate[0]  );lastUpdate[0]=l1->lastUpdateTime; }}  ); }while(!a1->IsRunning()  );
long entireSpan=totalDuration * 2  ;
long frameDelta=l1->lastUpdateTime - l1->firstRunningFrameTime;
ASSERT_TRUE(Math->abs(entireSpan - frameDelta)   < TOLERANCE);
ValueAnimatorTests::MyListener l1=new ValueAnimatorTests::MyListener()  ;
ValueAnimatorTests::MyListener l2=new ValueAnimatorTests::MyListener()  ;
a1->addListener(l1);
a2->addListener(l2);
anim->Cancel();
anim->Cancel();
a1->addListener(new ValueAnimatorTests::MyListener(){void onAnimationEnd(ACE_EXPORTAnimator *  anim) { anim->Cancel(); }}  );
anim->end();
anim->end();
a2->addListener(new ValueAnimatorTests::MyListener(){void onAnimationCancel(ACE_EXPORTAnimator *  anim) { anim->end(); }}  );
ASSERT_FALSE(l1->cancelCalled);
ASSERT_FALSE(l1->endCalled);
ASSERT_FALSE(l2->cancelCalled);
ASSERT_FALSE(l2->endCalled);
a1->Play();
a2->Play();
ASSERT_FALSE(l1->cancelCalled);
ASSERT_FALSE(l1->endCalled);
ASSERT_FALSE(l2->cancelCalled);
ASSERT_FALSE(l2->endCalled);
a1->Play();
a2->Play();
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_FALSE(l1->cancelCalled);ASSERT_FALSE(l1->endCalled);ASSERT_FALSE(l2->cancelCalled);ASSERT_FALSE(l2->endCalled);a1->Play();a2->Play(); }}  );
Thread->sleep(POLL_INTERVAL);
a1->Stop();
a2->cancel();
a1->Stop();
a2->cancel();
mActivityRule->runOnUiThread(new Runnable(){void run() { a1->Stop();a2->cancel(); }}  );
Thread->sleep(POLL_INTERVAL);
ASSERT_FALSE(l1->cancelCalled);
ASSERT_TRUE(l1->endCalled);
ASSERT_TRUE(l2->cancelCalled);
ASSERT_TRUE(l2->endCalled);
float value1=(Float)a1.getAnimatedValue();
int value2=(Integer)a2.getAnimatedValue();
ASSERT_EQ(A1_END_VALUE,value1);
ASSERT_EQ(A2_END_VALUE,value2);
ASSERT_FALSE(l1->cancelCalled);
ASSERT_TRUE(l1->endCalled);
ASSERT_TRUE(l2->cancelCalled);
ASSERT_TRUE(l2->endCalled);
float value1=(Float)a1.getAnimatedValue();
int value2=(Integer)a2.getAnimatedValue();
ASSERT_EQ(A1_END_VALUE,value1);
ASSERT_EQ(A2_END_VALUE,value2);
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_FALSE(l1->cancelCalled);ASSERT_TRUE(l1->endCalled);ASSERT_TRUE(l2->cancelCalled);ASSERT_TRUE(l2->endCalled);float value1=(Float)a1.getAnimatedValue();int value2=(Integer)a2.getAnimatedValue();ASSERT_EQ(A1_END_VALUE,value1);ASSERT_EQ(A2_END_VALUE,value2); }}  );
ValueAnimatorTests::MyListener l1=new ValueAnimatorTests::MyListener()  ;
a1->addListener(l1);
ValueAnimatorTests::MyListener l2=new ValueAnimatorTests::MyListener()  ;
a2->addListener(l2);
a1->Play();
a2->Play();
a1->Play();
a2->Play();
mActivityRule->runOnUiThread(new Runnable(){void run() { a1->Play();a2->Play(); }}  );
Thread->sleep(POLL_INTERVAL);
ASSERT_FALSE(l1->endCalled);
ASSERT_FALSE(l2->endCalled);
assertNotEqual(A1_END_VALUE,a1->getAnimatedValue()  );
assertNotEqual(A1_END_VALUE,a2->getAnimatedValue()  );
a2->Stop();
ASSERT_FALSE(l1->endCalled);
ASSERT_FALSE(l2->endCalled);
assertNotEqual(A1_END_VALUE,a1->getAnimatedValue()  );
assertNotEqual(A1_END_VALUE,a2->getAnimatedValue()  );
a2->Stop();
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_FALSE(l1->endCalled);ASSERT_FALSE(l2->endCalled);assertNotEqual(A1_END_VALUE,a1->getAnimatedValue()  );assertNotEqual(A1_END_VALUE,a2->getAnimatedValue()  );a2->Stop(); }}  );
Thread->sleep(a1->getTotalDuration()  );
ASSERT_FALSE(l1->cancelCalled);
ASSERT_TRUE(l1->endCalled);
ASSERT_FALSE(l2->cancelCalled);
ASSERT_TRUE(l2->endCalled);
ASSERT_EQ(A1_END_VALUE,((Float)(a1.getAnimatedValue()))  -> floatValue());
ASSERT_EQ(A2_END_VALUE,((Integer)(a2.getAnimatedValue()))  -> intValue());
ASSERT_FALSE(l1->cancelCalled);
ASSERT_TRUE(l1->endCalled);
ASSERT_FALSE(l2->cancelCalled);
ASSERT_TRUE(l2->endCalled);
ASSERT_EQ(A1_END_VALUE,((Float)(a1.getAnimatedValue()))  -> floatValue());
ASSERT_EQ(A2_END_VALUE,((Integer)(a2.getAnimatedValue()))  -> intValue());
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_FALSE(l1->cancelCalled);ASSERT_TRUE(l1->endCalled);ASSERT_FALSE(l2->cancelCalled);ASSERT_TRUE(l2->endCalled);ASSERT_EQ(A1_END_VALUE,((Float)(a1.getAnimatedValue()))  -> floatValue());ASSERT_EQ(A2_END_VALUE,((Integer)(a2.getAnimatedValue()))  -> intValue()); }}  );
ValueAnimatorTests::MyFrameCallbackProvider provider=new ValueAnimatorTests::MyFrameCallbackProvider()  ;
long sleep=0  ;
Thread->sleep(POLL_INTERVAL);
sleep+=POLL_INTERVAL;
break;
if(sleep > WAIT_TIME_OUT){ break; }
while(provider->mHandler == null  ){ Thread->sleep(POLL_INTERVAL);sleep+=POLL_INTERVAL;if(sleep > WAIT_TIME_OUT){ break; } }
assertNotNull(provider->mHandler);
ValueAnimatorTests::MyListener listener=new ValueAnimatorTests::MyListener()  ;
long currentTime=SystemClock->uptimeMillis()  ;
long frameDelay=provider->getFrameDelay()  ;
ASSERT_TRUE((currentTime-lastUpdateTime)   < frameDelay * 4  );
ASSERT_TRUE(listener->startCalled);
ASSERT_TRUE(listener->startTime > 0  );
ASSERT_TRUE(currentTime - listener->startTime < frameDelay * 4  );
if(lastUpdateTime > 0  ){ ASSERT_TRUE((currentTime-lastUpdateTime)   < frameDelay * 4  ); }else{ ASSERT_TRUE(listener->startCalled);ASSERT_TRUE(listener->startTime > 0  );ASSERT_TRUE(currentTime - listener->startTime < frameDelay * 4  ); }
super-> onAnimationUpdate(animation);
ValueAnimatorTests::MyUpdateListener l1=new ValueAnimatorTests::MyUpdateListener(){void onAnimationUpdate(ACE_EXPORTAnimator *  animation) { long currentTime=SystemClock->uptimeMillis()  ;long frameDelay=provider->getFrameDelay()  ;if(lastUpdateTime > 0  ){ ASSERT_TRUE((currentTime-lastUpdateTime)   < frameDelay * 4  ); }else{ ASSERT_TRUE(listener->startCalled);ASSERT_TRUE(listener->startTime > 0  );ASSERT_TRUE(currentTime - listener->startTime < frameDelay * 4  ); }super-> onAnimationUpdate(animation); }}  ;
a1->AddUpdateListener(l1);
a1->addListener(listener);
a1->setStartDelay(100  );
AnimationHandler->getInstance()  -> setProvider(provider);
a1->Play();
AnimationHandler->getInstance()  -> setProvider(provider);
a1->Play();
provider.mHandler->post(new Runnable(){void run() { AnimationHandler->getInstance()  -> setProvider(provider);a1->Play(); }}  );
Thread->sleep(POLL_INTERVAL);
ASSERT_TRUE(a1->IsRunning()  );
Thread->sleep(a1->getTotalDuration()   + TOLERANCE);
throwprovider->mAssertionError;
if(provider->mAssertionError != null  ){ throwprovider->mAssertionError; }
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_TRUE(listener->endTime > 0  );
ASSERT_TRUE(listener->endTime >= l1->lastUpdateTime);
ASSERT_TRUE(listener->endTime - l1->lastUpdateTime < 2   * provider->getFrameDelay()  );
ACE_EXPORTAnimator *  a0=ValueAnimator->ofInt(100  ,200  )  -> setDuration(500  );
ACE_EXPORTAnimator *  a3=ValueAnimator->ofFloat(0  ,1  )  -> setDuration(500  );
ACE_EXPORTAnimator *  a4=ValueAnimator->ofInt(200  ,300  )  -> setDuration(500  );
super-> onAnimationEnd(anim);
a0->cancel();
a1->Stop();
a3->Stop();
a4->cancel();
ValueAnimatorTests::MyListener listener=new ValueAnimatorTests::MyListener(){void onAnimationEnd(ACE_EXPORTAnimator *  anim) { super-> onAnimationEnd(anim);a0->cancel();a1->Stop();a3->Stop();a4->cancel(); }}  ;
a2->addListener(listener);
a0->Play();
a1->Play();
a2->Play();
a3->Play();
a4->Play();
a0->Play();
a1->Play();
a2->Play();
a3->Play();
a4->Play();
mActivityRule->runOnUiThread(new Runnable(){void run() { a0->Play();a1->Play();a2->Play();a3->Play();a4->Play(); }}  );
ASSERT_TRUE(a0->IsRunning()  );
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a2->IsRunning()  );
ASSERT_TRUE(a3->IsRunning()  );
ASSERT_TRUE(a4->IsRunning()  );
ASSERT_TRUE(a0->IsRunning()  );
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a2->IsRunning()  );
ASSERT_TRUE(a3->IsRunning()  );
ASSERT_TRUE(a4->IsRunning()  );
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_TRUE(a0->IsRunning()  );ASSERT_TRUE(a1->IsRunning()  );ASSERT_TRUE(a2->IsRunning()  );ASSERT_TRUE(a3->IsRunning()  );ASSERT_TRUE(a4->IsRunning()  ); }}  );
Thread->sleep(POLL_INTERVAL);
a2->Stop();
a2->Stop();
mActivityRule->runOnUiThread(new Runnable(){void run() { a2->Stop(); }}  );
Thread->sleep(POLL_INTERVAL);
ASSERT_TRUE(listener->endCalled);
ASSERT_FALSE(a0->IsRunning()  );
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a2->IsRunning()  );
ASSERT_FALSE(a3->IsRunning()  );
ASSERT_FALSE(a4->IsRunning()  );
ValueAnimatorTests::MyListener l1=new ValueAnimatorTests::MyListener()  ;
ValueAnimatorTests::MyListener l2=new ValueAnimatorTests::MyListener()  ;
ValueAnimatorTests::MyUpdateListener updateListener1=new ValueAnimatorTests::MyUpdateListener()  ;
ValueAnimatorTests::MyUpdateListener updateListener2=new ValueAnimatorTests::MyUpdateListener()  ;
float a1StartFraction=0.2f  ;
float a2StartFraction=0.3f  ;
a1->setDuration(1000  );
a2->setDuration(1000  );
a1->addListener(l1);
a2->addListener(l2);
a1->AddUpdateListener(updateListener1);
a2->AddUpdateListener(updateListener2);
//以下组件没有匹配:
//TimeInterpolator,LinearInterpolator
TimeInterpolator *  interpolator=new LinearInterpolator()  ;
a1->setInterpolator(interpolator);
a2->setInterpolator(interpolator);
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a2->IsRunning()  );
ASSERT_FALSE(a2->IsRunning()  );
a1->setCurrentFraction(a1StartFraction);
a2->setCurrentFraction(a2StartFraction);
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a2->IsRunning()  );
ASSERT_FALSE(a2->IsRunning()  );
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a2->IsRunning()  );
ASSERT_FALSE(a2->IsRunning()  );
a1->setCurrentFraction(a1StartFraction);
a2->setCurrentFraction(a2StartFraction);
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a2->IsRunning()  );
ASSERT_FALSE(a2->IsRunning()  );
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_FALSE(a1->IsRunning()  );ASSERT_FALSE(a1->IsRunning()  );ASSERT_FALSE(a2->IsRunning()  );ASSERT_FALSE(a2->IsRunning()  );a1->setCurrentFraction(a1StartFraction);a2->setCurrentFraction(a2StartFraction);ASSERT_FALSE(a1->IsRunning()  );ASSERT_FALSE(a1->IsRunning()  );ASSERT_FALSE(a2->IsRunning()  );ASSERT_FALSE(a2->IsRunning()  ); }}  );
Thread->sleep(POLL_INTERVAL);
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a2->IsRunning()  );
ASSERT_FALSE(a2->IsRunning()  );
ASSERT_EQ(a1StartFraction,a1->getAnimatedFraction()  );
ASSERT_EQ(a2StartFraction,a2->getAnimatedFraction()  );
a1->Play();
a2->Play();
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a2->IsRunning()  );
ASSERT_FALSE(a2->IsRunning()  );
ASSERT_EQ(a1StartFraction,a1->getAnimatedFraction()  );
ASSERT_EQ(a2StartFraction,a2->getAnimatedFraction()  );
a1->Play();
a2->Play();
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_FALSE(a1->IsRunning()  );ASSERT_FALSE(a1->IsRunning()  );ASSERT_FALSE(a2->IsRunning()  );ASSERT_FALSE(a2->IsRunning()  );ASSERT_EQ(a1StartFraction,a1->getAnimatedFraction()  );ASSERT_EQ(a2StartFraction,a2->getAnimatedFraction()  );a1->Play();a2->Play(); }}  );
Thread->sleep(POLL_INTERVAL);
float halfwayFraction=0.5f  ;
ASSERT_TRUE(l1->startCalled);
ASSERT_TRUE(l2->startCalled);
ASSERT_FALSE(l1->endCalled);
ASSERT_FALSE(l2->endCalled);
ASSERT_TRUE(updateListener1->startFraction >= a1StartFraction);
ASSERT_TRUE(updateListener2->startFraction >= a2StartFraction);
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a2->IsRunning()  );
ASSERT_TRUE(a2->IsRunning()  );
a1->setCurrentFraction(halfwayFraction);
a2->setCurrentFraction(halfwayFraction);
ASSERT_TRUE(l1->startCalled);
ASSERT_TRUE(l2->startCalled);
ASSERT_FALSE(l1->endCalled);
ASSERT_FALSE(l2->endCalled);
ASSERT_TRUE(updateListener1->startFraction >= a1StartFraction);
ASSERT_TRUE(updateListener2->startFraction >= a2StartFraction);
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a2->IsRunning()  );
ASSERT_TRUE(a2->IsRunning()  );
a1->setCurrentFraction(halfwayFraction);
a2->setCurrentFraction(halfwayFraction);
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_TRUE(l1->startCalled);ASSERT_TRUE(l2->startCalled);ASSERT_FALSE(l1->endCalled);ASSERT_FALSE(l2->endCalled);ASSERT_TRUE(updateListener1->startFraction >= a1StartFraction);ASSERT_TRUE(updateListener2->startFraction >= a2StartFraction);ASSERT_TRUE(a1->IsRunning()  );ASSERT_TRUE(a1->IsRunning()  );ASSERT_TRUE(a2->IsRunning()  );ASSERT_TRUE(a2->IsRunning()  );a1->setCurrentFraction(halfwayFraction);a2->setCurrentFraction(halfwayFraction); }}  );
Thread->sleep(POLL_INTERVAL);
ASSERT_TRUE(l1->startCalled);
ASSERT_TRUE(l2->startCalled);
ASSERT_FALSE(l1->endCalled);
ASSERT_FALSE(l2->endCalled);
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a2->IsRunning()  );
ASSERT_TRUE(a2->IsRunning()  );
ASSERT_TRUE(l1->startCalled);
ASSERT_TRUE(l2->startCalled);
ASSERT_FALSE(l1->endCalled);
ASSERT_FALSE(l2->endCalled);
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a2->IsRunning()  );
ASSERT_TRUE(a2->IsRunning()  );
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_TRUE(l1->startCalled);ASSERT_TRUE(l2->startCalled);ASSERT_FALSE(l1->endCalled);ASSERT_FALSE(l2->endCalled);ASSERT_TRUE(a1->IsRunning()  );ASSERT_TRUE(a1->IsRunning()  );ASSERT_TRUE(a2->IsRunning()  );ASSERT_TRUE(a2->IsRunning()  ); }}  );
long wait=Math->max(a1->getTotalDuration()  ,a2->getTotalDuration()  )  ;
Thread->sleep(wait);
ASSERT_TRUE(l1->endCalled);
ASSERT_TRUE(l2->endCalled);
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a2->IsRunning()  );
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a2->IsRunning()  );
ASSERT_TRUE(l1->endCalled);
ASSERT_TRUE(l2->endCalled);
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a2->IsRunning()  );
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(a2->IsRunning()  );
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_TRUE(l1->endCalled);ASSERT_TRUE(l2->endCalled);ASSERT_FALSE(a1->IsRunning()  );ASSERT_FALSE(a2->IsRunning()  );ASSERT_FALSE(a1->IsRunning()  );ASSERT_FALSE(a2->IsRunning()  ); }}  );
updateListener1->reset();
a1->Play();
a1->Play();
mActivityRule->runOnUiThread(new Runnable(){void run() { a1->Play(); }}  );
Thread->sleep(POLL_INTERVAL);
ASSERT_TRUE(updateListener1->wasRunning);
ASSERT_TRUE(updateListener1->startFraction >= 0  );
ASSERT_TRUE(updateListener1->startFraction < halfwayFraction);
a1->Stop();
ASSERT_TRUE(updateListener1->wasRunning);
ASSERT_TRUE(updateListener1->startFraction >= 0  );
ASSERT_TRUE(updateListener1->startFraction < halfwayFraction);
a1->Stop();
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_TRUE(updateListener1->wasRunning);ASSERT_TRUE(updateListener1->startFraction >= 0  );ASSERT_TRUE(updateListener1->startFraction < halfwayFraction);a1->Stop(); }}  );
ValueAnimatorTests::MyListener l1=new ValueAnimatorTests::MyListener()  ;
ValueAnimatorTests::MyListener l2=new ValueAnimatorTests::MyListener()  ;
a1->addListener(l1);
a2->addListener(l2);
ASSERT_FALSE(l1->startCalled);
ASSERT_FALSE(l2->startCalled);
ASSERT_EQ(0f  ,a1->getAnimatedFraction()  );
ASSERT_EQ(0f  ,a2->getAnimatedFraction()  );
a1->Play();
a2->Play();
ASSERT_FALSE(l1->startCalled);
ASSERT_FALSE(l2->startCalled);
ASSERT_EQ(0f  ,a1->getAnimatedFraction()  );
ASSERT_EQ(0f  ,a2->getAnimatedFraction()  );
a1->Play();
a2->Play();
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_FALSE(l1->startCalled);ASSERT_FALSE(l2->startCalled);ASSERT_EQ(0f  ,a1->getAnimatedFraction()  );ASSERT_EQ(0f  ,a2->getAnimatedFraction()  );a1->Play();a2->Play(); }}  );
Thread->sleep(POLL_INTERVAL);
ASSERT_FALSE(l1->endCalled);
ASSERT_FALSE(l2->endCalled);
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a2->IsRunning()  );
a1->setCurrentFraction(0f  );
a2->setCurrentFraction(1f  );
ASSERT_FALSE(l1->endCalled);
ASSERT_FALSE(l2->endCalled);
ASSERT_TRUE(a1->IsRunning()  );
ASSERT_TRUE(a2->IsRunning()  );
a1->setCurrentFraction(0f  );
a2->setCurrentFraction(1f  );
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_FALSE(l1->endCalled);ASSERT_FALSE(l2->endCalled);ASSERT_TRUE(a1->IsRunning()  );ASSERT_TRUE(a2->IsRunning()  );a1->setCurrentFraction(0f  );a2->setCurrentFraction(1f  ); }}  );
Thread->sleep(POLL_INTERVAL);
ASSERT_FALSE(l1->endCalled);
ASSERT_TRUE(l2->endCalled);
ASSERT_EQ(1f  ,a2->getAnimatedFraction()  );
ASSERT_FALSE(l1->endCalled);
ASSERT_TRUE(l2->endCalled);
ASSERT_EQ(1f  ,a2->getAnimatedFraction()  );
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_FALSE(l1->endCalled);ASSERT_TRUE(l2->endCalled);ASSERT_EQ(1f  ,a2->getAnimatedFraction()  ); }}  );
Thread->sleep(a1->getTotalDuration()  );
ASSERT_TRUE(l1->endCalled);
ASSERT_EQ(1f  ,a1->getAnimatedFraction()  );
ASSERT_TRUE(l1->endCalled);
ASSERT_EQ(1f  ,a1->getAnimatedFraction()  );
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_TRUE(l1->endCalled);ASSERT_EQ(1f  ,a1->getAnimatedFraction()  ); }}  );
a1->setStartDelay(20  );
ValueAnimatorTests::MyListener normalEndingListener=new ValueAnimatorTests::MyListener()  ;
a1->addListener(normalEndingListener);
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(normalEndingListener->startCalled);
ASSERT_FALSE(normalEndingListener->endCalled);
a1->Play();
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(normalEndingListener->startCalled);
ASSERT_FALSE(normalEndingListener->endCalled);
a1->Play();
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_FALSE(a1->IsRunning()  );ASSERT_FALSE(normalEndingListener->startCalled);ASSERT_FALSE(normalEndingListener->endCalled);a1->Play(); }}  );
Thread->sleep(a1->getTotalDuration()   + POLL_INTERVAL);
ValueAnimatorTests::MyListener l1=new ValueAnimatorTests::MyListener()  ;
a1->addListener(l1);
ValueAnimatorTests::MyListener l2=new ValueAnimatorTests::MyListener()  ;
a2->addListener(l2);
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(l1->startCalled);
ASSERT_FALSE(l1->endCalled);
ASSERT_FALSE(a2->IsRunning()  );
ASSERT_FALSE(l2->startCalled);
ASSERT_FALSE(l1->endCalled);
a1->Stop();
a2->Stop();
ASSERT_TRUE(l1->startCalled);
ASSERT_TRUE(l1->endCalled);
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_TRUE(l1->endTime >= l1->startTime);
ASSERT_TRUE(l2->startCalled);
ASSERT_TRUE(l2->endCalled);
ASSERT_FALSE(a2->IsRunning()  );
ASSERT_TRUE(l2->endTime >= l1->startTime);
ValueAnimatorTests::MyListener l1=new ValueAnimatorTests::MyListener()  ;
a1->addListener(l1);
ValueAnimatorTests::MyListener l2=new ValueAnimatorTests::MyListener()  ;
a2->addListener(l2);
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_FALSE(l1->startCalled);
ASSERT_FALSE(l1->endCalled);
ASSERT_FALSE(a2->IsRunning()  );
ASSERT_FALSE(l2->startCalled);
ASSERT_FALSE(l1->endCalled);
a1->Stop();
a2->Stop();
ASSERT_TRUE(l1->startCalled);
ASSERT_TRUE(l1->endCalled);
ASSERT_FALSE(a1->IsRunning()  );
ASSERT_TRUE(l1->endTime >= l1->startTime);
ASSERT_TRUE(l2->startCalled);
ASSERT_TRUE(l2->endCalled);
ASSERT_FALSE(a2->IsRunning()  );
ASSERT_TRUE(l2->endTime >= l1->startTime);
mActivityRule->runOnUiThread(new Runnable(){void run() { ValueAnimatorTests::MyListener l1=new ValueAnimatorTests::MyListener()  ;a1->addListener(l1);ValueAnimatorTests::MyListener l2=new ValueAnimatorTests::MyListener()  ;a2->addListener(l2);ASSERT_FALSE(a1->IsRunning()  );ASSERT_FALSE(l1->startCalled);ASSERT_FALSE(l1->endCalled);ASSERT_FALSE(a2->IsRunning()  );ASSERT_FALSE(l2->startCalled);ASSERT_FALSE(l1->endCalled);a1->Stop();a2->Stop();ASSERT_TRUE(l1->startCalled);ASSERT_TRUE(l1->endCalled);ASSERT_FALSE(a1->IsRunning()  );ASSERT_TRUE(l1->endTime >= l1->startTime);ASSERT_TRUE(l2->startCalled);ASSERT_TRUE(l2->endCalled);ASSERT_FALSE(a2->IsRunning()  );ASSERT_TRUE(l2->endTime >= l1->startTime); }}  );
a1->setDuration(0  );
a2->setDuration(0  );
ACE_EXPORTAnimator *  a3=ValueAnimator->ofInt(0  ,100  )  ;
a3->setDuration(0  );
a3->setCurrentFraction(1.0f  );
ASSERT_EQ(1.0f  ,a3->getAnimatedFraction()  );
ValueAnimatorTests::MyListener l1=new ValueAnimatorTests::MyListener()  ;
ValueAnimatorTests::MyListener l2=new ValueAnimatorTests::MyListener()  ;
ValueAnimatorTests::MyListener l3=new ValueAnimatorTests::MyListener()  ;
a1->addListener(l1);
a2->addListener(l2);
a3->addListener(l3);
ASSERT_FALSE(l1->startCalled);
ASSERT_FALSE(l2->startCalled);
ASSERT_FALSE(l3->startCalled);
ASSERT_FALSE(l1->endCalled);
ASSERT_FALSE(l2->endCalled);
ASSERT_FALSE(l3->endCalled);
a1->Play();
a2->reverse();
a3->Play();
ASSERT_EQ(A1_END_VALUE,a1->getAnimatedValue()  );
ASSERT_EQ(A2_START_VALUE,a2->getAnimatedValue()  );
ASSERT_FALSE(l1->startCalled);
ASSERT_FALSE(l2->startCalled);
ASSERT_FALSE(l3->startCalled);
ASSERT_FALSE(l1->endCalled);
ASSERT_FALSE(l2->endCalled);
ASSERT_FALSE(l3->endCalled);
a1->Play();
a2->reverse();
a3->Play();
ASSERT_EQ(A1_END_VALUE,a1->getAnimatedValue()  );
ASSERT_EQ(A2_START_VALUE,a2->getAnimatedValue()  );
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_FALSE(l1->startCalled);ASSERT_FALSE(l2->startCalled);ASSERT_FALSE(l3->startCalled);ASSERT_FALSE(l1->endCalled);ASSERT_FALSE(l2->endCalled);ASSERT_FALSE(l3->endCalled);a1->Play();a2->reverse();a3->Play();ASSERT_EQ(A1_END_VALUE,a1->getAnimatedValue()  );ASSERT_EQ(A2_START_VALUE,a2->getAnimatedValue()  ); }}  );
Thread->sleep(POLL_INTERVAL);
ASSERT_TRUE(l1->startCalled);
ASSERT_TRUE(l2->startCalled);
ASSERT_TRUE(l3->startCalled);
ASSERT_TRUE(l1->endCalled);
ASSERT_TRUE(l2->endCalled);
ASSERT_TRUE(l3->endCalled);
ASSERT_EQ(1.0f  ,a1->getAnimatedFraction()  );
ASSERT_EQ(0f  ,a2->getAnimatedFraction()  );
ASSERT_EQ(1f  ,a3->getAnimatedFraction()  );
ASSERT_EQ(A1_END_VALUE,a1->getAnimatedValue()  );
ASSERT_EQ(A2_START_VALUE,a2->getAnimatedValue()  );
ASSERT_EQ(100  ,a3->getAnimatedValue()  );
ASSERT_TRUE(l1->startCalled);
ASSERT_TRUE(l2->startCalled);
ASSERT_TRUE(l3->startCalled);
ASSERT_TRUE(l1->endCalled);
ASSERT_TRUE(l2->endCalled);
ASSERT_TRUE(l3->endCalled);
ASSERT_EQ(1.0f  ,a1->getAnimatedFraction()  );
ASSERT_EQ(0f  ,a2->getAnimatedFraction()  );
ASSERT_EQ(1f  ,a3->getAnimatedFraction()  );
ASSERT_EQ(A1_END_VALUE,a1->getAnimatedValue()  );
ASSERT_EQ(A2_START_VALUE,a2->getAnimatedValue()  );
ASSERT_EQ(100  ,a3->getAnimatedValue()  );
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_TRUE(l1->startCalled);ASSERT_TRUE(l2->startCalled);ASSERT_TRUE(l3->startCalled);ASSERT_TRUE(l1->endCalled);ASSERT_TRUE(l2->endCalled);ASSERT_TRUE(l3->endCalled);ASSERT_EQ(1.0f  ,a1->getAnimatedFraction()  );ASSERT_EQ(0f  ,a2->getAnimatedFraction()  );ASSERT_EQ(1f  ,a3->getAnimatedFraction()  );ASSERT_EQ(A1_END_VALUE,a1->getAnimatedValue()  );ASSERT_EQ(A2_START_VALUE,a2->getAnimatedValue()  );ASSERT_EQ(100  ,a3->getAnimatedValue()  ); }}  );
float scale=ValueAnimator->getDurationScale()  ;
ValueAnimator->setDurationScale(0f  );
a1->setStartDelay(200  );
ValueAnimatorTests::MyListener l1=new ValueAnimatorTests::MyListener()  ;
ValueAnimatorTests::MyListener l2=new ValueAnimatorTests::MyListener()  ;
a1->addListener(l1);
a2->addListener(l2);
ASSERT_FALSE(l1->startCalled);
ASSERT_FALSE(l2->startCalled);
ASSERT_FALSE(l1->endCalled);
ASSERT_FALSE(l2->endCalled);
a1->Play();
a2->Play();
ASSERT_EQ(A2_START_VALUE,a2->getAnimatedValue()  );
ASSERT_FALSE(l1->startCalled);
ASSERT_FALSE(l2->startCalled);
ASSERT_FALSE(l1->endCalled);
ASSERT_FALSE(l2->endCalled);
a1->Play();
a2->Play();
ASSERT_EQ(A2_START_VALUE,a2->getAnimatedValue()  );
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_FALSE(l1->startCalled);ASSERT_FALSE(l2->startCalled);ASSERT_FALSE(l1->endCalled);ASSERT_FALSE(l2->endCalled);a1->Play();a2->Play();ASSERT_EQ(A2_START_VALUE,a2->getAnimatedValue()  ); }}  );
Thread->sleep(POLL_INTERVAL);
ASSERT_TRUE(l1->startCalled);
ASSERT_TRUE(l2->startCalled);
ASSERT_TRUE(l1->endCalled);
ASSERT_TRUE(l2->endCalled);
ASSERT_EQ(A1_END_VALUE,a1->getAnimatedValue()  );
ASSERT_EQ(A2_END_VALUE,a2->getAnimatedValue()  );
ASSERT_TRUE(l1->startCalled);
ASSERT_TRUE(l2->startCalled);
ASSERT_TRUE(l1->endCalled);
ASSERT_TRUE(l2->endCalled);
ASSERT_EQ(A1_END_VALUE,a1->getAnimatedValue()  );
ASSERT_EQ(A2_END_VALUE,a2->getAnimatedValue()  );
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_TRUE(l1->startCalled);ASSERT_TRUE(l2->startCalled);ASSERT_TRUE(l1->endCalled);ASSERT_TRUE(l2->endCalled);ASSERT_EQ(A1_END_VALUE,a1->getAnimatedValue()  );ASSERT_EQ(A2_END_VALUE,a2->getAnimatedValue()  ); }}  );
ValueAnimator->setDurationScale(scale);
ACE_EXPORTAnimator *  a3=ValueAnimator->ofInt(0  ,100  )  ;
a1->setDuration(400  );
a2->setDuration(600  );
a3->setDuration(400  );
ValueAnimatorTests::MyListener l1=new ValueAnimatorTests::MyListener()  ;
ValueAnimatorTests::MyListener l2=new ValueAnimatorTests::MyListener()  ;
ValueAnimatorTests::MyListener l3=new ValueAnimatorTests::MyListener()  ;
a1->addListener(l1);
a2->addListener(l2);
a3->addListener(l3);
ASSERT_FALSE(l1->startCalled);
ASSERT_FALSE(l2->startCalled);
ASSERT_FALSE(l3->startCalled);
ASSERT_FALSE(l1->endCalled);
ASSERT_FALSE(l2->endCalled);
ASSERT_FALSE(l3->endCalled);
a1->reverse();
a2->reverse();
a3->reverse();
ASSERT_FALSE(l1->startCalled);
ASSERT_FALSE(l2->startCalled);
ASSERT_FALSE(l3->startCalled);
ASSERT_FALSE(l1->endCalled);
ASSERT_FALSE(l2->endCalled);
ASSERT_FALSE(l3->endCalled);
a1->reverse();
a2->reverse();
a3->reverse();
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_FALSE(l1->startCalled);ASSERT_FALSE(l2->startCalled);ASSERT_FALSE(l3->startCalled);ASSERT_FALSE(l1->endCalled);ASSERT_FALSE(l2->endCalled);ASSERT_FALSE(l3->endCalled);a1->reverse();a2->reverse();a3->reverse(); }}  );
Thread->sleep(POLL_INTERVAL);
ASSERT_TRUE(l1->startCalled);
ASSERT_TRUE(l2->startCalled);
ASSERT_TRUE(l3->startCalled);
a1->setCurrentFraction(0f  );
a2->setCurrentFraction(1f  );
a3->Stop();
ASSERT_EQ(1f  ,a1->getAnimatedFraction()  );
ASSERT_EQ(0f  ,a2->getAnimatedFraction()  );
ASSERT_TRUE(l1->startCalled);
ASSERT_TRUE(l2->startCalled);
ASSERT_TRUE(l3->startCalled);
a1->setCurrentFraction(0f  );
a2->setCurrentFraction(1f  );
a3->Stop();
ASSERT_EQ(1f  ,a1->getAnimatedFraction()  );
ASSERT_EQ(0f  ,a2->getAnimatedFraction()  );
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_TRUE(l1->startCalled);ASSERT_TRUE(l2->startCalled);ASSERT_TRUE(l3->startCalled);a1->setCurrentFraction(0f  );a2->setCurrentFraction(1f  );a3->Stop();ASSERT_EQ(1f  ,a1->getAnimatedFraction()  );ASSERT_EQ(0f  ,a2->getAnimatedFraction()  ); }}  );
Thread->sleep(POLL_INTERVAL);
ASSERT_FALSE(l1->endCalled);
ASSERT_TRUE(l2->endCalled);
ASSERT_TRUE(l3->endCalled);
ASSERT_FALSE(l1->endCalled);
ASSERT_TRUE(l2->endCalled);
ASSERT_TRUE(l3->endCalled);
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_FALSE(l1->endCalled);ASSERT_TRUE(l2->endCalled);ASSERT_TRUE(l3->endCalled); }}  );
Thread->sleep(a1->getTotalDuration()  );
ASSERT_TRUE(l1->endCalled);
ASSERT_EQ(0f  ,a1->getAnimatedFraction()  );
ASSERT_EQ(0f  ,a2->getAnimatedFraction()  );
ASSERT_EQ(0f  ,a3->getAnimatedFraction()  );
ASSERT_TRUE(l1->endCalled);
ASSERT_EQ(0f  ,a1->getAnimatedFraction()  );
ASSERT_EQ(0f  ,a2->getAnimatedFraction()  );
ASSERT_EQ(0f  ,a3->getAnimatedFraction()  );
mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_TRUE(l1->endCalled);ASSERT_EQ(0f  ,a1->getAnimatedFraction()  );ASSERT_EQ(0f  ,a2->getAnimatedFraction()  );ASSERT_EQ(0f  ,a3->getAnimatedFraction()  ); }}  );
}
void setUp(){a1=ValueAnimator->ofFloat(A1_START_VALUE,A1_END_VALUE)  -> setDuration(300  );a2=ValueAnimator->ofInt(A2_START_VALUE,A2_END_VALUE)  -> setDuration(500  );}
void tearDown(){a1=null  ;a2=null  ;}
void testStartDelay(){ACE_EXPORTAnimator *  a=ValueAnimator->ofFloat(5f  ,20f  )  ;ASSERT_EQ(a->getStartDelay()  ,0  );long delay=200  ;a->setStartDelay(delay);ASSERT_EQ(a->getStartDelay()  ,delay);ValueAnimatorTests::MyUpdateListener listener=new ValueAnimatorTests::MyUpdateListener()  ;a->AddUpdateListener(listener);long [] startTime= newlong[1] ;mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_FALSE(a->IsRunning()  );ASSERT_FALSE(a->IsRunning()  );a->Play();startTime[0]=SystemClock->uptimeMillis()  ;ASSERT_TRUE(a->IsRunning()  );ASSERT_FALSE(a->IsRunning()  ); }}  );Thread->sleep(a->getTotalDuration()  );mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_TRUE(listener->wasRunning);ASSERT_TRUE(listener->firstRunningFrameTime - startTime[0]   >= delay); }}  );Thread->sleep(a->getTotalDuration()  );mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_FALSE(a->IsRunning()  ); }}  );}
void testListenerCallbacks(){ValueAnimatorTests::MyListener l1=new ValueAnimatorTests::MyListener()  ;ValueAnimatorTests::MyListener l2=new ValueAnimatorTests::MyListener()  ;a1->addListener(l1);a2->addListener(l2);a2->setStartDelay(400  );ASSERT_FALSE(l1->startCalled);ASSERT_FALSE(l1->cancelCalled);ASSERT_FALSE(l1->endCalled);ASSERT_FALSE(l2->startCalled);ASSERT_FALSE(l2->cancelCalled);ASSERT_FALSE(l2->endCalled);mActivityRule->runOnUiThread(new Runnable(){void run() { a1->Play();a2->Play(); }}  );long wait=0  ;Thread->sleep(POLL_INTERVAL);wait+=POLL_INTERVAL;mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_FALSE(l1->cancelCalled);a1->cancel();ASSERT_TRUE(l1->cancelCalled);ASSERT_TRUE(l1->endCalled); }}  );while(wait < a2->getStartDelay()  ){ mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_TRUE(l1->startCalled);ASSERT_FALSE(l2->startCalled); }}  );Thread->sleep(POLL_INTERVAL);wait+=POLL_INTERVAL; }long delay=Math->max(a1->getTotalDuration()  ,a2->getTotalDuration()  )   + TOLERANCE;Thread->sleep(delay);mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_TRUE(l1->startCalled);ASSERT_TRUE(l1->cancelCalled);ASSERT_TRUE(l1->endCalled);ASSERT_TRUE(l2->startCalled);ASSERT_FALSE(l2->cancelCalled);ASSERT_TRUE(l2->endCalled); }}  );}
void testIsStarted(){ASSERT_FALSE(a1->IsRunning()  );ASSERT_FALSE(a2->IsRunning()  );ASSERT_FALSE(a1->IsRunning()  );ASSERT_FALSE(a2->IsRunning()  );long startDelay=150  ;a1->setStartDelay(startDelay);long [] startTime= newlong[1] ;mActivityRule->runOnUiThread(new Runnable(){void run() { a1->Play();a2->Play();startTime[0]=SystemClock->uptimeMillis()  ;ASSERT_TRUE(a1->IsRunning()  );ASSERT_TRUE(a2->IsRunning()  ); }}  );long delayMs=0  ;while(delayMs < startDelay){ Thread->sleep(POLL_INTERVAL);delayMs+=POLL_INTERVAL;mActivityRule->runOnUiThread(new Runnable(){void run() { if(SystemClock->uptimeMillis()   - startTime[0]   < startDelay){ ASSERT_FALSE(a1->IsRunning()  ); } }}  ); }Thread->sleep(startDelay);mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_TRUE(a1->IsRunning()  );ASSERT_TRUE(a2->IsRunning()  ); }}  );long delay=Math->max(a1->getTotalDuration()  ,a2->getTotalDuration()  )   * 2  ;Thread->sleep(delay);mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_FALSE(a1->IsRunning()  );ASSERT_FALSE(a1->IsRunning()  );ASSERT_FALSE(a2->IsRunning()  );ASSERT_FALSE(a2->IsRunning()  ); }}  );}
void testPause(){mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_FALSE(a1->IsPending()  );ASSERT_FALSE(a2->IsPending()  );a1->Play();a2->Play();ASSERT_FALSE(a1->IsPending()  );ASSERT_FALSE(a2->IsPending()  );ASSERT_TRUE(a1->IsRunning()  );ASSERT_TRUE(a2->IsRunning()  ); }}  );Thread->sleep(POLL_INTERVAL);mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_TRUE(a1->IsRunning()  );ASSERT_TRUE(a2->IsRunning()  );a1->Pause();ASSERT_TRUE(a1->IsPending()  );ASSERT_FALSE(a2->IsPending()  );ASSERT_TRUE(a1->IsRunning()  ); }}  );Thread->sleep(a2->getTotalDuration()  );mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_FALSE(a2->IsRunning()  );ASSERT_FALSE(a2->IsRunning()  );ASSERT_TRUE(a1->IsRunning()  );ASSERT_TRUE(a1->IsRunning()  );ASSERT_TRUE(a1->IsPending()  );a1->resume(); }}  );Thread->sleep(POLL_INTERVAL);mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_TRUE(a1->IsRunning()  );ASSERT_TRUE(a1->IsRunning()  );ASSERT_FALSE(a1->IsPending()  ); }}  );Thread->sleep(a1->getTotalDuration()  );mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_FALSE(a1->IsRunning()  );ASSERT_FALSE(a1->IsRunning()  );ASSERT_FALSE(a1->IsPending()  ); }}  );}
void testPauseListener(){ValueAnimatorTests::MyPauseListener l1=new ValueAnimatorTests::MyPauseListener()  ;ValueAnimatorTests::MyPauseListener l2=new ValueAnimatorTests::MyPauseListener()  ;a1->addPauseListener(l1);a2->addPauseListener(l2);ASSERT_FALSE(l1->pauseCalled);ASSERT_FALSE(l1->resumeCalled);ASSERT_FALSE(l2->pauseCalled);ASSERT_FALSE(l2->resumeCalled);mActivityRule->runOnUiThread(new Runnable(){void run() { a1->Play();a2->Play(); }}  );Thread->sleep(a1->getTotalDuration()   / 2  );a1->Pause();Thread->sleep(a2->getTotalDuration()  );ASSERT_TRUE(l1->pauseCalled);ASSERT_FALSE(l1->resumeCalled);mActivityRule->runOnUiThread(new Runnable(){void run() { a1->resume(); }}  );Thread->sleep(a1->getTotalDuration()  );ASSERT_TRUE(l1->pauseCalled);ASSERT_TRUE(l1->resumeCalled);ASSERT_FALSE(l2->pauseCalled);ASSERT_FALSE(l2->resumeCalled);}
void testResume(){ValueAnimatorTests::MyUpdateListener l1=new ValueAnimatorTests::MyUpdateListener()  ;long totalDuration=a1->getTotalDuration()  ;a1->AddUpdateListener(l1);a1->setDuration(1000  );ASSERT_TRUE(l1->firstRunningFrameTime < 0  );ASSERT_TRUE(l1->lastUpdateTime < 0  );long [] lastUpdate= newlong[1] ;mActivityRule->runOnUiThread(new Runnable(){void run() { a1->Play(); }}  );Thread->sleep(totalDuration / 2  );mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_TRUE(l1->firstRunningFrameTime > 0  );ASSERT_TRUE(l1->lastUpdateTime > l1->firstRunningFrameTime);lastUpdate[0]=l1->lastUpdateTime;a1->Pause(); }}  );Thread->sleep(totalDuration);mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_EQ(lastUpdate[0]  ,l1->lastUpdateTime);a1->resume(); }}  );do{ Thread->sleep(POLL_INTERVAL);mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_TRUE(l1->lastUpdateTime > lastUpdate[0]  );lastUpdate[0]=l1->lastUpdateTime; }}  ); }while(!a1->IsRunning()  );long entireSpan=totalDuration * 2  ;long frameDelta=l1->lastUpdateTime - l1->firstRunningFrameTime;ASSERT_TRUE(Math->abs(entireSpan - frameDelta)   < TOLERANCE);}
void testEnd(){ValueAnimatorTests::MyListener l1=new ValueAnimatorTests::MyListener()  ;ValueAnimatorTests::MyListener l2=new ValueAnimatorTests::MyListener()  ;a1->addListener(l1);a2->addListener(l2);a1->addListener(new ValueAnimatorTests::MyListener(){void onAnimationEnd(ACE_EXPORTAnimator *  anim) { anim->Cancel(); }}  );a2->addListener(new ValueAnimatorTests::MyListener(){void onAnimationCancel(ACE_EXPORTAnimator *  anim) { anim->end(); }}  );mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_FALSE(l1->cancelCalled);ASSERT_FALSE(l1->endCalled);ASSERT_FALSE(l2->cancelCalled);ASSERT_FALSE(l2->endCalled);a1->Play();a2->Play(); }}  );Thread->sleep(POLL_INTERVAL);mActivityRule->runOnUiThread(new Runnable(){void run() { a1->Stop();a2->cancel(); }}  );Thread->sleep(POLL_INTERVAL);mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_FALSE(l1->cancelCalled);ASSERT_TRUE(l1->endCalled);ASSERT_TRUE(l2->cancelCalled);ASSERT_TRUE(l2->endCalled);float value1=(Float)a1.getAnimatedValue();int value2=(Integer)a2.getAnimatedValue();ASSERT_EQ(A1_END_VALUE,value1);ASSERT_EQ(A2_END_VALUE,value2); }}  );}
void testEndValue(){ValueAnimatorTests::MyListener l1=new ValueAnimatorTests::MyListener()  ;a1->addListener(l1);ValueAnimatorTests::MyListener l2=new ValueAnimatorTests::MyListener()  ;a2->addListener(l2);mActivityRule->runOnUiThread(new Runnable(){void run() { a1->Play();a2->Play(); }}  );Thread->sleep(POLL_INTERVAL);mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_FALSE(l1->endCalled);ASSERT_FALSE(l2->endCalled);assertNotEqual(A1_END_VALUE,a1->getAnimatedValue()  );assertNotEqual(A1_END_VALUE,a2->getAnimatedValue()  );a2->Stop(); }}  );Thread->sleep(a1->getTotalDuration()  );mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_FALSE(l1->cancelCalled);ASSERT_TRUE(l1->endCalled);ASSERT_FALSE(l2->cancelCalled);ASSERT_TRUE(l2->endCalled);ASSERT_EQ(A1_END_VALUE,((Float)(a1.getAnimatedValue()))  -> floatValue());ASSERT_EQ(A2_END_VALUE,((Integer)(a2.getAnimatedValue()))  -> intValue()); }}  );}
void testUpdateListener(){ValueAnimatorTests::MyFrameCallbackProvider provider=new ValueAnimatorTests::MyFrameCallbackProvider()  ;long sleep=0  ;while(provider->mHandler == null  ){ Thread->sleep(POLL_INTERVAL);sleep+=POLL_INTERVAL;if(sleep > WAIT_TIME_OUT){ break; } }assertNotNull(provider->mHandler);ValueAnimatorTests::MyListener listener=new ValueAnimatorTests::MyListener()  ;ValueAnimatorTests::MyUpdateListener l1=new ValueAnimatorTests::MyUpdateListener(){void onAnimationUpdate(ACE_EXPORTAnimator *  animation) { long currentTime=SystemClock->uptimeMillis()  ;long frameDelay=provider->getFrameDelay()  ;if(lastUpdateTime > 0  ){ ASSERT_TRUE((currentTime-lastUpdateTime)   < frameDelay * 4  ); }else{ ASSERT_TRUE(listener->startCalled);ASSERT_TRUE(listener->startTime > 0  );ASSERT_TRUE(currentTime - listener->startTime < frameDelay * 4  ); }super-> onAnimationUpdate(animation); }}  ;a1->AddUpdateListener(l1);a1->addListener(listener);a1->setStartDelay(100  );provider.mHandler->post(new Runnable(){void run() { AnimationHandler->getInstance()  -> setProvider(provider);a1->Play(); }}  );Thread->sleep(POLL_INTERVAL);ASSERT_TRUE(a1->IsRunning()  );Thread->sleep(a1->getTotalDuration()   + TOLERANCE);if(provider->mAssertionError != null  ){ throwprovider->mAssertionError; }ASSERT_FALSE(a1->IsRunning()  );ASSERT_TRUE(listener->endTime > 0  );ASSERT_TRUE(listener->endTime >= l1->lastUpdateTime);ASSERT_TRUE(listener->endTime - l1->lastUpdateTime < 2   * provider->getFrameDelay()  );}
void testConcurrentModification(){ACE_EXPORTAnimator *  a0=ValueAnimator->ofInt(100  ,200  )  -> setDuration(500  );ACE_EXPORTAnimator *  a3=ValueAnimator->ofFloat(0  ,1  )  -> setDuration(500  );ACE_EXPORTAnimator *  a4=ValueAnimator->ofInt(200  ,300  )  -> setDuration(500  );ValueAnimatorTests::MyListener listener=new ValueAnimatorTests::MyListener(){void onAnimationEnd(ACE_EXPORTAnimator *  anim) { super-> onAnimationEnd(anim);a0->cancel();a1->Stop();a3->Stop();a4->cancel(); }}  ;a2->addListener(listener);mActivityRule->runOnUiThread(new Runnable(){void run() { a0->Play();a1->Play();a2->Play();a3->Play();a4->Play(); }}  );mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_TRUE(a0->IsRunning()  );ASSERT_TRUE(a1->IsRunning()  );ASSERT_TRUE(a2->IsRunning()  );ASSERT_TRUE(a3->IsRunning()  );ASSERT_TRUE(a4->IsRunning()  ); }}  );Thread->sleep(POLL_INTERVAL);mActivityRule->runOnUiThread(new Runnable(){void run() { a2->Stop(); }}  );Thread->sleep(POLL_INTERVAL);ASSERT_TRUE(listener->endCalled);ASSERT_FALSE(a0->IsRunning()  );ASSERT_FALSE(a1->IsRunning()  );ASSERT_FALSE(a2->IsRunning()  );ASSERT_FALSE(a3->IsRunning()  );ASSERT_FALSE(a4->IsRunning()  );}
void testSeek(){ValueAnimatorTests::MyListener l1=new ValueAnimatorTests::MyListener()  ;ValueAnimatorTests::MyListener l2=new ValueAnimatorTests::MyListener()  ;ValueAnimatorTests::MyUpdateListener updateListener1=new ValueAnimatorTests::MyUpdateListener()  ;ValueAnimatorTests::MyUpdateListener updateListener2=new ValueAnimatorTests::MyUpdateListener()  ;float a1StartFraction=0.2f  ;float a2StartFraction=0.3f  ;a1->setDuration(1000  );a2->setDuration(1000  );a1->addListener(l1);a2->addListener(l2);a1->AddUpdateListener(updateListener1);a2->AddUpdateListener(updateListener2);}
void testSeekWhileRunning(){ValueAnimatorTests::MyListener l1=new ValueAnimatorTests::MyListener()  ;ValueAnimatorTests::MyListener l2=new ValueAnimatorTests::MyListener()  ;a1->addListener(l1);a2->addListener(l2);mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_FALSE(l1->startCalled);ASSERT_FALSE(l2->startCalled);ASSERT_EQ(0f  ,a1->getAnimatedFraction()  );ASSERT_EQ(0f  ,a2->getAnimatedFraction()  );a1->Play();a2->Play(); }}  );Thread->sleep(POLL_INTERVAL);mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_FALSE(l1->endCalled);ASSERT_FALSE(l2->endCalled);ASSERT_TRUE(a1->IsRunning()  );ASSERT_TRUE(a2->IsRunning()  );a1->setCurrentFraction(0f  );a2->setCurrentFraction(1f  ); }}  );Thread->sleep(POLL_INTERVAL);mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_FALSE(l1->endCalled);ASSERT_TRUE(l2->endCalled);ASSERT_EQ(1f  ,a2->getAnimatedFraction()  ); }}  );Thread->sleep(a1->getTotalDuration()  );mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_TRUE(l1->endCalled);ASSERT_EQ(1f  ,a1->getAnimatedFraction()  ); }}  );}
void testEndBeforeStart(){a1->setStartDelay(20  );ValueAnimatorTests::MyListener normalEndingListener=new ValueAnimatorTests::MyListener()  ;a1->addListener(normalEndingListener);mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_FALSE(a1->IsRunning()  );ASSERT_FALSE(normalEndingListener->startCalled);ASSERT_FALSE(normalEndingListener->endCalled);a1->Play(); }}  );Thread->sleep(a1->getTotalDuration()   + POLL_INTERVAL);mActivityRule->runOnUiThread(new Runnable(){void run() { ValueAnimatorTests::MyListener l1=new ValueAnimatorTests::MyListener()  ;a1->addListener(l1);ValueAnimatorTests::MyListener l2=new ValueAnimatorTests::MyListener()  ;a2->addListener(l2);ASSERT_FALSE(a1->IsRunning()  );ASSERT_FALSE(l1->startCalled);ASSERT_FALSE(l1->endCalled);ASSERT_FALSE(a2->IsRunning()  );ASSERT_FALSE(l2->startCalled);ASSERT_FALSE(l1->endCalled);a1->Stop();a2->Stop();ASSERT_TRUE(l1->startCalled);ASSERT_TRUE(l1->endCalled);ASSERT_FALSE(a1->IsRunning()  );ASSERT_TRUE(l1->endTime >= l1->startTime);ASSERT_TRUE(l2->startCalled);ASSERT_TRUE(l2->endCalled);ASSERT_FALSE(a2->IsRunning()  );ASSERT_TRUE(l2->endTime >= l1->startTime); }}  );}
void testZeroDuration(){a1->setDuration(0  );a2->setDuration(0  );ACE_EXPORTAnimator *  a3=ValueAnimator->ofInt(0  ,100  )  ;a3->setDuration(0  );a3->setCurrentFraction(1.0f  );ASSERT_EQ(1.0f  ,a3->getAnimatedFraction()  );ValueAnimatorTests::MyListener l1=new ValueAnimatorTests::MyListener()  ;ValueAnimatorTests::MyListener l2=new ValueAnimatorTests::MyListener()  ;ValueAnimatorTests::MyListener l3=new ValueAnimatorTests::MyListener()  ;a1->addListener(l1);a2->addListener(l2);a3->addListener(l3);mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_FALSE(l1->startCalled);ASSERT_FALSE(l2->startCalled);ASSERT_FALSE(l3->startCalled);ASSERT_FALSE(l1->endCalled);ASSERT_FALSE(l2->endCalled);ASSERT_FALSE(l3->endCalled);a1->Play();a2->reverse();a3->Play();ASSERT_EQ(A1_END_VALUE,a1->getAnimatedValue()  );ASSERT_EQ(A2_START_VALUE,a2->getAnimatedValue()  ); }}  );Thread->sleep(POLL_INTERVAL);mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_TRUE(l1->startCalled);ASSERT_TRUE(l2->startCalled);ASSERT_TRUE(l3->startCalled);ASSERT_TRUE(l1->endCalled);ASSERT_TRUE(l2->endCalled);ASSERT_TRUE(l3->endCalled);ASSERT_EQ(1.0f  ,a1->getAnimatedFraction()  );ASSERT_EQ(0f  ,a2->getAnimatedFraction()  );ASSERT_EQ(1f  ,a3->getAnimatedFraction()  );ASSERT_EQ(A1_END_VALUE,a1->getAnimatedValue()  );ASSERT_EQ(A2_START_VALUE,a2->getAnimatedValue()  );ASSERT_EQ(100  ,a3->getAnimatedValue()  ); }}  );}
void testZeroScale(){float scale=ValueAnimator->getDurationScale()  ;ValueAnimator->setDurationScale(0f  );a1->setStartDelay(200  );ValueAnimatorTests::MyListener l1=new ValueAnimatorTests::MyListener()  ;ValueAnimatorTests::MyListener l2=new ValueAnimatorTests::MyListener()  ;a1->addListener(l1);a2->addListener(l2);mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_FALSE(l1->startCalled);ASSERT_FALSE(l2->startCalled);ASSERT_FALSE(l1->endCalled);ASSERT_FALSE(l2->endCalled);a1->Play();a2->Play();ASSERT_EQ(A2_START_VALUE,a2->getAnimatedValue()  ); }}  );Thread->sleep(POLL_INTERVAL);mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_TRUE(l1->startCalled);ASSERT_TRUE(l2->startCalled);ASSERT_TRUE(l1->endCalled);ASSERT_TRUE(l2->endCalled);ASSERT_EQ(A1_END_VALUE,a1->getAnimatedValue()  );ASSERT_EQ(A2_END_VALUE,a2->getAnimatedValue()  ); }}  );ValueAnimator->setDurationScale(scale);}
void testReverse(){ACE_EXPORTAnimator *  a3=ValueAnimator->ofInt(0  ,100  )  ;a1->setDuration(400  );a2->setDuration(600  );a3->setDuration(400  );ValueAnimatorTests::MyListener l1=new ValueAnimatorTests::MyListener()  ;ValueAnimatorTests::MyListener l2=new ValueAnimatorTests::MyListener()  ;ValueAnimatorTests::MyListener l3=new ValueAnimatorTests::MyListener()  ;a1->addListener(l1);a2->addListener(l2);a3->addListener(l3);mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_FALSE(l1->startCalled);ASSERT_FALSE(l2->startCalled);ASSERT_FALSE(l3->startCalled);ASSERT_FALSE(l1->endCalled);ASSERT_FALSE(l2->endCalled);ASSERT_FALSE(l3->endCalled);a1->reverse();a2->reverse();a3->reverse(); }}  );Thread->sleep(POLL_INTERVAL);mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_TRUE(l1->startCalled);ASSERT_TRUE(l2->startCalled);ASSERT_TRUE(l3->startCalled);a1->setCurrentFraction(0f  );a2->setCurrentFraction(1f  );a3->Stop();ASSERT_EQ(1f  ,a1->getAnimatedFraction()  );ASSERT_EQ(0f  ,a2->getAnimatedFraction()  ); }}  );Thread->sleep(POLL_INTERVAL);mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_FALSE(l1->endCalled);ASSERT_TRUE(l2->endCalled);ASSERT_TRUE(l3->endCalled); }}  );Thread->sleep(a1->getTotalDuration()  );mActivityRule->runOnUiThread(new Runnable(){void run() { ASSERT_TRUE(l1->endCalled);ASSERT_EQ(0f  ,a1->getAnimatedFraction()  );ASSERT_EQ(0f  ,a2->getAnimatedFraction()  );ASSERT_EQ(0f  ,a3->getAnimatedFraction()  ); }}  );}
}
